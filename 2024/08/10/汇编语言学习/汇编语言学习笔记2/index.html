<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>汇编语言学习笔记2 | G00DBrain blog</title><meta name="author" content="GoodBrain"><meta name="copyright" content="GoodBrain"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="汇编语言学习笔记2实验七 就是将一数据段拆开放进另一个数据段，但是有很多坑，建议自己写出来了再对比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152assume cs:adata segmentdb &#x27;1975&#x27;,&#x27;1976&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言学习笔记2">
<meta property="og:url" content="http://example.com/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="G00DBrain blog">
<meta property="og:description" content="汇编语言学习笔记2实验七 就是将一数据段拆开放进另一个数据段，但是有很多坑，建议自己写出来了再对比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152assume cs:adata segmentdb &#x27;1975&#x27;,&#x27;1976&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg">
<meta property="article:published_time" content="2024-08-09T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-10T11:32:04.749Z">
<meta property="article:author" content="GoodBrain">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "汇编语言学习笔记2",
  "url": "http://example.com/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
  "image": "https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg",
  "datePublished": "2024-08-09T16:00:00.000Z",
  "dateModified": "2025-03-10T11:32:04.749Z",
  "author": [
    {
      "@type": "Person",
      "name": "GoodBrain",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg"><link rel="canonical" href="http://example.com/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言学习笔记2',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">G00DBrain blog</span></a><a class="nav-page-title" href="/"><span class="site-name">汇编语言学习笔记2</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言学习笔记2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-09T16:00:00.000Z" title="发表于 2024-08-10 00:00:00">2024-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-10T11:32:04.749Z" title="更新于 2025-03-10 19:32:04">2025-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">汇编语言学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">27.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>99分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="汇编语言学习笔记2"><a href="#汇编语言学习笔记2" class="headerlink" title="汇编语言学习笔记2"></a>汇编语言学习笔记2</h1><p><strong>实验七</strong></p>
<p>就是将一数据段拆开放进另一个数据段，但是有很多坑，建议自己写出来了再对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:a</span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax,table</span><br><span class="line">		mov es,ax</span><br><span class="line">		mov si,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov bp,168</span><br><span class="line">		mov cx,21</span><br><span class="line">	s:  push cx</span><br><span class="line">		mov di,0</span><br><span class="line">		mov cx,4</span><br><span class="line">	s0: mov al,ds:[si]</span><br><span class="line">	    mov es:[bx+di],al</span><br><span class="line">		mov al,ds:[si+84]</span><br><span class="line">		mov es:[bx+di+5],al</span><br><span class="line">		inc si</span><br><span class="line">		inc di</span><br><span class="line">		loop s0</span><br><span class="line">	    mov ax,ds:[bp]</span><br><span class="line">	    mov es:[bx+10],ax</span><br><span class="line">		mov dx,es:[bx+7]</span><br><span class="line">		mov ax,es:[bx+5]</span><br><span class="line">		div word ptr es:[bx+10]</span><br><span class="line">		mov es:[bx+13],ax</span><br><span class="line">		add bp,2</span><br><span class="line">		add bx,16</span><br><span class="line">		pop cx</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line"></span><br><span class="line">a ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724030139876.png" alt="image-20240724030139876"></p>
<h2 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h2><ul>
<li>8086cpu的转移指令分为以下几类<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h3 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h3><ul>
<li>操作符offset在汇编语言中是由编译器处理的符号，他的功能是取得标号的偏移地址</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codeseg segment</span><br><span class="line">start:mov ax,offset start //相当于 mov ax,0  start这条指令的偏移地址是0</span><br><span class="line">s:    mov ax,offset s     //相当于mov ax.3   s这条指令的偏移地址是3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>实验</strong></p>
<p>将s处的指令复制到s0处</p>
<ol>
<li>代码</li>
</ol>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724122910500.png" alt="image-20240724122910500"></p>
<ol start="2">
<li>实现</li>
</ol>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724122902202.png" alt="image-20240724122902202"></p>
<p><strong>如果代码指令过长ax放不下怎么办</strong></p>
<p><strong>小实验</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724202506276.png" alt="image-20240724202506276"></p>
<p>我们编写一个机器码有4个字节的代码</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724202611625.png" alt="image-20240724202611625"></p>
<p>再进行debug调试，在调试的过程中我们发现，由于指令过长所以只存放了前面两个字节的数据，如果说以后我们真的需要offset来转移指令应当注意被转移指令的长度</p>
<h3 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h3><ul>
<li><p><code>jmp</code>为无条件转移，可以只修改<code>IP</code>，也可以同时修改<code>CS:IP</code></p>
</li>
<li><p><code>jmp</code>指令要给出两种信息</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移，段内短转移，段内近转移）</li>
</ul>
</li>
</ul>
<h3 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h3><ul>
<li><pre><code>jmp short 标号（转移标号处执行指令）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  这种格式的 jmp 指令实现的是段内**短**转移，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。(为什么负数可以到-128，详情请看原码，补码，反码的学习)</span><br><span class="line"></span><br><span class="line">  **示例**</span><br><span class="line"></span><br><span class="line">  ![image-20240724124350840](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124350840.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724124422603](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124422603.png)</span><br><span class="line"></span><br><span class="line">  程序执行后，ax中的值为1，因为执行jmp shorts后，越过了add ax,1 ，IP 指向了标号 s处的 inc ax。也就是说，程序只进行了一次ax加01操作。</span><br><span class="line"></span><br><span class="line">* 汇编指令jmp short s 对应的机器指令</span><br><span class="line"></span><br><span class="line">  1. 先观察一下其他的指令于机器码</span><br><span class="line"></span><br><span class="line">  ![image-20240724124754961](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124754961.png)</span><br><span class="line"></span><br><span class="line">  可以看到，在一般的汇编指会中，汇编指会中的idata(立即数)，不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指会，它必须要处理这些数据或地址。</span><br><span class="line"></span><br><span class="line">  2. 再看看jmp short s 对应的机器指令</span><br><span class="line"></span><br><span class="line">     ![image-20240724125315581](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724125315581.png)</span><br><span class="line"></span><br><span class="line">     可以看到，Debug 将imp shorts中的s表示为inc ax指令的偏移地址8，并将jmp shorts表示为jmp 0008，表示转移到cs:0008处。</span><br><span class="line"></span><br><span class="line">     再观察机器码，发现jmp 0008 (Debug 中的表示)或jmp short s(汇编语言中的表示)所对应的机器码为EB 03，注意，这个机器码中竟然不包含转移的目的地址。</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">* 由上面引出问题，没有机器码指出要转移的地址，cpu是怎么知道要转移到哪里的呢?</span><br><span class="line"></span><br><span class="line">  **小实验**</span><br><span class="line"></span><br><span class="line">  我们在jmp要跳转的指令前添加代码，再来进行观察</span><br><span class="line"></span><br><span class="line">  ![image-20240724130200929](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130200929.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724130240124](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130240124.png)</span><br><span class="line"></span><br><span class="line">  我们发现当与要跳转的指令差了6个机器码时，03变成了06</span><br><span class="line"></span><br><span class="line">  ![image-20240724130346609](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130346609.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724130333732](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130333732.png)</span><br><span class="line"></span><br><span class="line">  我们发现当与要跳转的指令差了5个机器码时，03变成了05</span><br><span class="line"></span><br><span class="line">  **总结：**机器指令中并不包含转移的目的地址，因为cpu不需要这个目的地址就可以实现对ip的修改</span><br><span class="line"></span><br><span class="line">* jmp short s 指令的读取和执行过程</span><br><span class="line"></span><br><span class="line">  ![image-20240724125315581](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724125315581.png)</span><br><span class="line"></span><br><span class="line">  (1)(CS)=076AH，(IP)=0003，CS:IP指向EB 03(jmp short s的机器码)</span><br><span class="line">  (2)读取指令码EB 03进入指会缓冲器</span><br><span class="line">  (3)(IP)=(IP)+所读取指令的长度=(IP)+2=0005，CS:IP指向add ax,1</span><br><span class="line">  (4)CPU指行指会缓冲器中的指合EB03</span><br><span class="line">  (5)指会EB 03执行后，(IP)=000AH，CS:IP指向inc ax</span><br><span class="line"></span><br><span class="line">* 我们现在就可以理解为什么有偏移范围-128~127，因为，指令 `jmp short 标号`的功能实际为`(ip)=(ip)+8位位移`</span><br><span class="line">  * (1)8位位移=“标号”处的地址-jmp指令后的第一个字节的地址</span><br><span class="line">  * (2)short指明此处的位移为8位位移</span><br><span class="line">  * (3)8位位移的范围为-128~127，用补码表示</span><br><span class="line">  * (4)8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">* 与 `jmp short 标号`功能相近的指令格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
jmp near ptr 标号
实现的是段内近转移
功能：(ip)=(ip)+16位位移
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  说明：</span><br><span class="line"></span><br><span class="line">  * (1)16位位移=“标号”处的地址-jmp指令后的第一个字节的地址</span><br><span class="line">  * (2)near ptr指明此处的位移为16位位移，进行的是段内近转移</span><br><span class="line">  * (3)8位位移的范围为-32769~32767，用补码表示</span><br><span class="line">  * (4)16位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">### 9.4 转移的目的地址在指令中的jmp指令</span><br><span class="line"></span><br><span class="line">* 前面讲的jmp指令，其对应的机器码中并没有转移目的地址，而是相对于当前IP的转移位移</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jmp far ptr 标号 </span><br></pre></td></tr></table></figure>

实现的是段间转移，又称为远转移

功能：

* (CS)=标号所在段的段地址
* (IP)=标号所在段中的偏移地址
* far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。
</code></pre>
</li>
<li><p><strong>示例</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724162800552.png" alt="image-20240724162800552"></p>
<p>我们再查看机器码</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163053315.png" alt="image-20240724163053315"></p>
<p>我们发现它使用的还是段内跳转，但是多了三个空字节</p>
<p>我们再添加一点数据</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163236891.png" alt="image-20240724163236891"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163019916.png" alt="image-20240724163019916"></p>
<p>发现jmp指令在机器码还是debug中都给出了详细的段地址加偏移地址</p>
</li>
</ul>
<h3 id="9-5-转移的地址在寄存器中的jmp指令"><a href="#9-5-转移的地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移的地址在寄存器中的jmp指令"></a>9.5 转移的地址在寄存器中的jmp指令</h3><ul>
<li><pre><code>jmp 16位寄存器
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：ip=（16位寄存器）</span><br><span class="line"></span><br><span class="line">  **回顾2.11**</span><br><span class="line"></span><br><span class="line">  转移指令</span><br><span class="line"></span><br><span class="line">  1. 同时修改cs，ip的内容：</span><br><span class="line"></span><br><span class="line">     jmp 段地址：偏移地址</span><br><span class="line"></span><br><span class="line">     功能：用指令中给出的段地址修改cs，偏移地址修改ip</span><br><span class="line"></span><br><span class="line">     **注意：**这个指令只能在debug中使用，编译器并不认识</span><br><span class="line"></span><br><span class="line">  2. 仅修改ip的内容</span><br><span class="line"></span><br><span class="line">     jmp 某一合法寄存器</span><br><span class="line"></span><br><span class="line">  ![image-20240716140046220](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716140046220.png)</span><br><span class="line"></span><br><span class="line">###  9.6 转移地址在内存中的jmp指令</span><br><span class="line"></span><br><span class="line">* 转移地址在内存中的jmp指令有两种格式</span><br><span class="line"></span><br><span class="line">  1. ```</span><br><span class="line">     jmp word ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure>

   功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址

   内存单元地址可用寻址方式的任一格式给出 

   如：

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line">执行后：（ip）=0123H</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br><span class="line">执行后：（ip）=0123H</span><br></pre></td></tr></table></figure>

2. ```
   jmp dword ptr 内存单元地址（段间转移）
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">功能:从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</span><br><span class="line">(CS)=(内存单元地址+2)</span><br><span class="line">(IP)=(内存单元地址)</span><br><span class="line">内存单元地址可用寻址方式的任一格式给出。</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   mov ax,0123H
   mov ds:[0],ax
   mov word ptr ds:[2],0
   jmp dword ptr ds:[0]
   执行后：(cs)=0  (ip)=0123H
   
   mov ax,0123H
   mov [dx],ax
   mov word ptr [dx+2],0
   jmp dword ptr [bx]
   执行后：(cs)=0  (ip)=0123H
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">### 9.7 jcxz指令</span><br><span class="line"></span><br><span class="line">* jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jcxz 标号 //如果(cx)=0，则转移到标号处执行</span><br></pre></td></tr></table></figure>

操作：

* 当(cx)=0时，(ip)=(ip)+8位位移
  * 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址
  * 8位位移的取值范围为-128~127，用补码表示
  * 8位位移由编译程序在编译时算出
* 当(cx)!=0时，程序不进行跳转，继续向下执行
</code></pre>
</li>
<li><p>指令jcxz的功能相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">	jmp short 标号;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h3><ul>
<li><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址</p>
</li>
<li><p>对ip的修改范围 -128~127</p>
</li>
<li><pre><code>loop 标号  //((cx))=(cx)-1,如果(cx)！=0，转移到标号处执行
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  操作：</span><br><span class="line"></span><br><span class="line">  * (cx)=(cx)-1</span><br><span class="line">  * 当(cx)!=0时,(ip)=(ip)+8位位移</span><br><span class="line">    * 8位位移=“标号”处的地址-loop指令后的第一个字节的地址</span><br><span class="line">    * 8位位移的取值范围为-128~127，用补码表示</span><br><span class="line">    * 8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">  * 当cx=0，程序不进行跳转，继续向下执行</span><br><span class="line"></span><br><span class="line">* 指令loop的功能相当于</span><br><span class="line"></span><br></pre></td></tr></table></figure>
(cx)--
if((cx)!=0)
    jmp short 标号
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* loop循环步骤</span><br><span class="line"></span><br><span class="line">  先执行循环中的程序—&gt;再将cx中的值减一—&gt;再判断cx是否为0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
dec指令的功能和inc相反，dec bx进行的操作位：(bx)=(bx)-1
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 9.9 根据位移进行转移的意义</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jmp short 标号</span><br><span class="line">  jmp near ptr 标号</span><br><span class="line">  jcxz 标号</span><br><span class="line">  loop 标号</span><br></pre></td></tr></table></figure>

<p>  等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离</p>
<ul>
<li><p>这样设计，方便了程序段在内存中的浮动装配</p>
<p>例如：<img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240724193454116.png" alt="image-20240724193454116"></p>
<ul>
<li><p>这段程序装在内存中的不同位置都可正确执行，因为 loops在执行时只涉及到s的位移(-4，前移 4个字节，补码表示为FCH)，而不是s的地址。</p>
</li>
<li><p>如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制</p>
</li>
<li><p>因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。</p>
</li>
<li><p>而loop s的机器码中包含的是转移的位移，就不存在这个问题了</p>
</li>
<li><p>因为，无论 s处的指令的实际地址是多少，1oop指令的转移位移是不变的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h3><ul>
<li><p>注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错</p>
</li>
<li><p><strong>小实验</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724194655086.png" alt="image-20240724194655086"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724194711136.png" alt="image-20240724194711136"></p>
<p>我们发现错误 jump out of range by 129 byte 跳出范围129字节表示超出了129个字节</p>
</li>
<li><p><strong>注意</strong><code>jmp 2000:0100</code>的转移指令，是在Debug 中使用的汇编指令，汇编编译器并不认识。<br>如果在源程序中使用，编译时也会报错。</p>
</li>
</ul>
<h2 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h2><ul>
<li><p>程序的加载与返回过程</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725122356406.png" alt="image-20240725122356406"></p>
<p>这就是一个加载debug程序，再返回的过程</p>
</li>
<li><p>call和ret指令都是转移指令，他们都修改ip，或同时修改cs和ip</p>
</li>
<li><p>他们经常被共同用来实现自程序的设计</p>
</li>
</ul>
<h3 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h3><ul>
<li><p><code>ret</code>指令用栈中的数据，修改ip的内容，从而实现近转移</p>
</li>
<li><p>cpu执行ret指令时，进行下面两步操作：</p>
<ul>
<li>(ip)&#x3D;((ss)*16+(sp))</li>
<li>(sp)&#x3D;(sp)+2</li>
</ul>
</li>
<li><p><code>retf</code>指令用栈中的数据，修改cs和ip的内容，从而实现远转移</p>
</li>
<li><p>cpu执行retf指令时，进行下面四步操作</p>
<ul>
<li><p>(ip)&#x3D;((ss)*16+(sp))</p>
</li>
<li><p>(sp)&#x3D;(sp)+2</p>
</li>
<li><p>(cs)&#x3D;((ss)*16+(sp))</p>
</li>
<li><p>(sp)&#x3D;(sp)+2</p>
</li>
</ul>
</li>
<li><p>我们可以用汇编语法来解释ret和retf指令</p>
<ul>
<li><p>cpu执行ret指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP   //注意，无论是push ip还是pop ip都是不合法的，这里只是方便解释</span><br></pre></td></tr></table></figure>
</li>
<li><p>cpu执行retf指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实验</strong></p>
<p><strong>ret指令</strong></p>
<ol>
<li><p>编写程序</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130205572.png" alt="image-20240725130205572"></p>
</li>
<li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li>
<li><p>观察调试过程</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130153322.png" alt="image-20240725130153322"></p>
</li>
<li><p>实验总结：这时我们可以知道ret指令相比于pop将数据输出给寄存器，会直接将数据赋值给ip</p>
</li>
</ol>
<p><strong>retf指令</strong></p>
<ol>
<li><p>编写程序</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130920970.png" alt="image-20240725130920970"></p>
</li>
<li><p>……</p>
</li>
<li><p>查看调试过程</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130957124.png" alt="image-20240725130957124"></p>
</li>
<li><p>我们发现程序可以正常退出，但并不能体现处retf的特色</p>
</li>
<li><p>我们重新编写一个程序：在这个程序中我们将正常退出的指令单独放在一个段中</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725131851528.png" alt="image-20240725131851528"></p>
</li>
<li><p>……</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725131837086.png" alt="image-20240725131837086"></p>
</li>
</ol>
</li>
</ul>
<h3 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h3><ul>
<li><p>call指令经常跟ret指令配合使用，因此cpu执行call执行，进行两步操作：</p>
<ul>
<li>将当前的ip或cs和ip压入栈中</li>
<li>转移（jmp）</li>
</ul>
</li>
<li><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p>
</li>
</ul>
<h3 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h3><ul>
<li><pre><code>call 标号 //将当前的ip压栈后，转到标号处执行指令
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  cpu执行此种格式的call之指令时，进行如下操作</span><br><span class="line"></span><br><span class="line">  * (sp)=(sp)-2</span><br><span class="line"></span><br><span class="line">    ((ss)*16+(sp))=(ip)</span><br><span class="line"></span><br><span class="line">  * (ip)=(ip)+16位的位移</span><br><span class="line"></span><br><span class="line">* call 标号</span><br><span class="line">  * 16位位移=“标号”处的地址-call指令**后**的第一个字节的地址</span><br><span class="line">  * 16位位移的取值范围为-32768~32767，用补码表示</span><br><span class="line">  * 16位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">**实验**</span><br><span class="line"></span><br><span class="line">1. 编写程序</span><br><span class="line"></span><br><span class="line">   ![image-20240725152136158](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152136158.png)</span><br><span class="line"></span><br><span class="line">2. ……</span><br><span class="line"></span><br><span class="line">3. 查看调试过程</span><br><span class="line"></span><br><span class="line">   ![image-20240725152254856](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152254856.png)</span><br><span class="line"></span><br><span class="line">4. 我们发现程序正常退出并没有进入无限循环</span><br><span class="line"></span><br><span class="line">5. 那如果没有退出代码呢</span><br><span class="line"></span><br><span class="line">   ![image-20240725152504458](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725152504458.png)</span><br><span class="line"></span><br><span class="line">   6. 这时我们再调试</span><br><span class="line"></span><br><span class="line">      ![image-20240725152605941](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152605941.png)</span><br><span class="line"></span><br><span class="line">      我们发现再ret之后就ip大跳到了其他地址</span><br><span class="line"></span><br><span class="line">      ![image-20240725154525656](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725154525656.png)</span><br><span class="line"></span><br><span class="line">      再观察执行最后一个ret前的段地址 看见6AB8</span><br><span class="line"></span><br><span class="line">**小总结**</span><br><span class="line"></span><br><span class="line">上述实验我们并没有发现代码进入死循环，说明执行call指令时压入栈的ip，指向的时call指令的下一条指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* cpu执行这种格式的call指令时，相当于进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
push IP     //这个IP是指向call的下一条指令
jmp near ptr 标号
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.4 转移的目的地址在指令中的call指令</span><br><span class="line"></span><br><span class="line">* 前面讲解的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  call far ptr 标号 //实现段间转移</span><br></pre></td></tr></table></figure>

操作：

* (sp)=(sp)-2

  ((ss)*16+(sp))=(cs)

  (sp)=(sp)-2

  ((ss)*16+(sp))=(ip)

* (cs)=标号所在的段地址

  (ip)=标号所在的偏移地址
</code></pre>
</li>
<li><p>cpu执行这种格式的call指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP    </span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h3><ul>
<li><pre><code>call 16位寄存器
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：</span><br><span class="line"></span><br><span class="line">  * (sp)=(sp)-2</span><br><span class="line">  * ((ss)*16+(sp))=(ip)</span><br><span class="line">  * ip=（16位寄存器）</span><br><span class="line"></span><br><span class="line">* cpu执行这种格式的call指令时，相当于进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
push IP    
jmp 16位寄存器
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.6 转移地址在内存中的call指令</span><br><span class="line"></span><br><span class="line">* 转移地址在内存中的call指令有两种格式：</span><br><span class="line"></span><br><span class="line">  * call word ptr 内存单元地址</span><br><span class="line">  * call dword ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* call word ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  相当于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
push IP
jmp word ptr 内存单元地址
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mov sp,10H
mov ax,0123H
mov ds:[0],ax
call word ptr ds:[0]
执行后：(ip)=0123H,(sp)=0EH

mov sp,10H
mov ax,0123H
mov [bx],ax
call word ptr [bx]
执行后：(ip)=0123H,(sp)=0EH
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* call dword ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  相当于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
push CS
push IP
jmp dword ptr 内存单元地址
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
mov sp,10H
mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
执行后：(cs)=0  (ip)=0123H (sp)=0CH

mov sp,10H
mov ax,0123H
mov [dx],ax
mov word ptr [dx+2],0
call dword ptr [bx]
执行后：(cs)=0  (ip)=0123H (sp)=0CH
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.7 call和ret的配合使用</span><br><span class="line"></span><br><span class="line">* 我们已经分别学习了 ret 和call指令的原理。现在我们看一下，如何将它们配合使用来实现子程序的机制。</span><br><span class="line"></span><br><span class="line">* 分析代码1</span><br><span class="line"></span><br><span class="line">  ![image-20240725172451443](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725172451443.png)</span><br><span class="line"></span><br><span class="line">  这个代码应该是先给ax赋值1，再给cx赋值3，执行call指令将 `mov bx ax`的偏移地址存入栈，再跳转到标号 `s`处，执行三次 `add ax,ax`，结束后ax的值是8，循环结束后执行ret，将栈中 `mov bx ax`的偏移地址取出并设置为新的ip，之后执行 `mov bx,ax`后退出程序</span><br><span class="line"></span><br><span class="line">  1. 前三条指令执行后，栈内是空的</span><br><span class="line"></span><br><span class="line">     ![image-20240725185805773](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725185805773.png)</span><br><span class="line"></span><br><span class="line">  2. 但当call指令读入后，(ip)=000EH（此时的ip指向的是call指令之后的指令）,cpu指令指令缓冲器中的代码为`D8 05 00`</span><br><span class="line"></span><br><span class="line">     cpu执行`D8 05 00`，栈中的情况变为</span><br><span class="line"></span><br><span class="line">     ![image-20240725190125122](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725190125122.png)</span><br><span class="line"></span><br><span class="line">     然后 (ip)=(ip)+0005=0013H</span><br><span class="line"></span><br><span class="line">  3. cpu从`cs:0013H`处（标号s处）开始执行</span><br><span class="line"></span><br><span class="line">  4. ret指令读入后：(ip)=0016H，cpu指令缓冲器中的代码为C3</span><br><span class="line"></span><br><span class="line">     当cpu执行c3，相当于进行`pop ip`，执行后，栈中的情况为：</span><br><span class="line"></span><br><span class="line">     ![image-20240725190706877](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725190706877.png)</span><br><span class="line"></span><br><span class="line">  5. cpu回到`cs:000EH`处（ip指向的是call指令之后的指令），继续执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* call指会后面的指令的地址将存储在栈中，所以可以在子程序的后面使用 ret指令，用栈中的数据设置IP的值，从而转到 call 指令后面的代码处继续执行。</span><br><span class="line"></span><br><span class="line">* 这样我们可以利用call和ret来实现子程序的机制</span><br><span class="line"></span><br><span class="line">![image-20240725191607473](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725191607473.png)</span><br><span class="line"></span><br><span class="line">### 10.8 mul指令</span><br><span class="line"></span><br><span class="line">* mul是乘法指令</span><br><span class="line">* 使用mul做乘法的时候</span><br><span class="line">  * 相乘的两个数：要么都是8位，要么都是16位</span><br><span class="line">    * 8位：al中和8位寄存器或内存字节单元中</span><br><span class="line">    * 16位：ax中和16位寄存器或内存单元中</span><br><span class="line">  * 结果</span><br><span class="line">    * 8位：ax中</span><br><span class="line">    * 16位：DX（高位）和AX（低位）中</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mul reg</span><br><span class="line">  mul 内存单元</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>内存单元可以用不同的寻址方式给出（8.4）</p>
<ul>
<li><pre><code>mul byte ptr ds:[0]

含义为:(ax)=(al)*((ds)*16+0)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mul word ptr [bx+si+8]</span><br><span class="line">  </span><br><span class="line">  含义为:</span><br><span class="line">  (ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位;</span><br><span class="line">  (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<ol>
<li><p>问题1：我们直接mul idata</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725195357149.png" alt="image-20240725195357149"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725195419844.png" alt="image-20240725195419844"></p>
<p>报错</p>
</li>
<li><p>问题2：研究8位还是16位是不是al，ax决定的</p>
<ol>
<li><p>编写代码</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726101644608.png" alt="image-20240726101644608"></p>
</li>
<li><p>逐个分析</p>
</li>
<li><p>情况1</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726101758363.png" alt="image-20240726101758363"></p>
<p>我们发现在al*bl的过程中，算出的是16位的数据</p>
</li>
<li><p>情况2</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102031753.png" alt="image-20240726102031753"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102138250.png" alt="image-20240726102138250"></p>
<p>我们发现在al*bx的情况下，成功计算出32位的答案</p>
</li>
<li><p>情况3</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102338726.png" alt="image-20240726102338726"></p>
<p>我们在ax*bl的情况下不能判断计算出的数据位</p>
</li>
<li><p>情况4</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726102559292.png" alt="image-20240726102559292"></p>
<p>我们在ax*bx中算出了32位数据</p>
</li>
<li><p>在上述实验中我们知道如果<code>mul 16位数据</code>算出的结果是32位的，但是不能决定<code>mul 8位数据</code>是否算出的是16位数据</p>
</li>
<li><p>编写代码</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726103439842.png" alt="image-20240726103439842"></p>
</li>
<li><p>情况1</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726103530866.png" alt="image-20240726103530866"></p>
<p>我们发现还是8位的数据相乘，说明主要是看mul后面的位</p>
</li>
<li><p>情况2</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726103735649.png" alt="image-20240726103735649"></p>
<p>由这个可以确定就是看mul后面数据的位数</p>
</li>
</ol>
</li>
</ol>
<p><strong>实验总结</strong></p>
<p>由上述实验我们可以确定 mul判断是多少位的数据相乘是看mul后的数据是多少位，如果mul后的数据是8位，就读取al，反之如果mul后的数据是16位，就读取ax</p>
<h3 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h3><ul>
<li><p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少</p>
</li>
<li><p>因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法</p>
</li>
<li><p>而call和ret指会对这种分析方法提供了程序实现上的支持。利用 call和ret指令，我们可以用简洁的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题。</p>
</li>
</ul>
<h3 id="10-10-参数和结果的传递问题"><a href="#10-10-参数和结果的传递问题" class="headerlink" title="10.10 参数和结果的传递问题"></a>10.10 参数和结果的传递问题</h3><ul>
<li><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者</p>
</li>
<li><p>其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。</p>
</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li><p>设计一个子程序，可以根据提供的N，来计算N的3次方:<br>这里面就有两个问题:<br>(1)将参数N存储在什么地方?<br>(2) 计算得到的数值，存储在什么地方?</p>
</li>
<li><p>很显然，可以用寄存器来存储，可以将参数放到bx中;因为子程序中要计算N*N *N，可以使用多个 mul指令，为了方便，可将结果放到 dx和 ax中。</p>
</li>
<li><p>我们可以编一个子程序</p>
<ul>
<li><p>说明：计算N的3次方</p>
</li>
<li><p>参数：(bx)&#x3D;N</p>
</li>
<li><p>结果：(dx:ax)&#x3D;N^3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube mov ax,bx</span><br><span class="line">	 mul bx</span><br><span class="line">	 mul bx</span><br><span class="line">	 ret</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>要做好注释</p>
</li>
<li><p>用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反</p>
<ul>
<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值;</li>
<li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</li>
</ul>
</li>
</ul>
<h3 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h3><ul>
<li><p>一个子程序中，如果有一个，两个参数可以用寄存器存放，但是如果要传递参数有很多怎么办</p>
</li>
<li><p>寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。</p>
</li>
<li><p>在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。</p>
</li>
<li><p>对于具有批量数据的返回结里，也可用同样的方法。</p>
</li>
<li><p>注意：除了寄存器，内存传递参数外，还有一种通用的方法使用栈来传递参数</p>
</li>
</ul>
<h3 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h3><ul>
<li>设计一个子程序，功能:将一个全是字母，以0结尾的字符串，转化为大写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment </span><br><span class="line">db &#x27;asdfghhjk&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov si,0</span><br><span class="line">		call bdx</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line">	bdx:mov cl,[si]</span><br><span class="line">		mov ch,0</span><br><span class="line">		jcxz s</span><br><span class="line">		and byte ptr [si],11011111b</span><br><span class="line">		inc si</span><br><span class="line">		jmp bdx</span><br><span class="line">	s:  ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ol>
<li><p>debug调试，查看原数据段</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726115423284.png" alt="image-20240726115423284"></p>
</li>
<li><p>查看运行后的数据段内存</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726115728275.png" alt="image-20240726115728275"></p>
</li>
</ol>
<ul>
<li>如果是多个字符串呢</li>
</ul>
<ol>
<li><pre><code>assume cs:code
data segment 
db &#39;asdfghhjk&#39;,0
db &#39;asdfghhjk&#39;,0
db &#39;asdfghhjk&#39;,0
db &#39;asdfghhjk&#39;,0
data ends
code segment
start:        
        mov ax,data
        mov ds,ax
        mov si,0
        mov bx,0
        mov cx,4
        call bdx
        
        mov ax,4c00h
        int 21h

    bdx:push cx
    s0: mov cl,[si]
        mov ch,0
        jcxz s
        and byte ptr [si],11011111b
        inc si
        jmp short s0
    s:    pop cx
        inc si
        loop bdx
        ret
      


code ends
end start
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 编译连接，debug调试，查看原始数据段![image-20240726121144937](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726121144937.png)</span><br><span class="line"></span><br><span class="line">3. 查看运行结束后的数据段![image-20240726121842386](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726121842386.png)</span><br><span class="line"></span><br><span class="line">### **实验十**</span><br><span class="line"></span><br><span class="line">**实验一：显示字符串**</span><br><span class="line"></span><br><span class="line">![image-20240726142905838](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726142905838.png)</span><br><span class="line"></span><br><span class="line">![image-20240726142931140](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726142931140.png)</span><br><span class="line"></span><br><span class="line">1. 代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>assume cs:code<br>data segment<br>db ‘Welcome to masm!’,0<br>data ends<br>code segment<br>start:	 mov dh,3<br>		 mov dl,1<br>	  	 mov cl,2<br>		 mov ax,data<br>	  	 mov ds,ax<br>		 mov si,0<br>		 call show_str<br>		<br>		 mov ax,4c00h<br>		 int 21h<br>		<br>show_str:mov ax,cx<br>		 mov cl,[si]<br>		 mov ch,0<br>		 jcxz s<br>		 mov cx,ax<br>		 push dx<br>		 mov bx,dx<br>		 mov ax,0B800h<br>		 mov es,ax<br>		 mov dl,dh<br>		 mov dh,0<br>		 mov ax,0A0h<br>		 mul dx<br>	     mov bh,0<br>		 add ax,bx<br>		 add ax,bx<br>		 mov bx,ax<br>		 mov al,[si]<br>		 mov ah,cl<br>		 mov di,si<br>		 add di,di<br>		 mov es:[bx+di],ax<br>		 inc si<br>		 pop dx<br>		 jmp show_str<br>	s:   ret<br>		<br>code ends<br>end start</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ![image-20240726164025985](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726164025985.png)</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   mov dh,15</span><br><span class="line">   mov dl,6</span><br><span class="line">   mov cl,2</span><br></pre></td></tr></table></figure>

<p>   <img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726162817240.png" alt="image-20240726162817240"></p>
<p><strong>实验二：解决除法溢出的问题</strong></p>
<ol>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">da segment </span><br><span class="line">db 16 dup(0)</span><br><span class="line">da ends</span><br><span class="line">code segment</span><br><span class="line">start:	 mov ax,4240h;低位</span><br><span class="line">		 mov dx,000fh;高位</span><br><span class="line">	  	 mov cx,0ah</span><br><span class="line">		 call divdw</span><br><span class="line">		</span><br><span class="line">		 mov ax,4c00h</span><br><span class="line">		 int 21h</span><br><span class="line">		</span><br><span class="line">divdw:   push ax</span><br><span class="line">		 mov ax,da</span><br><span class="line">		 mov ds,ax</span><br><span class="line">		 pop ax</span><br><span class="line">		 mov bx,ax</span><br><span class="line">		 mov ax,dx</span><br><span class="line">		 mov dx,0;此时bx是低位，ax是高位，dx=0</span><br><span class="line">		 div cx  </span><br><span class="line">		 ;此时ax是int，dx是rem，bx是低位</span><br><span class="line">		 </span><br><span class="line">		 push ax</span><br><span class="line">		 push bx</span><br><span class="line">		 push dx</span><br><span class="line">		 mov ax,dx</span><br><span class="line">		 mov bx,0ffffh</span><br><span class="line">		 mul bx  ;这时是进行rem的乘法，		 </span><br><span class="line">		 pop dx</span><br><span class="line">		 add ax,dx</span><br><span class="line">		 pop bx</span><br><span class="line">		 add ax,bx;进行加L操作</span><br><span class="line">		 div cx</span><br><span class="line">		 mov cx,ax	 ;cx这时是加号右边的结果</span><br><span class="line">		 pop ax</span><br><span class="line">		 mov dx,ax</span><br><span class="line">		 push dx</span><br><span class="line">		 mov bx,0ffffh</span><br><span class="line">		 mul bx	</span><br><span class="line">		 mov ds:[0],ax</span><br><span class="line">		 mov ds:[2],dx</span><br><span class="line">		 pop dx</span><br><span class="line">		 adc ds:[0],dx</span><br><span class="line">		 mov ax,0</span><br><span class="line">		 adc ds:[2],ax</span><br><span class="line">		 adc ds:[0],cx</span><br><span class="line">		 mov ax,ds:[0]</span><br><span class="line">		 mov dx,ds:[2]</span><br><span class="line">		 ret</span><br><span class="line">		 </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726195657645.png" alt="image-20240726195657645"></p>
</li>
<li><pre><code>adc指令

ADC 指令在汇编语言中用于执行加法操作时处理进位（carry）。ADC 指令的全称是“Add with Carry”（带进位加法）。它不仅将两个操作数相加，还将前一个加法操作中的进位标志（carry flag）也加到结果中。

ADC destination, source

destination: 目标操作数，通常是一个寄存器或内存位置。
source: 源操作数，通常是一个立即数、寄存器或内存位置。

加法操作: ADC 指令首先执行加法操作，即将 destination 和 source 相加。
进位处理: 它还加上进位标志（Carry Flag，CF）的值。进位标志是前一个加法操作的结果。如果前一个加法操作产生了进位，ADC 会将这个进位加到当前的加法操作中。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">**实验三：数值显示**</span><br><span class="line"></span><br><span class="line">1. 代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
assume cs:code
data segment
db 10 dup(0)
data ends

code segment
start:  mov ax,12666
        mov bx,data
        mov ds,bx
        mov si,0
        call dtoc
        mov dh,8
        mov dl,3
        mov cl,2
        call show_str
        
        mov ax,4c00h
        int 21h
        
dtoc:    mov cx,10 
        mov dx,0
        div cx
        mov bl,dl
        mov bh,0
        mov cx,bx
        jcxz cz
        add bl,30H
        push bx
        inc di
        jmp dtoc
cz:     mov ax,data
        mov ds,ax
        mov cx,di
    s0: pop ds:[si]
        inc si
        loop s0
        mov si,0
        ret

        
show_str:mov ax,cx
         mov cl,[si]
         mov ch,0
         jcxz s
         mov cx,ax
         push dx
         mov bx,dx
         mov ax,0B800h
         mov es,ax
         mov dl,dh
         mov dh,0
         mov ax,0A0h
         mul dx
         mov bh,0
         add ax,bx
         add ax,bx
         mov bx,ax
         mov al,[si]
         mov ah,cl
         mov di,si
         add di,di
         mov es:[bx+di],ax
         inc si
         pop dx
         jmp show_str
    s:   ret

code ends
end start 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 结果</span><br><span class="line"></span><br><span class="line">   ![image-20240726213123243](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726213123243.png)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 11 标志寄存器</span><br><span class="line"></span><br><span class="line">* 8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)</span><br><span class="line"></span><br><span class="line">* 我们已经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、ip、cs、ss、ds、es等13个寄存器了。</span><br><span class="line"></span><br><span class="line">* flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。</span><br><span class="line"></span><br><span class="line">* 而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</span><br><span class="line"></span><br><span class="line">* 8086cpu的flag寄存器的结构</span><br><span class="line"></span><br><span class="line">  ![image-20240726225843589](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726225843589.png)</span><br><span class="line"></span><br><span class="line">* flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.1 ZF标志</span><br><span class="line"></span><br><span class="line">* flag的第6位是ZF，零标志位。</span><br><span class="line">  它记录相关指令执行后，</span><br><span class="line"></span><br><span class="line">  * 结果为0，ZF=1</span><br><span class="line">  * 结果不为0，ZF=0</span><br><span class="line"></span><br><span class="line">  **例如：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>  mov ax,1<br>  sub ax,1<br>  指令执行后，结果为0，则ZF&#x3D;1</p>
<p>  mov ax,2<br>  sub ax,1<br>  指令执行后，结果为1，则ZF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。</span><br><span class="line"></span><br><span class="line">  指令：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov ax,1<br>  and ax,0<br>  执行后，结果为0，则ZF&#x3D;1，表示“结果是0”</p>
<p>  mov ax,1<br>  or ax,0<br>  执行后，结果不为0，则ZF&#x3D;0，表示“结果非0”<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* **注意：**</span><br><span class="line"></span><br><span class="line">  在8086CPU的指令集中，有的指会的执行是影响标志寄存器的，比如:`add、sub、mul、div、inc、or、and`等，它们大都是运算指令(进行逻辑或算术运算)</span><br><span class="line"></span><br><span class="line">  有的指会的执行对标志寄存器没有影响，比如:`mov、push、pop`等，它们大都是传送指令</span><br><span class="line"></span><br><span class="line">* 我们在使用一条指会的时候，要注意这条指会的全部功能，其中包括，执行结果对标记寄存器的哪些标志位造成影响。</span><br><span class="line"></span><br><span class="line">### 11.2 PF标志</span><br><span class="line"></span><br><span class="line">* flag的第2位是PF，奇偶标志位。</span><br><span class="line">  它记录指令执行后，结果的所有二进制位中1的个数:</span><br><span class="line"></span><br><span class="line">  * 为偶数，PF=1</span><br><span class="line">  * 为奇数，PF=0</span><br><span class="line"></span><br><span class="line">  **例如**：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,1<br>  add al,10<br>  执行后，结果为00001011B，其中有3(奇数)个1，则PF&#x3D;0</p>
<p>  mov al,1<br>  or al,10<br>  执行后，结果为00000011B，其中有2(偶数)个1，则PF&#x3D;1<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.3 SF标志</span><br><span class="line"></span><br><span class="line">* flag的第7位是SF，符号标志位</span><br><span class="line"></span><br><span class="line">  他记录指令执行后</span><br><span class="line"></span><br><span class="line">  * 结果为负，SF=1</span><br><span class="line">  * 结果为正，SF=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>有符号数与补码</p>
<ul>
<li><p>计算机中通常用补码来麦示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数</p>
<p>如：</p>
<p>  00000001B，以者作为无符号数1，或有，符号数+1<br>  10000001B，可以看作为无符号数129，也可以看作有符号数-127。</p>
</li>
<li><p>这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  mov al,10000001B<br>  add al,1<br>  结果:(al)&#x3D;10000010B<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 我们可以将add指令进行的运当作无符号数的运那么add指令相当于计算129+1，结果为130</span><br><span class="line">    (10000010B)</span><br><span class="line">  * 也可以将add指会进行的运算当作有符号数的运算，那么add指令相当于计算-127+1，结果为-126</span><br><span class="line">    (10000010B)</span><br><span class="line"></span><br><span class="line">* 不管我们如何看待，CPU 在执行add等指会的时候就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。</span><br><span class="line"></span><br><span class="line">* **关键在于我们需要哪一种结果**</span><br><span class="line"></span><br><span class="line">* SF 标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。</span><br><span class="line">  在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负</span><br><span class="line"></span><br><span class="line">* 如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</span><br><span class="line"></span><br><span class="line">* CPU在执行 add 等指令时，是必然要影响到SF标志位的值的。</span><br><span class="line"></span><br><span class="line">* 我们再来看那个例子</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,10000001B<br>  add al,1<br>  结果:(al)&#x3D;10000010B，SF&#x3D;1<br>  表示：如果指会进行的是有符号数运算，那么结果为负，如果是无符号数运算不用管他</p>
<p>  moy al,10000001B<br>  add al,01111111B<br>  执行后，结果为0，SF&#x3D;0<br>  表示:如果指令进行的是有符号数运，那么结果为非负。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 某次指会将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据 </span><br><span class="line">* 如执行 `sub al,al`执行后，ZF，PF，SF等标志位都要受到影响，ZF=1，PF=1，SF=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.4 CF标志</span><br><span class="line"></span><br><span class="line">* flag的第0位是CF，进位标志位</span><br><span class="line"></span><br><span class="line">* 一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</span><br><span class="line"></span><br><span class="line">* 对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。</span><br><span class="line"></span><br><span class="line">* ![image-20240727140615518](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727140615518.png)</span><br><span class="line"></span><br><span class="line">  当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。</span><br><span class="line">  比如，两个8 位数据:98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了</span><br><span class="line"></span><br><span class="line">* 其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上:</span><br><span class="line">* 8086CPU 就用flag的CF位来记录这个进位值。</span><br><span class="line"></span><br><span class="line">* debug看到的信息</span><br><span class="line"></span><br><span class="line">  ![image-20240727141042541](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141042541.png)</span><br><span class="line"></span><br><span class="line">* **比如：**</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,98H<br>  add al,al  ;执行后:(al)&#x3D;30H，CF&#x3D;1，<br>  		   ;CF记录了最高有效位向更高位的进位值<br>  add al,al  ;执行后:(al)&#x3D;30H，CF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **上机：**</span><br><span class="line"></span><br><span class="line">  ![image-20240727141549850](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141549850.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727141737306](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141737306.png)</span><br><span class="line"></span><br><span class="line">  我们发现在第一个add后，NC变为了CY，因为是98H+98H=130H，产生了进位，而第二次add，CY变为NC，因为30H+30H=60H没有产生进位</span><br><span class="line"></span><br><span class="line">* 另外一种情况，而当两个数据做减法的时候，有可能向更高位借位。</span><br><span class="line"></span><br><span class="line">  **比如**：</span><br><span class="line"></span><br><span class="line">  两个8位数据:97H-98H，将产生借位，借位后，相当于计算197H-98H。</span><br><span class="line">  而flag的CF位也可以用来记录这个借位值。</span><br><span class="line"></span><br><span class="line">  **上机：**</span><br><span class="line"></span><br><span class="line">  ![image-20240727142502358](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727142502358.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727142614159](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727142614159.png)</span><br><span class="line"></span><br><span class="line">  FF：相当于补码的-1，我们发现在第一次sub的时候NC变为CY，第二次则变回NC</span><br><span class="line"></span><br><span class="line">### 11.5 OF标志</span><br><span class="line"></span><br><span class="line">* 在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出</span><br><span class="line"></span><br><span class="line">* 那么，什么是机器所能表示的范围呢?</span><br><span class="line"></span><br><span class="line">  比如:add al,3，那么对于8位的有符号数据，机器所能表示的范围就是-128~127。</span><br><span class="line"></span><br><span class="line">* 如果运算结果超出了机器所能表达的范围，将产生溢出。</span><br><span class="line">* 注意，这里所讲的溢出，只是对有符号数运算而言。(就像进位只是相对于无符号数而言!)</span><br><span class="line"></span><br><span class="line">* **示例**</span><br><span class="line"></span><br><span class="line">  ![image-20240727143313821](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727143313821.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727143458650](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727143458650.png)</span><br><span class="line"></span><br><span class="line">  我们发现NV变为OV，说明发生了溢出，结果侵犯了符号位</span><br><span class="line"></span><br><span class="line">  ![image-20240727143753714](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727143753714.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727143840350](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727143840350.png)</span><br><span class="line"></span><br><span class="line">  当成无符号数的话，进位标志位，产生了进位，而当成有符号数来看的话，溢出标志位产生了溢出</span><br><span class="line"></span><br><span class="line">* 如果在进行有符号数运算时发生溢出，那么运算的结里将不正确。</span><br><span class="line">  就上面的两个例子来说:</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,98<br>  add al,99<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  add指会运算的结果是(a1)=0C5H，因为进行的是有符号数运算，所以 al中存储的是有符号数，而0C5H是有符号数-59的补码。</span><br><span class="line"></span><br><span class="line">  ![image-20240727144524938](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727144524938.png)</span><br><span class="line"></span><br><span class="line">  如果我们用add 指令进行的是有符号数运算，则98+99=-59这样的结果让人无法接受。</span><br><span class="line"></span><br><span class="line">  造成这种情况的原因，就是实际的结果 197，作为一个有符号数，在8位寄存器al中存放不下</span><br><span class="line"></span><br><span class="line">* 由于在进行有符号数运算时，可能发生溢出而造成结果的错误。所以CPU需要对指令执行后是否产生溢出进行记录。因此有了OF</span><br><span class="line"></span><br><span class="line">* CF和OF的区别</span><br><span class="line">  * CF是对无符号数运算有意义的标志位</span><br><span class="line">  * OF是对有符号数运算有意义的标志位</span><br><span class="line"></span><br><span class="line">* 对于无符号数运算，CPU用CF位来记录是否产生了进位</span><br><span class="line">* 对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出</span><br><span class="line"></span><br><span class="line">* SF位来记录结果的符号</span><br><span class="line"></span><br><span class="line">* 对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mov al,98b</span><br><span class="line">  add al,99b</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于无符号数运算，98+99没有进位，CF&#x3D;0</li>
<li>对于有符号数运算，98+99发生溢出，OF&#x3D;1</li>
</ul>
<h3 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h3><ul>
<li><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<ul>
<li>格式: <code>adc 操作对象1,操作对象2</code></li>
<li>功能:<br>操作对象1&#x3D;操作对象1+操作对象2+CF</li>
<li>比如:<code>adc ax,bx</code> 实现的功能是:<br>(ax)&#x3D;(ax)+(bx)+CF</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br><span class="line">执行后：(ax)=4</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算：</span><br><span class="line">(ax)+1+CF=2+1+1=4</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728212323510.png" alt="image-20240728212323510"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728215919208.png" alt="image-20240728215919208"></p>
<p>1111 1111补码相当于-1</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728212837878.png" alt="image-20240728212837878"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add ax,ax</span><br><span class="line">adc ax,3</span><br><span class="line">执行后，(ax)=5</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算:</span><br><span class="line">(ax)+3+CF=2+3+0=5。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al</span><br><span class="line">adc al,3</span><br><span class="line">执行后，(ax)=34H</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算:</span><br><span class="line">(ax)+3+CF=30H+3+1=34H</span><br></pre></td></tr></table></figure>


</li>
<li><p>在执行 adc 指令的时候加上的 CF 的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的</p>
</li>
<li><p>显然，如果CF 的值是被sub指会设置的，那么它的含义就是借位值;如果是被add指令设置的，那么它的含义就是进位值。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728213228509.png" alt="image-20240728213228509"></p>
<ul>
<li><pre><code>add ax,bx

add al,bl
adc ah,bh
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  上述两段代码有相同的作用</span><br><span class="line"></span><br><span class="line">* cpu提供adc指令的目的，就是来进行加法的第二步运算</span><br><span class="line"></span><br><span class="line">* adc和add配合可以进行更大数据的加法运算</span><br><span class="line"></span><br><span class="line">**adc 论调**</span><br><span class="line"></span><br><span class="line">* 由于有这样的功能，我们就可以对任意大的数据进行加法运算</span><br><span class="line"></span><br><span class="line">**adc指令实践**</span><br><span class="line"></span><br><span class="line">如果要进行128位的数据相加怎么办？</span><br><span class="line"></span><br><span class="line">* 参数：</span><br><span class="line">* ds:si指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元，由低地址单元到高地址单元依次存放 128位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。</span><br><span class="line"></span><br><span class="line">* ds:di指向存储第二个数的内存空间</span><br><span class="line"></span><br><span class="line">**注意**</span><br><span class="line"></span><br><span class="line">* inc和loop指令不影响CF位，上面的程序中不能用add因为会影响CF位</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>汇编语言中影响CF位的指令包括加法类指令，减法类指令，取补指令，以及比较指令</p>
<p>加法类指令：括不带进位的加法（add）和带进位的加法（adc）,这些指令在执行加法运算时会影响CF位。具体来说，当执行加法操作时，如果结果需要进位，则CF位被设置为1；否则，CF位被设置为0。</p>
<p>减法类指令：包括不带借位的减法（sub）和带借位的减法（sbb），这些指令在执行减法运算时同样会影响CF位。当执行减法操作时，如果被减数小于减数，导致需要借位，则CF位被设置为1；否则，CF位被设置为0。</p>
<p>取补指令：取补指令（neg）用于对一个数取反后加一，这个操作也会影响CF位。具体来说，当操作数为正数时，执行取补操作后CF位被设置为0；当操作数为负数时，执行取补操作后CF位的设置则取决于具体的操作数。</p>
<p>比较指令：比较指令（cmp）用于比较两个数的大小，不保存结果。这个指令通过减去第二个操作数来更新标志位，包括CF位。比较的结果可以通过检查ZF（零标志位）来确定两个数是否相等，而CF位则反映了比较过程中是否发生了借位或进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 11.7 sbb指令</span><br><span class="line"></span><br><span class="line">* sbb是带借位减法指会，它利用了CF位上记录的借位值。</span><br><span class="line"></span><br><span class="line">  * 格式: `sbb 操作对象1,操作对象2`</span><br><span class="line"></span><br><span class="line">  * 功能:</span><br><span class="line">    操作对象1=操作对象-操作对象2-CF</span><br><span class="line"></span><br><span class="line">  * 比如:`sbb ax,bx` 实现的功能是:</span><br><span class="line">    (ax)=(ax)-(bx)-CF</span><br><span class="line"></span><br><span class="line">* 利用sbb指令我们可以对任意大的数据进行减法运 。</span><br><span class="line"></span><br><span class="line">* sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。在这里，我们就不再进行过多的讨论。</span><br><span class="line"></span><br><span class="line">### 11.8 cmp指令</span><br><span class="line"></span><br><span class="line">* cmp 是比较指令，功能相当于减法指令，只是不保存结果。</span><br><span class="line"></span><br><span class="line">* cmp 指令执行后，将对标志寄存器产生影响。</span><br><span class="line"></span><br><span class="line">* 其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</span><br><span class="line"></span><br><span class="line">* **比如**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  cmp ax,ax<br>  做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>  指令执行后<br>  ZF&#x3D;1&#x2F;&#x2F;是否产生0<br>  PF&#x3D;1&#x2F;&#x2F;1有多少个，偶数为1<br>  SF&#x3D;0<br>  CF&#x3D;0<br>  OF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们通过相关标志位的值就可以看出比较的结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  cmp ax,bx<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  ![image-20240729202523805](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729202523805.png)</span><br><span class="line">  </span><br><span class="line">* 比较指令的设计思路</span><br><span class="line"></span><br><span class="line">  通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。</span><br><span class="line"></span><br><span class="line">  ![image-20240729203038918](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729203038918.png)</span><br><span class="line"></span><br><span class="line">* 同 add、sub 指令一样，CPU 在执行cmp指令的时候，也包含两种含义:</span><br><span class="line">  进行无符号数运算和进行有符号数运算</span><br><span class="line">* 所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。</span><br><span class="line"></span><br><span class="line">* 无论是进行无符号数运算和进行有符号数运算ZF为1是都表示相等</span><br><span class="line"></span><br><span class="line">* 进行**有符号运算**的时候可以通过观察`SF`标志位，若是结果为负，SF=1</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  (ah)=22H ，(bh)=0AOH</span><br><span class="line">  则(ah)-(bh)=34-(-96)=130-82H</span><br><span class="line">  82H是-126的补码，所以SF=1</span><br><span class="line">  </span><br><span class="line">  这里虽然SF=1，但是并不能说明(ah)&lt;(bh)，因为显然34&gt;-96。</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>两个有符号数A 和B 相减，得到的是负数，那么可以肯定A&lt;B，这个思路没有错误</p>
</li>
<li><p>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了</p>
</li>
<li><p>所以，我们应该在考察SF(得知实际结果的正负)的同时考察OF(得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果</p>
</li>
<li><p>如果SF&#x3D;1，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正结果的正负&#x3D;实际结果的正负;<br>因SF&#x3D;1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)&lt;(bh)。</p>
</li>
<li><p>如果SF&#x3D;1，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负<br>简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF-1，OF&#x3D;1，说明了(ah)&gt;(bh)。</p>
</li>
<li><p>如果SF&#x3D;0，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负<br>简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，SF-0，OF&#x3D;1，说明了(ah)&lt;(bh)</p>
</li>
<li><p>如果SF&#x3D;0，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正结果的正负&#x3D;实际结果的正负;<br>因SF&#x3D;0，实际结果非负，所以逻辑上真正的结果必然非负。所以(ah)&gt;&#x3D;(bh)</p>
</li>
</ul>
<h3 id="11-9检测比较结果的条件转移指令"><a href="#11-9检测比较结果的条件转移指令" class="headerlink" title="11.9检测比较结果的条件转移指令"></a>11.9检测比较结果的条件转移指令</h3><ul>
<li>因为 cmp 指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据 cmp 指令的比较结果进行转移的指令也分为两种，即:</li>
<li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值;</li>
<li>根据有符号数的比较结果进行转移的条件转移指令，它们检测 SF、OF和 ZF的值。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729210503979.png" alt="image-20240729210503979"></p>
<ul>
<li><p>这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump，后面的</p>
<ul>
<li>e:表示equal</li>
<li>ne:表示not equal</li>
<li>b:表示below</li>
<li>nb:表示not below</li>
<li>a:表示above </li>
<li>na:表示not above</li>
</ul>
</li>
<li><p>注意观察一下它们所检测的标志位，都是cmp指令进行无符号数比较时候，记录比较结果的标志位。</p>
</li>
<li><p>虽然je的逻辑含义是“相等则转移”，但它进行的操作是，ZF&#x3D;1时则转移。</p>
</li>
<li><p>“相等则转移”这种逻辑含义，是通过和 cmp 指令配合使用来体现的，因为是cmp 指令为“ZF&#x3D;1”赋予了“两数相等”的含义。</p>
</li>
<li><p>是否在<code>je</code>前使用cmp指令在于我们的安排</p>
</li>
<li><p><code>je</code>检测的是ZF位置，不管 <code>je</code> 前面是什么指令只要CPU执行<code>je</code>指令时ZF&#x3D;1，那么就会发生转移。</p>
</li>
<li><p>对于<code>jne、jb、jnb、ja、jna</code>等指令和cmp指令配合使用的思想和 <code>je</code> 相同，可以自己分析一下。</p>
</li>
<li><p>根据有符号数的比较结果进行转移的条件转移指令的工作原理和无符号的相同，只是检测了不同的标志位。</p>
</li>
<li><p>我们在这里主要探讨的是cmp，标志寄存器的相关位、条件转移指令三者配合应用的原理这个原理具有普遍性，而不是逐条讲解条件转移指令</p>
</li>
</ul>
<h3 id="11-10-DF标志和串转送指令"><a href="#11-10-DF标志和串转送指令" class="headerlink" title="11.10 DF标志和串转送指令"></a>11.10 DF标志和串转送指令</h3><ul>
<li><p>flag的第10位是DF，方向标志位。</p>
</li>
<li><p>在串处理指会中，控制每次操作后si，di的增减。</p>
</li>
<li><p>DF&#x3D;0:每次操作后si，di递增;</p>
</li>
<li><p>DF&#x3D;1:每次操作后si，di递减。</p>
</li>
<li><pre><code>movsb
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：以字节为单位传送</span><br><span class="line"></span><br><span class="line">  * ((es)x16 +(di))=((ds)x16+(si))</span><br><span class="line">  * 如果DF=0则:(si)=(si)+1     (di)=(di)+ 1</span><br><span class="line">  * 如果DF=1则:(si)=(si)-1     (di)=(di)-1s</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  * `movsb` 的功能是将 ds:si 指向的内存单元中的字节送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  movsw</span><br></pre></td></tr></table></figure>

功能：以字为单位传送

* 将 ds:si指向的内存字单元中word送入es:di中然后根据标志寄存器DF位的值，将si和di递增2或递减2。
</code></pre>
</li>
<li><p><code>movsb</code>和<code>movsw</code>进行的是串传送操作中的一个步骤，一般来说，<code>movsb</code>和<code>movsw</code>都和<code>rep</code>配合使用，格式如下:<code>rep movsb</code>，<code>rep</code>的作用是根据cx的值，重复执行后面的串传送指令。</p>
</li>
<li><p>由于每执行一次<code>movsb</code>指令<code>si</code>和<code>di</code>都会递增或递减指向后一个单元或前个单元，则<code>rep movsb</code>就可以循环实现(cx)个字符的传送。</p>
</li>
<li><p>由于<code>flag</code>的<code>DF</code>位决定着串传送指会执行后，<code>si</code>和<code>di</code>改变的方向，所以<code>CPU</code>应该提供相应的指令来对<code>DF</code>位进行设置，从而使程序员能够决定传送的方向。</p>
</li>
<li><p>8086CPU提供下而两条指会对DF位进行设置</p>
<ul>
<li><code>cld</code>指令:将标志寄存器的DF位置0</li>
<li><code>std</code>指会:将标志寄存器的DF位置1</li>
</ul>
</li>
<li><p>使用串传送指会进行数据的传送，需要给它提供一些必要的信息，它们是:</p>
<ul>
<li>传送的原始位置: <code>ds:si</code>:</li>
<li>传送的目的位置: <code>es:di</code>;</li>
<li>传送的长度:cx</li>
<li>传送的方向:DF</li>
</ul>
</li>
</ul>
<h3 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h3><ul>
<li><p>pushf:将标志寄存器的值压栈;</p>
</li>
<li><p>popf:从栈中弹出数据，送入标志寄存器中。</p>
</li>
<li><p>pushf和popf,为直接访问标志寄存器提供了一种方法。</p>
</li>
</ul>
<h2 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h2><ul>
<li><p>中断是CPU处理外部突发事件的一个重要技术</p>
</li>
<li><p>它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理,处理完成后又立即返回断点，继续进行CPU原来的工作。</p>
</li>
</ul>
<h3 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h3><ul>
<li><p>引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p>
</li>
<li><p>外部中断一般是指由计算机外设发出的中断请求，如:键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说利用中断控制器可以屏蔽这些外部设备的中断请求。</p>
</li>
<li><p>内部中断是指因硬件出错(如突然掉电、奇偶校验错等)或运算出错(除数为零、运算溢出、单步中断等)所引起的中断。内部中断是不可屏蔽的中断。</p>
</li>
<li><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用(INT 21H)等都是软件中断。</p>
</li>
<li><p>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是:(1)除法错误、溢出中断、软件中断 (2)不可屏蔽中断(3)可屏蔽中断 (4)单步中断。</p>
</li>
</ul>
<h3 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h3><ul>
<li><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。</p>
</li>
<li><p>我们知道，中断信息中包含有标识中断源的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序</p>
</li>
<li><p>比如CPU 根据中断类型码4，就可以找到4号中断的处理程序。</p>
</li>
<li><p>可随之而来的问题是，若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据 8位的中断类型码(8086中断类型码为一个字节)得到中断处理程序的段地址和偏移地址呢? 这就要引入“中断向量表”了。</p>
</li>
</ul>
<h3 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h3><ul>
<li><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。</p>
</li>
<li><p>中断向量表就是中断向量的列表</p>
</li>
<li><p>中断向量表在内存中保存，其中存放着 256个中断源所对应的中断处理程序的入口，如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729225113104.png" alt="image-20240729225113104"></p>
</li>
<li><p>中断向量表在内存中存放，对于8086cpu机，中断向量表指定放在内存地址0处</p>
</li>
<li><p>从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。</p>
</li>
</ul>
<p><strong>测试点总结</strong></p>
<p>在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p>
<h3 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h3><ul>
<li><p>可以用中断类型码，在中断向量表中找到中断处理程序的入口</p>
</li>
<li><p>找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。</p>
</li>
<li><p>用中断类型码找到中断向量，并用它设置CS和IP，这个互作是由CPU的硬件自动完成的。</p>
</li>
<li><p>CPU 硬件完成这个工作的过程被称为中断过程</p>
</li>
<li><p>8086CPU的中断过程:</p>
<ul>
<li>(1)(从中断信息中)取得中断类型码</li>
<li>(2)标志寄存器的值入栈(保护标志位)</li>
<li>(3)设置标志寄存器的第8位TF 和第9位IF的值为0   (这一步的目的后面将介绍)</li>
<li>(4)CS的内容入栈;</li>
<li>(5)IP的内容入栈;</li>
<li>(6)从内存地址为中断类型码*4和中断类型码 *4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS·</li>
</ul>
</li>
<li><p>可以看到CPU将CS、IP保存在栈中。</p>
</li>
<li><p>我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位。</p>
</li>
<li><p>我们更简洁的描述中断过程，如下:</p>
<ul>
<li><p>(1)取得中断类型码N;</p>
</li>
<li><p>(2)<code>pushf</code></p>
</li>
<li><p>(3)<code>TF=0，IF=0</code></p>
</li>
<li><p>(4)<code>push CS</code></p>
</li>
<li><p>(5)<code>push IP</code></p>
</li>
<li><p>(6)<code>(IP)=(N*4),(CS)=(N*4+2)</code></p>
<p>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h3><ul>
<li><p>由于CPU随时都可能检测到中断信息，也就是说，CPU 随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间</p>
</li>
<li><p>而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>
</li>
<li><p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤:</p>
<ul>
<li><p>(1)保存用到的寄存器。</p>
</li>
<li><p>(2)处理中断。</p>
</li>
<li><p>(3)恢复用到的寄存器。</p>
</li>
<li><p>(4)用 iret 指令返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iret指令的功能用汇编语法描述为</span><br><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<ul>
<li>iret通常和硬件自动完成的中断过程配合使用。</li>
<li>可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP ，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU到现场恢复标志寄存器和CS、IP的互作。</li>
<li>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-6-除法错误中断的处理"><a href="#12-6-除法错误中断的处理" class="headerlink" title="12.6 除法错误中断的处理"></a>12.6 除法错误中断的处理</h3><ul>
<li><p>下面的内容中，我们通过对 0号中断，即除法错误的中断处理，来体会一下前面所讲的内容</p>
</li>
<li><p>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax,1000h</span><br><span class="line">		mov bh,1</span><br><span class="line">		div bh</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240730173358692.png" alt="image-20240730173358692"></p>
<p>虽然没有提示，但是我们查看中断向量表可以发现跳转的地址是0号储存的</p>
<h3 id="12-7-编译处理0号中断"><a href="#12-7-编译处理0号中断" class="headerlink" title="12.7 编译处理0号中断"></a>12.7 编译处理0号中断</h3><ul>
<li><p>现在我们考虑改变一下0号中断处理程序的功能，即重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to debug“的语句，然后返回到操作系统。</p>
</li>
<li><p>程序分析</p>
<p>一，当发生除法溢出的时候，产生0号中断信息，从而引发中断过程</p>
<ul>
<li>此时，CPU将进行以下工作:</li>
<li>取得中断类型码0;</li>
<li>标志寄存器入栈，TF、IF设置为0:</li>
<li>CS、IP入栈;</li>
<li><code>(IP)=(0*4)，(CS)=(0*4+2)</code></li>
</ul>
<p>二，可见，当中断0发生时，CPU将转去执行中断处理程序。</p>
<ul>
<li>只要按如下步骤编写中断处理程序，当中断0发生时，即可显示“Welcome to debug“</li>
<li>相关处理。</li>
<li>向显示缓冲区送字符串“Welcome to debug“</li>
<li>返回DOS</li>
</ul>
<p>我们将这段程序称为<code>do0</code></p>
<p>三，现在的问题是:do0 应放在内存中。</p>
<ul>
<li><p>因为除法溢出随时可能发生，CPU随时都可能将 CS:IP指向 do0的入口，执行程序。</p>
</li>
<li><p>由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，所以我们要想得到一块内存存放do0，应该向操作系统申请。</p>
</li>
<li><p>但在这里出于两个原因我们不想这样做</p>
<ul>
<li>原因之一:过多地讨论申请内存将偏离问题主线</li>
<li>原因之二:我们学习汇编的一个重要目的就是要获得对计算机底层的编程体验</li>
</ul>
</li>
<li><p>所以，在可能的情况下，我们不去理会操作系统，而直接面向硬件资源。</p>
</li>
<li><p>问题变得简单而直接，我们只需找到一块别的程序不会用到的内存区，将do0传送到其中即可</p>
</li>
<li><p>前面讲到，内存0000:0000~0000:03FF，大小为1KB的空间是系统存放中断处理程序入口地址的中断向量表。一般情况下，从0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。</p>
</li>
<li><p>根据以前的编程经验，我们可以估计出，do0的长度不可能超过256个字节。</p>
</li>
<li><p><strong>结论</strong>:我们可以将do0传送到内存0000:0200处。</p>
</li>
</ul>
<p>四，我们将中断处理程序do0放到 0000:0200后，若要使得除法溢出发生的时候，CPU转去执行do0，则必须将do0的入口地址。即0000:0200登记在中断向量表的对应表项中</p>
<ul>
<li>因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0x4地址单元开始存放，段地址存放在 0x4+2 字单元中，偏移地址存放在0x4字单元中。</li>
<li>也就是说要将do0的段地址0存放在 0000:0002字单元中 ，将偏移地址200H存放在0000:0000字单元中。</li>
</ul>
</li>
<li><p>我们需要做的事</p>
<ul>
<li>(1)编写可以显示“Welcome to debug”的中断处理程序:do0;</li>
<li>(2)将do0送入内存0000:0200处;</li>
<li>(3)将do0的入口地址0000:0200存储在中断向表0号表项中。</li>
</ul>
<p>程序框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以看到，上面的程序分为两部分:<ul>
<li>(1)安装do0，设置中断向量的程序</li>
<li>(2)do0</li>
</ul>
</li>
<li>程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。</li>
<li>执行do0安装程序，将do0 的代码拷贝到内存0:200处，然后设置中断向量表，即偏移地址200H和段地址0，保存在0号表项中。这两部<br>分工作完成后，程序就返回了</li>
<li>程序的目的就是在内存0:200处安装do0 的代码，将0号中断处理程感的入口地址设置为0:200。</li>
<li>do0的代码虽然在程序中，却不在程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。</li>
<li>do0部分代码的最后两条指令是依照我们的编程要求，用来返回DOS的。</li>
</ul>
</li>
</ul>
<h3 id="12-8-安装"><a href="#12-8-安装" class="headerlink" title="12.8 安装"></a>12.8 安装</h3><ul>
<li><p>可以使用movsb指令，将do0的代码送入0:200处</p>
</li>
<li><p>用rep movsb指令的时候需要确定的信息:</p>
<ul>
<li>(1)传送的原始位置，段地址:code，偏移地址:offset do0 ;</li>
<li>(2)传送的目的位置:0:200;</li>
<li>(3)传送的长度:do0部分代码的长度;</li>
<li>(4)传送的方向:正向。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,do0长度</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何确定cx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>通过 <code>offset do0end - offset do0</code>和 <code>do0end: nop</code> 可以确定do0的长度</p>
<ul>
<li><code>-</code> 是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。</li>
</ul>
<p>  比如 : mov ax,8-4  被<strong>编译器</strong>处理为指令:mov ax,4 </p>
<ul>
<li>编译器还可以处理表达式。比如指令:mov ax,(5+3)*5&#x2F;10，被编译器处理为指令:mov ax,4</li>
</ul>
</li>
</ul>
<h3 id="12-9-do0"><a href="#12-9-do0" class="headerlink" title="12.9 do0"></a>12.9 do0</h3><ul>
<li><p>do0的任务是显示字符串我们就直接用实验十的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment </span><br><span class="line">db &#x27;Welcome to debug&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:</span><br><span class="line">         mov dh,3</span><br><span class="line">		 mov dl,1</span><br><span class="line">	  	 mov cl,2</span><br><span class="line">		 mov ax,data</span><br><span class="line">	  	 mov ds,ax</span><br><span class="line">		 mov si,0</span><br><span class="line">		 call show_str</span><br><span class="line">		</span><br><span class="line">		 mov ax,4c00h</span><br><span class="line">		 int 21h</span><br><span class="line">		</span><br><span class="line">show_str:mov ax,cx</span><br><span class="line">		 mov cl,[si]</span><br><span class="line">		 mov ch,0</span><br><span class="line">		 jcxz s</span><br><span class="line">		 mov cx,ax</span><br><span class="line">		 push dx</span><br><span class="line">		 mov bx,dx</span><br><span class="line">		 mov ax,0B800h</span><br><span class="line">		 mov es,ax</span><br><span class="line">		 mov dl,dh</span><br><span class="line">		 mov dh,0</span><br><span class="line">		 mov ax,0A0h</span><br><span class="line">		 mul dx</span><br><span class="line">	     mov bh,0</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 mov bx,ax</span><br><span class="line">		 mov al,[si]</span><br><span class="line">		 mov ah,cl</span><br><span class="line">		 mov di,si</span><br><span class="line">		 add di,di</span><br><span class="line">		 mov es:[bx+di],ax</span><br><span class="line">		 inc si</span><br><span class="line">		 pop dx</span><br><span class="line">		 jmp show_str</span><br><span class="line">	s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>但是，这么处理是有问题的，’Welcome to debug’在程序ti.exe的data段中。程序ti.exe执行完成后返回它所占用的内存空间被系统释放，而在其中存放的’Welcome to debug’也将很可能被别的信息覆盖</strong></p>
<p>所以这段字符串也应该放在一段不会被覆盖的程序中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:	 jmp short do0start</span><br><span class="line">		 db &#x27;Welcome to debug&#x27;,0</span><br><span class="line">		 </span><br><span class="line">do0start:mov dh,3</span><br><span class="line">		 mov dl,1</span><br><span class="line">	  	 mov cl,2</span><br><span class="line">		 mov ax,0020H;这里修改了数据段的段地址指向do0的段地址</span><br><span class="line">	  	 mov ds,ax</span><br><span class="line">		 mov si,2;这里设置代码段起始地址跳过前两个字节就是那个jmp</span><br><span class="line">		 call show_str</span><br><span class="line">		</span><br><span class="line">		 mov ax,4c00h</span><br><span class="line">		 int 21h</span><br><span class="line">		</span><br><span class="line">show_str:mov ax,cx</span><br><span class="line">		 mov cl,[si]</span><br><span class="line">		 mov ch,0</span><br><span class="line">		 jcxz s</span><br><span class="line">		 mov cx,ax</span><br><span class="line">		 push dx</span><br><span class="line">		 mov bx,dx</span><br><span class="line">		 mov ax,0B800h</span><br><span class="line">		 mov es,ax</span><br><span class="line">		 mov dl,dh</span><br><span class="line">		 mov dh,0</span><br><span class="line">		 mov ax,0A0h</span><br><span class="line">		 mul dx</span><br><span class="line">	     mov bh,0</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 mov bx,ax</span><br><span class="line">		 mov al,[si]</span><br><span class="line">		 mov ah,cl</span><br><span class="line">		 mov di,si</span><br><span class="line">		 add di,di</span><br><span class="line">		 mov es:[bx+di],ax</span><br><span class="line">		 inc si</span><br><span class="line">		 pop dx</span><br><span class="line">		 jmp show_str</span><br><span class="line">	s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-10-设置中断向量"><a href="#12-10-设置中断向量" class="headerlink" title="12.10 设置中断向量"></a>12.10 设置中断向量</h3><ul>
<li>我们将do0的入口地址0:200，写入中断向量表的0号表项中，使do0成为<br>0 号中断的中断处理程序。</li>
<li>0号表项的地址为0:0，其中0:0字单元存放偏移地址，0:2字单元存放段地址</li>
</ul>
<p>完整的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0],200H</span><br><span class="line">mov word ptr es:[2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:	 jmp short do0start</span><br><span class="line">		 db &#x27;Welcome to debug&#x27;,0</span><br><span class="line">		 </span><br><span class="line">do0start:mov dh,3</span><br><span class="line">		 mov dl,1</span><br><span class="line">	  	 mov cl,2</span><br><span class="line">		 mov ax,0020H</span><br><span class="line">	  	 mov ds,ax</span><br><span class="line">		 mov si,2</span><br><span class="line">		 call show_str</span><br><span class="line">		</span><br><span class="line">		 mov ax,4c00h</span><br><span class="line">		 int 21h</span><br><span class="line">		</span><br><span class="line">show_str:mov ax,cx</span><br><span class="line">		 mov cl,[si]</span><br><span class="line">		 mov ch,0</span><br><span class="line">		 jcxz s</span><br><span class="line">		 mov cx,ax</span><br><span class="line">		 push dx</span><br><span class="line">		 mov bx,dx</span><br><span class="line">		 mov ax,0B800h</span><br><span class="line">		 mov es,ax</span><br><span class="line">		 mov dl,dh</span><br><span class="line">		 mov dh,0</span><br><span class="line">		 mov ax,0A0h</span><br><span class="line">		 mul dx</span><br><span class="line">	     mov bh,0</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 add ax,bx</span><br><span class="line">		 mov bx,ax</span><br><span class="line">		 mov al,[si]</span><br><span class="line">		 mov ah,cl</span><br><span class="line">		 mov di,si</span><br><span class="line">		 add di,di</span><br><span class="line">		 mov es:[bx+di],ax</span><br><span class="line">		 inc si</span><br><span class="line">		 pop dx</span><br><span class="line">		 jmp show_str</span><br><span class="line">	s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>触法程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,0</span><br><span class="line">div bx</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731233600145.png" alt="image-20240731233600145"></p>
<p>重启dos再运行te.exe会有效果吗</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234420964.png" alt="image-20240731234420964"></p>
<p>直接运行系统卡死</p>
<p>单步调试，也没有跳转到0000：0200</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234300060.png" alt="image-20240731234300060"></p>
<p>我们查看0000：0200 发现没有东西了</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234227184.png" alt="image-20240731234227184"></p>
<h3 id="12-11-单步中断"><a href="#12-11-单步中断" class="headerlink" title="12.11 单步中断"></a>12.11 单步中断</h3><ul>
<li><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。</p>
</li>
<li><p>单步中断的中断类型码为1，则它所引发的中断过程如下:<br>(1)取得中断类型码1<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(1*4),(CS)=(1*4+2)。</code></p>
</li>
<li><p>如上所述，如果TF&#x3D;1，则执行一条指令CPU就要转去执行1号中断处理程房</p>
</li>
<li><p>同样的道理，Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p>
</li>
<li><p>在使用T命令执行指令时，Debug 将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入指令</p>
</li>
<li><p>总之，当TF&#x3D;1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。执行完中断处理程序后，又返回原来的位置继续..</p>
</li>
<li><p>(1)取得中断类型码N<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(N*4),(CS)=(N*4+2)。</code></p>
</li>
<li><p>最后，CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p>
</li>
</ul>
<h3 id="12-12-响应中断的特殊情况"><a href="#12-12-响应中断的特殊情况" class="headerlink" title="12.12 响应中断的特殊情况"></a>12.12 响应中断的特殊情况</h3><ul>
<li><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU 在执行完当前指令后，即便是发生中断，也不会响应。</p>
</li>
<li><p>例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801000410097.png" alt="image-20240801000410097"></p>
</li>
</ul>
<h2 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13 int指令"></a>13 int指令</h2><h3 id="13-1-int指令"><a href="#13-1-int指令" class="headerlink" title="13.1 int指令"></a>13.1 int指令</h3><ul>
<li><p>int格式:<code>int n</code>，n为中断类型码。它的功能是引发中断过程。</p>
</li>
<li><p>CPU 执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下:</p>
<p>(1)取得中断类型码N<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(N*4),(CS)=(N*4+2)。</code></p>
<p>从此处转去执行n号中断的中断处理程序</p>
</li>
<li><p>可以在程序中使用int指令调用任何一个中断的中断处理程序。</p>
</li>
</ul>
<p><strong>例如</strong></p>
<p>我们先运行ti.exe再运行int 0</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801002013524.png" alt="image-20240801002013524"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801002054497.png" alt="image-20240801002054497"></p>
<ul>
<li><p>可见，int指令的最终功能和ca1l指令相似，都是调用一段程序。</p>
</li>
<li><p>因此，一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p>
</li>
<li><p>我们在编程的时候，可以用int指会调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。</p>
</li>
<li><p>以后，我们可以将中断处理程序简称为中断例程。</p>
</li>
</ul>
<h3 id="13-2-编写供应用程序调用的中断例程"><a href="#13-2-编写供应用程序调用的中断例程" class="headerlink" title="13.2 编写供应用程序调用的中断例程"></a>13.2 编写供应用程序调用的中断例程</h3><ul>
<li>前面，我们已经编写过中断0的中断例程了现在我们讨论可以供应用程序调用的中断例程的编写方法。</li>
</ul>
<p>实例一</p>
<p> 编写、安装中断7ch的中断例程，实现求word型数据的平方。</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801003112410.png" alt="image-20240801003112410"></p>
<p>注意再中断例程的最后要使用iret指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iret指令的功能用汇编语法描述为</span><br><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch 执行前的标志寄存器和CS、IP的值，从而接着执行应用程序。</p>
</li>
<li><p>int指令和 iret指令的配合使用与cal1指合和ret指令的配合使用具有相似的思路。</p>
</li>
</ul>
<p>实例二</p>
<p>功能:将一个全是字母，以 0 结尾的字符串，转化为大写。</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801005251434.png" alt="image-20240801005251434"></p>
<ul>
<li>最后，在中断例程中用到了寄存器 si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。</li>
</ul>
<h3 id="13-3-对int，iret和栈的深入理解"><a href="#13-3-对int，iret和栈的深入理解" class="headerlink" title="13.3 对int，iret和栈的深入理解"></a>13.3 对int，iret和栈的深入理解</h3><ul>
<li><p>问题：用7ch中断例程完成 1oop指令的功能。</p>
</li>
<li><p>loop s的执行需要两个信息，循环次数和到s的位移，所以，7ch中断例程要完成loop指令的功能，也需要这两个信息作为参数。我们用cx存放循环次数，用bx存放位移。</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801192824122.png" alt="image-20240801192824122"></p>
</li>
<li><p>分析，为了模拟loop指令，7ch中断例程应具备下面的功能:</p>
<ul>
<li>(1)dec cx</li>
<li>(2)如果(cx)≠0，转到标号s处执行，否则向下执行。</li>
</ul>
</li>
<li><p>7ch中断例程如何实现到目的地址的转移</p>
<ul>
<li>(1)转到标号s显然应设(CS)&#x3D;标号s的段地址，(IP)&#x3D;标号s的偏移地址;</li>
<li>(2)那么，中断例程如何得到标号s的段地址和偏移地址呢?</li>
<li>(3)现在知道，可以从栈中直接和间接地得到标号s的段地址和偏移地址，那么如何用它们设置CS:IP呢?</li>
</ul>
</li>
<li><p>int 7ch引发中断过程后，进入 7ch 中断例程，在中断过程中，当前的标志寄存器、CS和IP都要压栈:</p>
</li>
<li><p>此时压入的CS和IP中的内容，分别是调用程序的段地址(可以认为是标号s的段地址)和int 7ch后一条指令的偏移地址(即标号se的偏移地址)。</p>
</li>
<li><p>可以利用iret指令，我们将栈中的se的偏移地址加上 bx 中的转移位移，则栈中的se的偏移地址就变为了s的偏移地址。（mov bx,offset s-offset se 可以知道bx是表示的负数）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195447471.png" alt="image-20240801195447471"></p>
<p>我们先编写好程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200H</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:	</span><br><span class="line">lp:		push bp</span><br><span class="line">		mov bp,sp</span><br><span class="line">		dec cx</span><br><span class="line">		jcxz lpret</span><br><span class="line">		add [bp+2],bx</span><br><span class="line">lpret:  pop bp</span><br><span class="line">		iret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,0b800h</span><br><span class="line">		mov es,ax</span><br><span class="line">		mov di,160*12</span><br><span class="line">		mov bx,offset s-offset se</span><br><span class="line">		mov cx,80</span><br><span class="line">	s:  mov byte ptr es:[di],&#x27;!&#x27;</span><br><span class="line">		add di,2</span><br><span class="line">		int 7ch</span><br><span class="line">		se:nop</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>再单步调试</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195359092.png" alt="image-20240801195359092"></p>
<p>注意执行标号s时的ip为E</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195710223.png" alt="image-20240801195710223"></p>
<p>我们发现成功修改ip值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">只要在[...]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195923255.png" alt="image-20240801195923255"></p>
<p>成功跳转到标号s</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195953840.png" alt="image-20240801195953840"></p>
<p>运行程序，成功显示<code>！</code></p>
<h3 id="13-4-BIOS和DOS所提供的中断例程"><a href="#13-4-BIOS和DOS所提供的中断例程" class="headerlink" title="13.4 BIOS和DOS所提供的中断例程"></a>13.4 BIOS和DOS所提供的中断例程</h3><ul>
<li><p>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，BIOS中主要包含以下几部分内容。<br>(1)硬件系统的检测和初始化程序;<br>(2)外部中断(第15 章中进行讲解)和内部中断的中断例程:<br>(3)用于对硬件设备进行 I&#x2F;O操作的中断例程;<br>(4)其他和硬件系统相关的中断例程。</p>
</li>
<li><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。</p>
</li>
<li><p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和 DOS 提供的中断例程，来完成某些工作。</p>
</li>
<li><p>和硬件设备相关的 DOS中断例程中，一般都调用了BIOS的中断例程。</p>
</li>
</ul>
<h3 id="13-5-BIOS和DOS中断例程的安装过程"><a href="#13-5-BIOS和DOS中断例程的安装过程" class="headerlink" title="13.5 BIOS和DOS中断例程的安装过程"></a>13.5 BIOS和DOS中断例程的安装过程</h3><ul>
<li><p>(1)开机后，CPU一加电，初始化(CS)&#x3D;0FFFFH，(IP)&#x3D;0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p>
</li>
<li><p>(2)初始化程序将建立BIOS 所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p>
</li>
<li><p>(3)硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p>
</li>
<li><p>(4)DOS 启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
</li>
</ul>
<h3 id="13-6-BIOS中断例程的应用"><a href="#13-6-BIOS中断例程的应用" class="headerlink" title="13.6 BIOS中断例程的应用"></a>13.6 BIOS中断例程的应用</h3><p>通过举例子来了解BIOS中断例程的应用</p>
<ul>
<li><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏慕输出相关的子程序。</p>
</li>
<li><p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序。</p>
</li>
<li><p>BIOS 和DOS 提供的中断例程，都用<strong>ah</strong>来传递内部子程序的编号</p>
</li>
<li><p>我们看一下int 10h中断例程的设置光标位置功能。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801202531632.png" alt="image-20240801202531632"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bh中页号的含义:内存地址空间中，B8000h~BFFFFh共 32K的空间，为80*25 彩色字符模式的显示缓冲区。</span><br><span class="line">一屏的内容在显示缓冲区中共占4000个字节，</span><br><span class="line">也就是说，通常情况下，B8000~B8F9F中的4000个字节的内容将出现在显示器上。</span><br><span class="line">一般情况下，显示第0页的内容。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801203037506.png" alt="image-20240801203037506"></p>
<p><strong>实验</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100031894.png" alt="image-20240802100031894"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100043638.png" alt="image-20240802100043638"></p>
<p>我们发现输入数据的地方出现在中间</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802100249831.png" alt="image-20240802100249831"></p>
<p>输入数据也是直接覆盖</p>
<p>debug调试</p>
<p>我们发现在执行int 10h的第一条指令就发生了跳转</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100506923.png" alt="image-20240802100506923"></p>
<p>并且执行一条指令后就退出了</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100715597.png" alt="image-20240802100715597"></p>
<p>查看地址里面也只有三条指令</p>
<p><strong>实验2</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101036530.png" alt="image-20240802101036530"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101054015.png" alt="image-20240802101054015"></p>
<p>debug调试</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101240601.png" alt="image-20240802101240601"></p>
<h3 id="13-7-DOS中断例程的应用"><a href="#13-7-DOS中断例程的应用" class="headerlink" title="13.7 DOS中断例程的应用"></a>13.7 DOS中断例程的应用</h3><ul>
<li><p>int 21h 中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p>
</li>
<li><p>我们从前一直使用的是 int 21h中断例程的4ch号功能，即程序返回功能，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch    ;程序返回</span><br><span class="line">mov al,0      ;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<ul>
<li><p>(ah)&#x3D;4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。<br>我们前面使用这个功能的时候经常写作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>int 21h中断例程的在光标位置显示字符串的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx指向字符串 ;要显示的字符串需用“$”作为结束符</span><br><span class="line">mov ah,9      ;功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<ul>
<li>(ah)&#x3D;9表示调用第21h号中断例程的 9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</li>
<li>编程:在屏幕的5列12行显示字符串</li>
<li>“$”本身不显示，只起到边界的作用</li>
<li>如果字符串比较长，遇到行尾，程序会自动转到下一行开头处继续显示;如果到了最后一行，还能自动上卷一行。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802103342796.png" alt="image-20240802103342796"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802103606719.png" alt="image-20240802103606719"></p>
<p>我们发现int 10h的程序2的功能是设置光标的功能，这时在运行int 21h的程序9就可以达到我们想要的效果</p>
<h2 id="14-端口"><a href="#14-端口" class="headerlink" title="14 端口"></a>14 端口</h2><ul>
<li><p>CPU可以直接读写3 个地方的数据</p>
<p>(1)CPU 内部的寄存器</p>
<p>(2)内存单元</p>
<p>(3)端口</p>
</li>
</ul>
<h3 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h3><ul>
<li><p>对端口的读写不能用mov、push、pop等内存读写指令。</p>
</li>
<li><p>端口的读写指令只有两条:in 和 out分别用于从端口读取数据和往端口写入数据。</p>
</li>
<li><p>CPU 执行内存访问指令和端口指令时候，总线上的信息:<br>(1)访问内存<br>(2)访问端口</p>
</li>
<li><p>访问内存</p>
<p><code>mov ax,ds:[8]</code><br>假设执行前(ds)&#x3D;0<br>执行时，与总线相关的操作:</p>
<ul>
<li>CPU通过地址线将地址信息8发出;</li>
<li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据;</li>
<li>存储器将 8号单元中的数据通过数据线送入CPU 。</li>
</ul>
</li>
<li><p>访问端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作:</p>
<ul>
<li>CPU通过地址线将地址信息60h发出;</li>
<li>CPU通过控制线发出端口读命令，选中端所在的芯片，并通知它，将要从中读取数据;</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU 8</li>
</ul>
</li>
<li><p>注意:在in和out 指令中，只能使用 ax或al 来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al ，访问16 位端口时用ax。</p>
</li>
<li><p>对0~255内的端口进行读写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure>

<p>对256~65535的端口进行读写时，端口号放在dx中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-2-CMOS-RAM-芯片"><a href="#14-2-CMOS-RAM-芯片" class="headerlink" title="14.2 CMOS RAM 芯片"></a>14.2 CMOS RAM 芯片</h3><ul>
<li>PC机中有一个CMOS RAM芯片,其有如下特征:<ul>
<li>(1)包合一个实时钟和一个有128个存储单元的RAM存储器。(早期的计算机为64个字节)</li>
<li>(2)该芯片靠电池供电。因此，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失</li>
<li>(3)128 个字节的 RAM 中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM 中的系统信息。</li>
<li>(4)该芯片内部有两个端口，端口地址为70h和71h。CPU 通过这两个端口读写CMOS RAM </li>
<li>(5)70h为地址端口，存放要访问的CMOSRAM单元的地址;71h为数据端口，存放从选定的CMOS RAM 单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行。<br>比如:读CMOS RAM的2号单元:<ul>
<li>1、将2送入端口70h</li>
<li>2、从71h读出2号单元的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>向CMOS RAM芯片写入数据后读取</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802215348216.png" alt="image-20240802215348216"></p>
<p>我们debug调试发现</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802215424134.png" alt="image-20240802215424134"></p>
<p>在我们向AL赋值后我们再读取其中的值并不是0</p>
<p>而且我们再次调试</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802215625490.png" alt="image-20240802215625490"></p>
<p>结果仍然在变</p>
<p><strong>时间在CMOS RAM中的表示形式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">秒：在0号单元</span><br><span class="line">分：2</span><br><span class="line">时：4</span><br><span class="line">日：7</span><br><span class="line">月：8</span><br><span class="line">年：9</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802220000440.png" alt="image-20240802220000440"></p>
<p>我们发现这个和分针有关系</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802220049384.png" alt="image-20240802220049384"></p>
<h3 id="14-3-shl和shr指令"><a href="#14-3-shl和shr指令" class="headerlink" title="14.3 shl和shr指令"></a>14.3 shl和shr指令</h3><ul>
<li><p>shl和shr 是逻辑移位指令，后面的课程中我们要用到移位指令，这里进行一下讲解。</p>
</li>
<li><p>shl逻辑左移指令，功能为:</p>
<ul>
<li><p>(1)将一个寄存器或内存单元中的数据向左移位;</p>
</li>
<li><p>(2)将最后移出的一位写入CF中</p>
</li>
<li><p>(3)最低位以0来补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1   ;将al中的数据左移一位</span><br><span class="line">执行后(al)=10010000b,cf=0</span><br></pre></td></tr></table></figure>

<p>如果移动位数大于1时，必须将移动位数放在cl中。</p>
<p><strong>试试</strong></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221328123.png" alt="image-20240802221328123"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221242724.png" alt="image-20240802221242724"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221253887.png" alt="image-20240802221253887"></p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802221406305.png" alt="image-20240802221406305"></p>
<p>我们试试第一位为1时</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221429520.png" alt="image-20240802221429520"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221458025.png" alt="image-20240802221458025"></p>
<p>发现NC变为CY</p>
<p>多次移位</p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802221854346.png" alt="image-20240802221854346"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221907392.png" alt="image-20240802221907392"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221843494.png" alt="image-20240802221843494"></p>
<p>我们发现cf的值仍是以最后输入的一位为主的</p>
</li>
</ul>
</li>
<li><p>我们发现将x左移一位，相当于把它乘以2</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802222151283.png" alt="image-20240802222151283"></p>
<p>cf的意思就是相当于产生了进位</p>
</li>
<li><p>shr逻辑右移指令，它和shl所进行的操作刚好相反</p>
<ul>
<li>(1)将一个寄存器或内存单元中的数据向右移位;</li>
<li>(2)将最后移出的一位写入CF中</li>
<li>(3)最高位以0来补充</li>
</ul>
</li>
<li><p>我们发现将x右移一位，相当于把它除以2</p>
</li>
</ul>
<h3 id="14-4-CMOS-RAM中存储的时间信息"><a href="#14-4-CMOS-RAM中存储的时间信息" class="headerlink" title="14.4 CMOS RAM中存储的时间信息"></a>14.4 CMOS RAM中存储的时间信息</h3><ul>
<li><p>在CMOS RAM中，存放着当前时间:<br>秒:00H<br>分:02H<br>时:04H<br>日:07H<br>月:08H<br>年:09H</p>
</li>
<li><p>这6个信息的长度长度都为1个字节。</p>
</li>
<li><p>这些数据以BCD码的方式存放</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802224825744.png" alt="image-20240802224825744"></p>
</li>
<li><p>可见，一个字节可表示两个BCD码。则CMOS RAM存储时间信息的单元中存储了用两个 BCD码表示的两位十进制数，高 4 位的BCD码表示十位，低4位的BCD 码表示个位。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov al,8</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h;这一段是获取8号单元也就是月份的数据</span><br><span class="line"></span><br><span class="line">add al,48;我们获取的数据不是ascll码所以要加上48</span><br><span class="line"></span><br><span class="line">mov cx,0b800h</span><br><span class="line">mov ds,cx</span><br><span class="line">mov bx,[160*8+2*15];设置显存地址</span><br><span class="line">mov ah,0cah;设置背景</span><br><span class="line">mov ds:[bx],ax;加载入显存</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802231724996.png" alt="image-20240802231724996"></p>
<h2 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15 外中断"></a>15 外中断</h2><ul>
<li><p>CPU 在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入、向它们进行输出。</p>
</li>
<li><p>也就是说，CPU 除了有运能力外，还要有 I&#x2F;O(Input&#x2F;Output ，输入&#x2F;输出)能力</p>
</li>
</ul>
<h3 id="15-1-接口芯片和端口"><a href="#15-1-接口芯片和端口" class="headerlink" title="15.1 接口芯片和端口"></a>15.1 接口芯片和端口</h3><ul>
<li><p>第 14 章我们讲过，在PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU 将这些寄存器当作端口来访问。</p>
</li>
<li><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中;</p>
</li>
<li><p>CPU 向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</p>
</li>
<li><p>CPU 还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</p>
</li>
<li><p>可见，<strong>CPU 通过端口和外部设备进行联系</strong></p>
</li>
<li><p>CPU 在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p>
</li>
</ul>
<h3 id="15-2-外中断信息"><a href="#15-2-外中断信息" class="headerlink" title="15.2 外中断信息"></a>15.2 外中断信息</h3><ul>
<li><p>pc系统中，外中断源一共有两类</p>
<ol>
<li>可屏蔽中断</li>
<li>不可屏蔽中断（少）</li>
</ol>
</li>
<li><p>可屏蔽中断是CPU 可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。</p>
<ul>
<li><p>当CPU 检测到可屏蔽中断信息时:</p>
<ul>
<li>如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程;</li>
<li>如果IF&#x3D;0,则不响应可屏蔽中断。</li>
</ul>
</li>
<li><p>可屏蔽中断所引发的中断过程 ，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。</p>
</li>
<li><p>因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的</p>
</li>
<li><p>而内中断的中断类型码是在CPU内部产生的</p>
</li>
<li><p>现在，我们可以解释中断过程中将IF置为0的原因了。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。</p>
</li>
<li><p>当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指会将IF 设置为1</p>
</li>
<li><p>8086cpu中设置IF的指令</p>
<ul>
<li>sti：用于设置IF&#x3D;1</li>
<li>cli：用于设置IF&#x3D;0</li>
</ul>
</li>
</ul>
</li>
<li><p>不可屏蔽中断是CPU 必须响应的外中断。当CPU 检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</p>
<ul>
<li>对于8086CPU 不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</li>
<li>不可屏蔽中断的中断过程<ul>
<li>标志寄存器入栈，TF、IF设置为0:</li>
<li>CS、IP入栈;</li>
<li><code>(IP)=(8)，(CS)=(0AH)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件(比如说键盘输入)发生时，相关芯片向CPU发出可屏蔽中断信息。</p>
</li>
<li><p>不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU 的中断信息。在我们的课程中，主要讨论可屏蔽中断</p>
</li>
</ul>
<h3 id="15-3-PC机键盘的处理过程"><a href="#15-3-PC机键盘的处理过程" class="headerlink" title="15.3 PC机键盘的处理过程"></a>15.3 PC机键盘的处理过程</h3><ul>
<li><p>观察键盘输入的处理过程，体会PC机处理外设输入的基本方法</p>
<ol>
<li>键盘输入</li>
<li>引发9号中断</li>
<li>执行int 9中断例程</li>
</ol>
<ul>
<li><p>键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。</p>
</li>
<li><p>按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。</p>
</li>
<li><p>松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H 端口中。</p>
</li>
<li><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p>
</li>
<li><p>扫描码长度为一个字节，通码的第7 位为0，断码的第7位为1，即:<br>断码 &#x3D; 通码+80H</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235148560.png" alt="image-20240802235148560"></p>
<p>比如:g键的通码为22H，断码为a2H</p>
<p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240802235245995.png" alt="image-20240802235245995"><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235316275.png" alt="image-20240802235316275"></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235539345.png" alt="image-20240802235539345"></p>
<ul>
<li><p>BIOS 提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下:</p>
<ol>
<li>读出60H 端口中的扫描码</li>
<li>如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCII码)送入内存中的 BIOS 键盘缓冲区</li>
</ol>
<ul>
<li><p>键盘的输入到达60H 端口时，相关的芯片就会向CPU 发出中断类型码为9的可屏蔽中断信息</p>
</li>
<li><p>CPU检测到该中断信息后，如果IF&#x3D;1，则响应中断，引发中断过程，转去执行int 9中断例程。</p>
</li>
<li><p>如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节),写入内存中存储状态字节的单元。</p>
</li>
</ul>
<ol start="3">
<li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li>
</ol>
<ul>
<li>BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接收的键盘输入的内存区。</li>
<li>该内存区可以存储 15 个键盘输入，因为int 9h中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</li>
</ul>
</li>
<li><p>0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下:</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803000627264.png" alt="image-20240803000627264"></p>
</li>
</ul>
<h3 id="15-4-编写int-9h中断例程"><a href="#15-4-编写int-9h中断例程" class="headerlink" title="15.4 编写int 9h中断例程"></a>15.4 编写int 9h中断例程</h3><p>从上面的内容中，可以看出键盘输入的处理过程:</p>
<ol>
<li>键盘产生扫描码;</li>
<li>扫描码送入60h端口;</li>
<li>引发9号中断;</li>
<li>CPU执行int9中断例程处理键盘输入。</li>
</ol>
<p>我们能修改的就只有4</p>
<p><strong>问题</strong></p>
<p>编程:在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下Esc 键后，改变显示的颜色。</p>
<p>首先是依次显示a到z</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,[160*8+2*12]</span><br><span class="line">	mov al,&#x27;a&#x27;</span><br><span class="line">s:  mov ds:[bx],al</span><br><span class="line">	inc al</span><br><span class="line">	cmp al,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803002554249.png" alt="image-20240803002554249"></p>
<p>可能是我电脑处理的太快，他只能看到最后的z</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls dos中的清屏指令</span><br></pre></td></tr></table></figure>

<p>我们应该在每显示一个字母后，延时一段时间，让人看清后再显示下一个字母，如何延时呢？</p>
<p>做空循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,[160*8+2*12]</span><br><span class="line">	mov al,&#x27;a&#x27;</span><br><span class="line">s:  call lti</span><br><span class="line">	mov ds:[bx],al</span><br><span class="line">	inc al</span><br><span class="line">	cmp al,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">lti:push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,1000h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: sub al,1;此时产生借位，并且al为ff，我电脑太撇火了我就循环少点</span><br><span class="line">	sbb dx,0</span><br><span class="line">	cmp al,0;这里要循环ff次，如果是ax就是ffff次</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0;第一次到达这里dx的值为0fff，al为0，又开始第一轮循环，直到dx=0，循环1000h*ffh次</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>之后我们要做的是按下esc改变颜色</p>
<p>键盘输入到达60h 端口后，就会引发 9号中断CPU 则转去执行int 9中断例程。</p>
<p>我们可以编写int 9中断例程，功能如下:</p>
<p>(1)从60h 端口读出键盘的输入;</p>
<p>(2)调用BTOS的int9中断例程，处理其他硬件细节;</p>
<p>(3)判断是否为Esc的扫描码，如果是，改 变显示的颜色后返回;如果不是则直接返回</p>
<ul>
<li><p>新的中断处理程序中调用原来的int 9中断例程时，中断向量表中的int 9中断例程的入口地址却不是原来的int9中断例珵的地址。所以我们不能使用int 指令直接调用，因为你已经对中断向量表中的9号地址进行了更改</p>
</li>
<li><p>对于我们现在的问题，假设我们将原来int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元，那么我们在需要调用原来的int 9中断例程时候，就可以在 ds:[0]、ds:[2]单元中找到它的入口地址那么，有了入口地址后，我们如何进行调用呢?当然不能使用指令int 9来调用。我们可以用别的指令来对int指会进行一些模拟，从而实现对中断例程的调用。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPU 执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下:</span><br><span class="line"></span><br><span class="line">(1)取得中断类型码N</span><br><span class="line">(2)标志寄存器入栈，TF、IF设置为0</span><br><span class="line">(3)CS、IP入栈</span><br><span class="line">(4)`(IP)=(N*4),(CS)=(N*4+2)。`</span><br><span class="line"></span><br><span class="line">从此处转去执行n号中断的中断处理程序</span><br></pre></td></tr></table></figure>

<p>模拟代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标志寄存器入栈，TF、IF设置为0//pushf</span><br><span class="line">CS、IP入栈</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实现IF=0，TF=0步骤</span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b;IF和OK为标志寄存器的第9位和第8位</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<p>全部代码太麻烦了，我就不写了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:	mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,128</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov es,ax</span><br><span class="line">		push es:[9*4]</span><br><span class="line">		pop ds:[0]</span><br><span class="line">		push es:[9*4+2]</span><br><span class="line">		pop ds:[2]</span><br><span class="line">		mov word ptr es:[9*4],offset int9</span><br><span class="line">		mov es:[9*4+2],cs</span><br><span class="line">		mov ax,0b800h</span><br><span class="line">		mov es,ax</span><br><span class="line">		mov ah,&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">s:		mov es:[160*12+40*2],ah</span><br><span class="line">		call delay</span><br><span class="line">		inc ah</span><br><span class="line">		cmp ah,&#x27;z&#x27;</span><br><span class="line">		jna s</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov es,ax</span><br><span class="line">		push ds:[0];恢复向量表</span><br><span class="line">		pop es:[9*4]</span><br><span class="line">		push ds:[2]</span><br><span class="line">		pop es:[9*4+2]</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line">delay:	push ax</span><br><span class="line">		push dx</span><br><span class="line">		mov dx,1000h</span><br><span class="line">		mov ax,0</span><br><span class="line">s1:		sub al,1</span><br><span class="line">		sbb dx,0</span><br><span class="line">		cmp al,0</span><br><span class="line">		jne s1</span><br><span class="line">		cmp dx,0</span><br><span class="line">		jne s1</span><br><span class="line">		pop dx</span><br><span class="line">		pop ax</span><br><span class="line">		ret		</span><br><span class="line"></span><br><span class="line">int9:	push ax</span><br><span class="line">		push bx</span><br><span class="line">		push es</span><br><span class="line">		in al,60h</span><br><span class="line">		pushf		;保存标志寄存器</span><br><span class="line">		</span><br><span class="line">		pushf</span><br><span class="line">		pop bx</span><br><span class="line">		and bh,11111100b</span><br><span class="line">		push bx</span><br><span class="line">		popf		;修改if和tf   </span><br><span class="line">		</span><br><span class="line">		call dword ptr ds:[0];跳转真的int9</span><br><span class="line">		</span><br><span class="line">		cmp al,1;esc的键盘扫描码为1</span><br><span class="line">		jne int9ret;不相等就直接跳转，只有esc的时候才向下执行</span><br><span class="line">		</span><br><span class="line">		mov ax,0b800h</span><br><span class="line">		mov es,ax</span><br><span class="line">		inc byte ptr es:[160*12+40*2+1]</span><br><span class="line">int9ret:pop es</span><br><span class="line">		pop bx</span><br><span class="line">		pop ax</span><br><span class="line">		iret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="15-5-安装新的int-9-中断例程"><a href="#15-5-安装新的int-9-中断例程" class="headerlink" title="15.5 安装新的int 9 中断例程"></a>15.5 安装新的int 9 中断例程</h3><p>任务：安装一个新的int 9中断例程</p>
<p>功能：在DOS下，按F1后改变当前屏幕的显示颜色，其他键照常处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,128</span><br><span class="line">		push cs</span><br><span class="line">		pop ds</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov es,ax</span><br><span class="line">		mov si,offset int9</span><br><span class="line">		mov di,204h</span><br><span class="line">		mov cx,offset int9end-offset int9</span><br><span class="line">		cld</span><br><span class="line">		rep movsb</span><br><span class="line">		push es:[9*4]</span><br><span class="line">		pop es:[200h]</span><br><span class="line">		push es:[9*4+2]</span><br><span class="line">		pop es:[202h]</span><br><span class="line">		cli</span><br><span class="line">		mov word ptr es:[9*4],204h</span><br><span class="line">		mov word ptr es:[9*4+2],0</span><br><span class="line">		sti</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">int9:	push ax</span><br><span class="line">		push bx</span><br><span class="line">		push cx</span><br><span class="line">		push es</span><br><span class="line">		in al,60h</span><br><span class="line">		pushf		;保存标志寄存器</span><br><span class="line">		pushf</span><br><span class="line">		pop bx</span><br><span class="line">		and bh,11111100b</span><br><span class="line">		push bx</span><br><span class="line">		popf		;修改if和tf  </span><br><span class="line">		call dword ptr es:[200h]</span><br><span class="line">		cmp al,3bh</span><br><span class="line">		jne int9ret</span><br><span class="line">		mov ax,0b800h</span><br><span class="line">		mov es,ax</span><br><span class="line">		mov bx,1</span><br><span class="line">		mov cx,2000</span><br><span class="line">s:		inc byte ptr es:[bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">		pop cx</span><br><span class="line">		pop bx</span><br><span class="line">		pop ax</span><br><span class="line">		iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>我一运行就不能输入</p>
<h3 id="指令系统总结"><a href="#指令系统总结" class="headerlink" title="指令系统总结"></a>指令系统总结</h3><p>8086CPU 提供以下几大类指令</p>
<ol>
<li><p>数据传送指令<br>比如:mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送</p>
</li>
<li><p>算术运算指令<br>比如:add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算，它们的执行结果影响标志寄存器的:sf、zf、of、cf、pf、af位。</p>
</li>
<li><p>逻辑指令</p>
<p>如:and、or、not、xor、test、shl、shr 、sal、sar、rol、ror、rcl、rcr等都是逻辑指令，除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。</p>
</li>
<li><p>转移指令<br>可以修改IP，或同时修改CS 和IP 的指合统称为转移指令。转移指令分为以下几类</p>
<ol>
<li>无条件转移指令，比如:jmp</li>
<li>条件转移指令，比如:jcxz、je、jb、ja、jnb、jna等;</li>
<li>循环指令，比如:loop;</li>
<li>过程，比如:call、ret、retf:</li>
<li>中断，比如int、iret。</li>
</ol>
</li>
<li><p>处理机控制指令<br>这些指令对标志寄存器或其他处理机状态进行设置，比如:cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令</p>
</li>
<li><p>串处理指令<br>这些指令对内存中的批量数据进行处理<br>如:movsb、movsw、cmps、scas、lods、stos等。</p>
<p>若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。</p>
</li>
</ol>
<h2 id="16-直接定址表"><a href="#16-直接定址表" class="headerlink" title="16 直接定址表"></a>16 直接定址表</h2><h3 id="16-1-描述了单元长度的标号"><a href="#16-1-描述了单元长度的标号" class="headerlink" title="16.1 描述了单元长度的标号"></a>16.1 描述了单元长度的标号</h3><p>举例：</p>
<p>下面的程序将code 段中的a标号处的8个数据累加，结果存储到b标号处的字中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:  mov si,offset a</span><br><span class="line">		mov bx,offset b</span><br><span class="line">		mov cx,8</span><br><span class="line">	s:  mov al,cs:[si]</span><br><span class="line">		mov ah,0</span><br><span class="line">		add cs:[bx],ax</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803031628357.png" alt="image-20240803031628357"></p>
<p>16进制24，10进制36</p>
<p>上述程序中所有的标号都只表示内存单元的地址</p>
<p>但是，我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:  mov si,offset a</span><br><span class="line">		mov bx,offset b</span><br><span class="line">		mov cx,8</span><br><span class="line">	s:  mov al,cs:[si]</span><br><span class="line">		mov ah,0</span><br><span class="line">		add cs:[bx],ax</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们在code 段中使用的标号a、b后面没有 <code>:</code> 因此它们是可以同时描述内存地址和单元长度的标号。</p>
</li>
<li><p>标号a描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元;</p>
</li>
<li><p>而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</p>
</li>
<li><p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,b 相当于:mov ax,cs:[8]</span><br><span class="line">mov b,2 相当于:mov word ptr cs:[8],2</span><br><span class="line">inc b 相当于:inc word ptr cs:[8]</span><br><span class="line">在这些指令中，标号b代表了一个内存单元，地址为code:8，长度为2 字节。</span><br></pre></td></tr></table></figure>

<p>对于程序中的a db 1,2,3,4,5,6,7,8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,a[si]</span><br><span class="line">相当于:mov al,cs:0[si]</span><br><span class="line">mov al,a[3]</span><br><span class="line">相当于:mov al,cs:0[3]</span><br><span class="line">mov al,a[bx+si+3]</span><br><span class="line">相当于:mov al,cs:0[bx+si+3]</span><br></pre></td></tr></table></figure>


</li>
<li><p>这种标号我们叫做<strong>数据标号</strong>，他标记了<strong>存储数据的单元的地址和长度</strong></p>
</li>
</ul>
<h3 id="16-2-在其他段中使用数据标号"><a href="#16-2-在其他段中使用数据标号" class="headerlink" title="16.2 在其他段中使用数据标号"></a>16.2 在其他段中使用数据标号</h3><ul>
<li>一般来说，我们不会在代码段中定义数据，而是将数据定义到其他段中。</li>
<li>在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。</li>
<li>注意:在后面加有 <code>:</code> 的地址标号，只能在代码段中使用，不能在其他段中使用。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data;注意这里定义了ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,8</span><br><span class="line">	s:  mov al,a[si]</span><br><span class="line">		mov ah,0</span><br><span class="line">		add b,ax</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803033711192.png" alt="image-20240803033711192"></p>
<p><strong>注意</strong>，如果想在代码段中，直接用数据标号访问数据，则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来，</p>
<p>否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。</p>
<p>因为这些实际编译出的指令，都默认所访问单元的段地址在ds中，而实际要访问的段为data，所以，若要访问正确，在这些指会执行前，ds中必须为 data 段的段地址。<br>则，我们在程序中使用指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>设置ds指向data段。</p>
<p>我们可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。<br>比如 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b//offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>数据标号c处存储的两个字型数据为标号a、b的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b//a的段地址和偏移地址,b的段地址和偏移地址</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>seg操作符，功能为取得某一标号的段地址</p>
<h3 id="16-3-直接定址表"><a href="#16-3-直接定址表" class="headerlink" title="16.3 直接定址表"></a>16.3 直接定址表</h3><p><strong>任务</strong></p>
<p>编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据</p>
<p><strong>分析</strong></p>
<p>一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个ASCII 字符。我们当然要用这16个字符来显示十六进制数码我们可以将一个byte的高4位和低4位分开，分别用它们的值得到对应的数码字符。比如2Bh，我们可以得到高4 位的值为2，低4 位的值为11。</p>
<p>最简单的方法就是一一比较</p>
<p>但是会很复杂，我们希望的是显然，我们希望能够在数值0<del>15和字符“0”</del>“F”之间找到一种映射关系。这样我们用0<del>15间的任何数值，都可以通过这种映射关系直接得到“0”</del>“F”中对应的字符</p>
<p>数值0<del>9和字符“0”</del>“9“之间的映射 :</p>
<ul>
<li>数值+30h&#x3D;对应字符的ASCII值:</li>
</ul>
<p>但是，10<del>15和“A”</del>“F”之间的映射关系是</p>
<ul>
<li>数值+37h&#x3D;对应字符的ASCII值</li>
</ul>
<p>还是复杂了，我们希望更简单的算法，考虑用同一种映射关系从数值得到字符码</p>
<p><strong>查表法</strong></p>
<p><strong>任务一</strong></p>
<p>具体的做法是，我们建立一张表，表中依次存储字符“0”<del>“F”我们可以通过数值0</del>15直接查找到对应的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov al,2eh</span><br><span class="line">		call showbyte</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">showbyte:jmp short show</span><br><span class="line">		 table db &#x27;0123456789ABCDEF&#x27; ;字符表</span><br><span class="line">		</span><br><span class="line">show:	push bx</span><br><span class="line">		push es</span><br><span class="line">		mov ah,al</span><br><span class="line">		shr ah,1</span><br><span class="line">		shr ah,1</span><br><span class="line">		shr ah,1	;右移4位，ah中得到高4位的值</span><br><span class="line">		shr ah,1</span><br><span class="line">		and al,00001111b;a1中为低4位的值</span><br><span class="line">		mov bl,ah</span><br><span class="line">		mov bh,0</span><br><span class="line">		mov ah,table[bx];用高4位的值作为相对于 table 的偏移，取得对应的字符</span><br><span class="line">		mov bx,0b800h</span><br><span class="line">		mov es,bx</span><br><span class="line">		mov es:[160*12+40*2],ah</span><br><span class="line">		mov bl,al</span><br><span class="line">		mov bh,0</span><br><span class="line">		mov al,table[bx];用低4位的值作为相对于 table 的偏移，取得对应的字符</span><br><span class="line">		mov es:[160*12+40*2+2],al</span><br><span class="line">		pop es</span><br><span class="line">		pop bx</span><br><span class="line">		ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803200158894.png" alt="image-20240803200158894"></p>
<ul>
<li><p>利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。</p>
<p>目的</p>
<ol>
<li>为了算法清晰简洁</li>
<li>为了加快运算速度</li>
<li>为了使程序易于扩充</li>
</ol>
</li>
</ul>
<p><strong>任务二</strong></p>
<p>编写一个子程序，计算sin(x)，x属于{0°,30°,60°,90°,120°,150°,180°}，并在屏幕中间显示计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov al,30h</span><br><span class="line">		call showsin</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">showsin:jmp short show</span><br><span class="line">		table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180</span><br><span class="line">		ag0 db &#x27;0&#x27;,0</span><br><span class="line">		ag30 db &#x27;0.5&#x27;,0</span><br><span class="line">		ag60 db &#x27;0.866&#x27;,0</span><br><span class="line">		ag90 db &#x27;1&#x27;,0</span><br><span class="line">		ag120 db&#x27;0.866&#x27;,0</span><br><span class="line">		ag150 db &#x27;0.5&#x27;,0</span><br><span class="line">		ag180 db &#x27;0&#x27;,0</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">show:	push bx</span><br><span class="line">		push es</span><br><span class="line">		push si</span><br><span class="line">		mov bx,0b800h</span><br><span class="line">		mov es,bx</span><br><span class="line">		mov ah,0</span><br><span class="line">		mov bl,30</span><br><span class="line">		div bl</span><br><span class="line">		mov bl,al</span><br><span class="line">		mov bh,0</span><br><span class="line">		add bx,bx;table中每个地址以字型单元的形式存储</span><br><span class="line">		mov bx,table[bx];这时bX储存的是字符串的地址</span><br><span class="line">		mov si,[160*12+40*2]</span><br><span class="line">		</span><br><span class="line">shows:	mov ah,cs:[bx]</span><br><span class="line">		cmp ah,0;与上一条指令一起判断是否接触到0</span><br><span class="line">		je showret;接触到0就跳转退出</span><br><span class="line">		mov es:[si],ah;录入显存</span><br><span class="line">		inc bx</span><br><span class="line">		add si,2;指向下一个字符</span><br><span class="line">		jmp short shows</span><br><span class="line">showret:pop si</span><br><span class="line">		pop es</span><br><span class="line">		pop dx</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803202801378.png" alt="image-20240803202801378"></p>
<h3 id="16-4-程序入口地址的直接定址表"><a href="#16-4-程序入口地址的直接定址表" class="headerlink" title="16.4 程序入口地址的直接定址表"></a>16.4 程序入口地址的直接定址表</h3><p><strong>问题</strong></p>
<p>实现一个子程序setscreen，为显示输出提供如下功能:</p>
<ol>
<li>清屏。</li>
<li>设置前景色</li>
<li>设置背景色</li>
<li>向上滚动一行</li>
</ol>
<p>入口参数说明</p>
<ol>
<li><p>用ah 寄存器传递功能号<br>-0 表示清屏<br>-1 表示设置前景色<br>-2 表示设置背景色<br>-3 表示向上滚动一行;</p>
</li>
<li><p>对于2、3号功能，用al传送颜色值</p>
<p>(al)&#x3D;{0,1,2,3,4,5,6,7}</p>
</li>
</ol>
<p><strong>1.清屏</strong></p>
<p>将显存中当前屏幕中的字符设为空格符</p>
<p>**2.设置前景色 **</p>
<p>设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位;</p>
<p><strong>3.设置背景色</strong></p>
<p>设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位;</p>
<p><strong>4. 向上滚动一行</strong></p>
<p>依次将第 n+1行的内容复制到第n行处:最后一行为空</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204647580.png" alt="image-20240803204647580"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204719251.png" alt="image-20240803204719251"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204818301.png" alt="image-20240803204818301"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803205000691.png" alt="image-20240803205000691"></p>
<p>我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。</p>
<p>对应的映射关系为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能号*2=对应的功能子程序在地址表中的偏移</span><br></pre></td></tr></table></figure>

<h2 id="17-使用BOIS进行键盘的输入和磁盘读写"><a href="#17-使用BOIS进行键盘的输入和磁盘读写" class="headerlink" title="17 使用BOIS进行键盘的输入和磁盘读写"></a>17 使用BOIS进行键盘的输入和磁盘读写</h2><p>罗云彬win32</p>
<p>大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。<br>程序和数据通常需要长期存储，磁盘是最常用的存储设备。<br>BIOS 为这两种外设的I&#x2F;O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。</p>
<h3 id="17-1-int-9中断例程对键盘输入的处理"><a href="#17-1-int-9中断例程对键盘输入的处理" class="headerlink" title="17.1 int 9中断例程对键盘输入的处理"></a>17.1 int 9中断例程对键盘输入的处理</h3><ul>
<li>CPU 在9号中断发生后，执行int 9中断例程，从60h 端口读出扫描码，并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</li>
<li>所以，一般的键盘输入，在CPU 执行完int9中断例程后，都放到了键盘缓冲区中。</li>
<li>键盘缓冲区中有16 个字单元，可以存储15个按键的扫描码和对应的ASCII码。</li>
</ul>
<h3 id="17-2-使用int-16H中断例程读取键盘缓冲区"><a href="#17-2-使用int-16H中断例程读取键盘缓冲区" class="headerlink" title="17.2 使用int 16H中断例程读取键盘缓冲区"></a>17.2 使用int 16H中断例程读取键盘缓冲区</h3><ul>
<li><p>BIOS提供了int 16h 中断例程供程序员调用。</p>
</li>
<li><p>int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。</p>
</li>
<li><p>下面的指令从键盘缓冲区中读取一个键盘输入并且将其从缓冲区中删除:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">结果: (ah)=扫描码,(al)=ASCII码</span><br></pre></td></tr></table></figure>


</li>
<li><p>int 16H中断程序的0号功能</p>
<ol>
<li>检测键盘缓冲区中是否有数据</li>
<li>没有则继续做第1步;</li>
<li>读取缓冲区第一个字单元中的键盘输入</li>
<li>将读取的扫描码送入ah，ASCII码送入a</li>
<li>将已读取的键盘输入从缓冲区中删除</li>
</ol>
</li>
<li><p>可见，BIOS的int9中断例程和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h 中断例程从缓冲区中读出</p>
</li>
<li><p>它们写入和读出的时机不同，int9中断例程在有键按下的时候向键盘缓冲区中写入数据;</p>
</li>
<li><p>而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p>
</li>
</ul>
<p><strong>编程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ah,0</span><br><span class="line">		int 16H</span><br><span class="line">		cmp al,&#x27;r&#x27;</span><br><span class="line">		jne g</span><br><span class="line">		mov al,4</span><br><span class="line">		call sub2</span><br><span class="line">		jmp over</span><br><span class="line">g:		cmp al,&#x27;g&#x27;</span><br><span class="line">		jne b</span><br><span class="line">		mov al,2</span><br><span class="line">		call sub2</span><br><span class="line">		jmp over</span><br><span class="line">b:		mov al,1</span><br><span class="line">		call sub2</span><br><span class="line">		jmp over</span><br><span class="line">over:	mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">				</span><br><span class="line">		</span><br><span class="line">sub2:	push bx</span><br><span class="line">		push cx</span><br><span class="line">		push es</span><br><span class="line">		mov bx,0b800h</span><br><span class="line">		mov es,bx</span><br><span class="line">		mov bx,1</span><br><span class="line">		mov cx,2000</span><br><span class="line">sub2s:	and byte ptr es:[bx],11111000b</span><br><span class="line">		or es:[bx],al</span><br><span class="line">		add bx,2</span><br><span class="line">		loop sub2s</span><br><span class="line">		pop es</span><br><span class="line">		pop cx</span><br><span class="line">		pop bx</span><br><span class="line">		ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240803213852879.png" alt="image-20240803213852879"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803213908995.png" alt="image-20240803213908995"></p>
<p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240803213923673.png" alt="image-20240803213923673"></p>
<h3 id="17-3-字符串的输入"><a href="#17-3-字符串的输入" class="headerlink" title="17.3 字符串的输入"></a>17.3 字符串的输入</h3><p>最基本的字符串输入程序，需要具备下面的功能</p>
<ol>
<li>在输入的同时需要显示这个字符串;</li>
<li>一般在输入回车符后，字符串输入结束</li>
<li>能够删除已经输入的字符。</li>
</ol>
<p>对于这三个功能，我们可以想象在DOS中，输入命令行时的情况。</p>
<p><strong>实现功能所需要的参数</strong></p>
<ol>
<li>(dh)、(dl)&#x3D;字符串在屏幕上显示的行、列位置</li>
<li>ds:si指向字符串的存储空间，字符串以0为结尾符</li>
</ol>
<p><strong>分析</strong></p>
<ol>
<li><p>字符的输入和删除<br>每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的。</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230124088.png" alt="image-20240803230124088"></p>
<ul>
<li>可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。</li>
<li>这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。</li>
<li>字符栈中的所有字符，从栈底到栈顶，组成一个字符串。</li>
</ul>
</li>
<li><p>在输入回车符后，字符串输入结束。</p>
<p>输入回车符后，我们可以在字符串中加入0，表示字符串结束。</p>
</li>
<li><p>在输入的同时需要显示这个字符串。</p>
<p>每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p>
</li>
<li><p>程序的处理过程。现在我们可以简单地确定程序的处理过程如下:</p>
<ol>
<li>调用int 16h读取键盘输入;</li>
<li>如果是字符，进入字符栈，显示字符栈中的所有字符;继续执行1</li>
<li>如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符;继续执行1</li>
<li>如果是Enter 键，向字符栈中压入0，返回</li>
</ol>
</li>
</ol>
<ul>
<li>这个程序比较常使用，我们可以将他写成子程序</li>
</ul>
<p><strong>子程序</strong></p>
<p>参数说明：</p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230655212.png" alt="image-20240803230655212"></p>
<p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230718374.png" alt="image-20240803230718374"></p>
<ul>
<li>可以通过，一段内存表示栈空间和一个内存存储栈顶，来实现一个简单的栈</li>
</ul>
<h3 id="17-4-应用int-13h中的中断例程对磁盘进行读写"><a href="#17-4-应用int-13h中的中断例程对磁盘进行读写" class="headerlink" title="17.4 应用int 13h中的中断例程对磁盘进行读写"></a>17.4 应用int 13h中的中断例程对磁盘进行读写</h3><p>以3.5英寸的软盘为例</p>
<p>常用的3.5英寸的软盘的结构</p>
<p>分为上下两面，每面有80个磁道，每个磁道又分为18个扇面，每个扇面的大小为512B</p>
<p>总容量为：<code>2面*80磁道*18扇区*512B=1440KB约等于1.44MB</code></p>
<p>磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。</p>
<p>注意，我们只能以扇区为单付对磁盘进行读写在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始</p>
<p>BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和便件相关的工作。</p>
<p>我们可以通过调用BIOS中断例程来访问磁盘:</p>
<p>BOIS提供的访问磁盘的中断例程为int 13H</p>
<p><strong>演示</strong></p>
<p>读取0面0道1扇面的内容到0:200</p>
<ol>
<li><p><strong>入口参数</strong></p>
<ul>
<li>(ah)&#x3D;int 13h的功能号(2表示读扇区)</li>
<li>(al)&#x3D;读取的扇区数</li>
<li>(ch)&#x3D;磁道号</li>
<li>(cl)&#x3D;扇区号</li>
<li>(dh)&#x3D;磁头号(对于软驱即面号，因为一个面用一个磁头来读写)</li>
<li>(dl)&#x3D;驱动器号<ul>
<li>软驱从0开始，0:软驱A，1:软驱B</li>
<li>硬盘从80h开始，80h:硬盘C，81h:硬盘D</li>
</ul>
</li>
<li>es:bx指向接收此扇区读入数据的内存区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,2</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>返回参数</strong></p>
<ul>
<li>操作成功：(ah)&#x3D;0,(al)&#x3D;读入的扇面数</li>
<li>操作失败：(ah)&#x3D;出错代码</li>
</ul>
</li>
</ol>
<p>写入0面0道1扇面的内容到0:200</p>
<ol>
<li><p><strong>入口参数</strong></p>
<ul>
<li><p>(ah)&#x3D;int 13h的功能号(3表示读扇区)</p>
</li>
<li><p>(al)&#x3D;写入的扇区数</p>
</li>
<li><p>(ch)&#x3D;磁道号</p>
</li>
<li><p>(cl)&#x3D;扇区号</p>
</li>
<li><p>(dh)&#x3D;磁头号(对于软驱即面号，因为一个面用一个磁头来读写)</p>
<ul>
<li>(dl)&#x3D;驱动器号<ul>
<li>软驱从0开始，0:软驱A，1:软驱B</li>
<li>硬盘从80h开始，80h:硬盘C，81h:硬盘D</li>
</ul>
</li>
</ul>
</li>
<li><p>es:bx指向接收此扇区写入数据的内存区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,3</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>返回参数</strong></p>
<ul>
<li>操作成功：(ah)&#x3D;0,(al)&#x3D;写入的扇面数</li>
<li>操作失败：(ah)&#x3D;出错代码</li>
</ul>
</li>
</ol>
<p><strong>注意</strong></p>
<p>下面我们要使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要的数据。</p>
<p>如果向软盘的0 面0 道1 扇区中写入了数据，要使软盘在现有的操作系统下可以使用，必须要重新格式化。</p>
<ul>
<li>在编写相关的程序之前，必须要找一张空闲的软盘。在使用int 13h中断例程时一定要注意驱动器号是否正确，千万不要随便对硬盘中的扇区进行写入。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">GoodBrain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">http://example.com/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">G00DBrain blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></div><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="汇编语言学习笔记1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">汇编语言学习笔记1</div></div><div class="info-2"><div class="info-item-1">汇编语言学习笔记1了解汇编语言本词条由“科普中国”科学百科词条编写与应用工作项目 审核 。 汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。 1....</div></div></div></a><a class="pagination-related" href="/2025/03/10/re/PYC%E6%96%87%E4%BB%B6%E9%80%86%E5%90%91/" title="PYC文件逆向"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PYC文件逆向</div></div><div class="info-2"><div class="info-item-1">PYC文件逆向pyc文件是什么？pyc是一种二进制文件，是由Python文件经过编译后所生成的文件，它是一种字节码文件，Python文件变成pyc文件后，加载的速度有所提高，最终经过python解释器转换成机器码运行 pyc文件有什么用？ 让python文件的加载更快 可通过pyc文件得到py文件的源码  pyc文件怎么获得 通过exe转py  1python pyinstxtractor-ng.py white_give.exe  （详细看文章exe转py）  通过py转pyc   命令行 1python3.6 -m py_compile test.py  2.脚本 12&gt;&gt;&gt; import py_compile  &gt;&gt;&gt; py_compile.compile(&#x27;test.py&#x27;)  pyc文件反编译通过pyc文件的反编译可以得到py文件的原码 对逆向工作有帮助  通过uncompyle6 在该文件目录下打开终端 1uncompyle6 -o test.py test.pyc  或 1uncompyle6...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="汇编语言学习笔记1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-01</div><div class="info-item-2">汇编语言学习笔记1</div></div><div class="info-2"><div class="info-item-1">汇编语言学习笔记1了解汇编语言本词条由“科普中国”科学百科词条编写与应用工作项目 审核 。 汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。 1....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/likunvs/images/main/images/96690cdf789a73f71e2908bee479484.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GoodBrain</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="/lkh_258@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">文章插图需搭梯子</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02"><span class="toc-text">汇编语言学习笔记2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">9. 转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-text">9.1 操作符offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">9.2 jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">9.3 依据位移进行转移的jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">9.5 转移的地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-loop%E6%8C%87%E4%BB%A4"><span class="toc-text">9.8 loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-10-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E8%BD%AC%E7%A7%BB%E4%BD%8D%E7%A7%BB%E8%B6%85%E7%95%8C%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-text">9.10 编译器对转移位移超界的检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-call%E5%92%8Cret%E6%8C%87%E4%BB%A4"><span class="toc-text">10. call和ret指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-ret%E5%92%8Cretf"><span class="toc-text">10.1 ret和retf</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%80%A6%E2%80%A6"><span class="toc-text">……</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-call%E6%8C%87%E4%BB%A4"><span class="toc-text">10.2 call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">10.3 依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">10.5 转移地址在寄存器中的call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">10.9 模块化程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10-%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98"><span class="toc-text">10.10 参数和结果的传递问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-11-%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">10.11 批量数据的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-12-%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">10.12 寄存器冲突的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-adc%E6%8C%87%E4%BB%A4"><span class="toc-text">11.6 adc指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-text">11.9检测比较结果的条件转移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E8%BD%AC%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">11.10 DF标志和串转送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-11-pushf%E5%92%8Cpopf"><span class="toc-text">11.11 pushf和popf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-text">12. 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%86%85%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-text">12.1 内中断的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">12.2 中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-text">12.3 中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="toc-text">12.4 中断过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4"><span class="toc-text">12.5 中断处理程序和iret指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E9%99%A4%E6%B3%95%E9%94%99%E8%AF%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">12.6 除法错误中断的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%860%E5%8F%B7%E4%B8%AD%E6%96%AD"><span class="toc-text">12.7 编译处理0号中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-%E5%AE%89%E8%A3%85"><span class="toc-text">12.8 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-do0"><span class="toc-text">12.9 do0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F"><span class="toc-text">12.10 设置中断向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-11-%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD"><span class="toc-text">12.11 单步中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-12-%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">12.12 响应中断的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-int%E6%8C%87%E4%BB%A4"><span class="toc-text">13 int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-int%E6%8C%87%E4%BB%A4"><span class="toc-text">13.1 int指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E7%BC%96%E5%86%99%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">13.2 编写供应用程序调用的中断例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E5%AF%B9int%EF%BC%8Ciret%E5%92%8C%E6%A0%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">13.3 对int，iret和栈的深入理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-BIOS%E5%92%8CDOS%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">13.4 BIOS和DOS所提供的中断例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-BIOS%E5%92%8CDOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-text">13.5 BIOS和DOS中断例程的安装过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-BIOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">13.6 BIOS中断例程的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-DOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">13.7 DOS中断例程的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%AB%AF%E5%8F%A3"><span class="toc-text">14 端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">14.1 端口的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-CMOS-RAM-%E8%8A%AF%E7%89%87"><span class="toc-text">14.2 CMOS RAM 芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-shl%E5%92%8Cshr%E6%8C%87%E4%BB%A4"><span class="toc-text">14.3 shl和shr指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-CMOS-RAM%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">14.4 CMOS RAM中存储的时间信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-text">15 外中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-text">15.1 接口芯片和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E5%A4%96%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="toc-text">15.2 外中断信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">15.3 PC机键盘的处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E7%BC%96%E5%86%99int-9h%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">15.4 编写int 9h中断例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E5%AE%89%E8%A3%85%E6%96%B0%E7%9A%84int-9-%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">15.5 安装新的int 9 中断例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93"><span class="toc-text">指令系统总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-text">16 直接定址表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E6%8F%8F%E8%BF%B0%E4%BA%86%E5%8D%95%E5%85%83%E9%95%BF%E5%BA%A6%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="toc-text">16.1 描述了单元长度的标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%9C%A8%E5%85%B6%E4%BB%96%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%A0%87%E5%8F%B7"><span class="toc-text">16.2 在其他段中使用数据标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-text">16.3 直接定址表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-text">16.4 程序入口地址的直接定址表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BD%BF%E7%94%A8BOIS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99"><span class="toc-text">17 使用BOIS进行键盘的输入和磁盘读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">17.1 int 9中断例程对键盘输入的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E4%BD%BF%E7%94%A8int-16H%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">17.2 使用int 16H中断例程读取键盘缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-text">17.3 字符串的输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E5%BA%94%E7%94%A8int-13h%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E7%A3%81%E7%9B%98%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99"><span class="toc-text">17.4 应用int 13h中的中断例程对磁盘进行读写</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/09/LLVM/LLVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="PYC文件逆向">PYC文件逆向</a><time datetime="2025-04-09T10:47:49.760Z" title="发表于 2025-04-09 18:47:49">2025-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="TEA加密算法">TEA加密算法</a><time datetime="2025-03-10T12:33:12.511Z" title="发表于 2025-03-10 20:33:12">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/MD5%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MD5加密学习笔记">MD5加密学习笔记</a><time datetime="2025-03-10T12:33:12.496Z" title="发表于 2025-03-10 20:33:12">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/base64%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="base64编码学习笔记">base64编码学习笔记</a><time datetime="2025-03-10T12:33:12.476Z" title="发表于 2025-03-10 20:33:12">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/ASCII%E7%A0%81%E8%A1%A8/" title="ASCII码表">ASCII码表</a><time datetime="2025-03-10T12:33:12.467Z" title="发表于 2025-03-10 20:33:12">2025-03-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: rgba(0, 0, 0, 0);"><div id="footer-wrap"><div class="copyright">&copy;2025 By GoodBrain</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>